-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module GHC.PArr

module Unsafe.Coerce
unsafeCoerce :: a -> b

module Data.Tuple
fst :: (a, b) -> a
snd :: (a, b) -> b
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c

module Data.String
class IsString a
fromString :: IsString a => String -> a
instance IsString [Char]

module Data.Ord
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
instance Ord All
instance Ord Any
instance Ord ArithException
instance Ord ArrayException
instance Ord AsyncException
instance Ord Bool
instance Ord BufferMode
instance Ord CChar
instance Ord CClock
instance Ord CDouble
instance Ord CFloat
instance Ord CInt
instance Ord CIntMax
instance Ord CIntPtr
instance Ord CLDouble
instance Ord CLLong
instance Ord CLong
instance Ord CPtrdiff
instance Ord CSChar
instance Ord CShort
instance Ord CSigAtomic
instance Ord CSize
instance Ord CTime
instance Ord CUChar
instance Ord CUInt
instance Ord CUIntMax
instance Ord CUIntPtr
instance Ord CULLong
instance Ord CULong
instance Ord CUShort
instance Ord CWchar
instance Ord Char
instance Ord ConsoleEvent
instance Ord Double
instance Ord ExitCode
instance Ord Fd
instance Ord Float
instance Ord GeneralCategory
instance Ord IOMode
instance Ord Int
instance Ord Int16
instance Ord Int32
instance Ord Int64
instance Ord Int8
instance Ord IntPtr
instance Ord Integer
instance Ord Ordering
instance Ord SeekMode
instance Ord ThreadId
instance Ord Unique
instance Ord Version
instance Ord Word
instance Ord Word16
instance Ord Word32
instance Ord Word64
instance Ord Word8
instance Ord WordPtr
instance Ord ()
instance (Ord a, Ord b) => Ord (a, b)
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) => Ord (a, b, c, d, e, f)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) => Ord (a, b, c, d, e, f, g)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h) => Ord (a, b, c, d, e, f, g, h)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i) => Ord (a, b, c, d, e, f, g, h, i)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j) => Ord (a, b, c, d, e, f, g, h, i, j)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k) => Ord (a, b, c, d, e, f, g, h, i, j, k)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l) => Ord (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m) => Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) => Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) => Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Ord a => Ord (Dual a)
instance Ord a => Ord (First a)
instance Ord (Fixed a)
instance Ord (ForeignPtr a)
instance Ord (FunPtr a)
instance Ord a => Ord (Last a)
instance Ord a => Ord (Maybe a)
instance Ord a => Ord (Product a)
instance Ord (Ptr a)
instance Integral a => Ord (Ratio a)
instance Ord a => Ord (Sum a)
instance Ord a => Ord [a]
instance (Ix i, Ord e) => Ord (Array i e)
instance (Ord a, Ord b) => Ord (Either a b)
data Ordering
LT :: Ordering
EQ :: Ordering
instance Bounded Ordering
instance Data Ordering
instance Enum Ordering
instance Eq Ordering
instance Ix Ordering
instance Monoid Ordering
instance Ord Ordering
instance Read Ordering
instance Show Ordering
instance Typeable Ordering
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

module Data.Maybe
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
instance Alternative Maybe
instance Applicative Maybe
instance Foldable Maybe
instance Functor Maybe
instance Monad Maybe
instance MonadFix Maybe
instance MonadPlus Maybe
instance Traversable Maybe
instance Typeable1 Maybe
instance Data a => Data (Maybe a)
instance Eq a => Eq (Maybe a)
instance Monoid a => Monoid (Maybe a)
instance Ord a => Ord (Maybe a)
instance Read a => Read (Maybe a)
instance Show a => Show (Maybe a)
maybe :: b -> (a -> b) -> Maybe a -> b
isJust :: Maybe a -> Bool
isNothing :: Maybe a -> Bool
fromJust :: Maybe a -> a
fromMaybe :: a -> Maybe a -> a
listToMaybe :: [a] -> Maybe a
maybeToList :: Maybe a -> [a]
catMaybes :: [Maybe a] -> [a]
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

module Data.Eq
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
instance Eq All
instance Eq Any
instance Eq ArithException
instance Eq ArrayException
instance Eq AsyncException
instance Eq Bool
instance Eq BufferMode
instance Eq BufferState
instance Eq CChar
instance Eq CClock
instance Eq CDouble
instance Eq CFloat
instance Eq CInt
instance Eq CIntMax
instance Eq CIntPtr
instance Eq CLDouble
instance Eq CLLong
instance Eq CLong
instance Eq CPtrdiff
instance Eq CSChar
instance Eq CShort
instance Eq CSigAtomic
instance Eq CSize
instance Eq CTime
instance Eq CUChar
instance Eq CUInt
instance Eq CUIntMax
instance Eq CUIntPtr
instance Eq CULLong
instance Eq CULong
instance Eq CUShort
instance Eq CWchar
instance Eq Char
instance Eq ConsoleEvent
instance Eq Constr
instance Eq ConstrRep
instance Eq DataRep
instance Eq Double
instance Eq Errno
instance Eq Exception
instance Eq ExitCode
instance Eq FDType
instance Eq Fd
instance Eq Fixity
instance Eq Float
instance Eq GeneralCategory
instance Eq Handle
instance Eq HandlePosn
instance Eq HashData
instance Eq IOErrorType
instance Eq IOException
instance Eq IOMode
instance Eq Inserts
instance Eq Int
instance Eq Int16
instance Eq Int32
instance Eq Int64
instance Eq Int8
instance Eq IntPtr
instance Eq Integer
instance Eq Key
instance Eq KeyPr
instance Eq Lexeme
instance Eq Ordering
instance Eq SeekMode
instance Eq ThreadId
instance Eq Timeout
instance Eq TyCon
instance Eq TypeRep
instance Eq Unique
instance Eq Version
instance Eq Word
instance Eq Word16
instance Eq Word32
instance Eq Word64
instance Eq Word8
instance Eq WordPtr
instance Eq ()
instance (Eq a, Eq b) => Eq (a, b)
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq (a, b, c, d, e, f)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq (a, b, c, d, e, f, g)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) => Eq (a, b, c, d, e, f, g, h)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) => Eq (a, b, c, d, e, f, g, h, i)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j) => Eq (a, b, c, d, e, f, g, h, i, j)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k) => Eq (a, b, c, d, e, f, g, h, i, j, k)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l) => Eq (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m) => Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n) => Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) => Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (RealFloat a, Eq a) => Eq (Complex a)
instance Eq a => Eq (Dual a)
instance Eq a => Eq (First a)
instance Eq (Fixed a)
instance Eq (ForeignPtr a)
instance Eq (FunPtr a)
instance Eq (IORef a)
instance Eq a => Eq (Last a)
instance Eq (MVar a)
instance Eq a => Eq (Maybe a)
instance Eq a => Eq (Product a)
instance Eq (Ptr a)
instance (Integral a, Eq a) => Eq (Ratio a)
instance Eq (StableName a)
instance Eq (StablePtr a)
instance Eq a => Eq (Sum a)
instance Eq (TVar a)
instance Eq a => Eq [a]
instance (Ix i, Eq e) => Eq (Array i e)
instance (Eq a, Eq b) => Eq (Either a b)
instance Eq (IOArray i e)
instance Eq (STRef s a)
instance Eq (STArray s i e)

module Data.Either
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b
instance Typeable2 Either
instance Functor (Either a)
instance (Data a, Data b) => Data (Either a b)
instance (Eq a, Eq b) => Eq (Either a b)
instance (Ord a, Ord b) => Ord (Either a b)
instance (Read a, Read b) => Read (Either a b)
instance (Show a, Show b) => Show (Either a b)
either :: (a -> c) -> (b -> c) -> Either a b -> c

module Text.Show
type ShowS = String -> String
class Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS
instance Show All
instance Show Any
instance Show ArithException
instance Show ArrayException
instance Show AsyncException
instance Show Bool
instance Show BufferMode
instance Show CChar
instance Show CClock
instance Show CDouble
instance Show CFloat
instance Show CInt
instance Show CIntMax
instance Show CIntPtr
instance Show CLDouble
instance Show CLLong
instance Show CLong
instance Show CPtrdiff
instance Show CSChar
instance Show CShort
instance Show CSigAtomic
instance Show CSize
instance Show CTime
instance Show CUChar
instance Show CUInt
instance Show CUIntMax
instance Show CUIntPtr
instance Show CULLong
instance Show CULong
instance Show CUShort
instance Show CWchar
instance Show Char
instance Show ConsoleEvent
instance Show Constr
instance Show ConstrRep
instance Show DataRep
instance Show DataType
instance Show Double
instance Show Dynamic
instance Show Exception
instance Show ExitCode
instance Show Fd
instance Show Fixity
instance Show Float
instance Show GeneralCategory
instance Show Handle
instance Show HandlePosn
instance Show HandleType
instance Show HashData
instance Show IOErrorType
instance Show IOException
instance Show IOMode
instance Show Int
instance Show Int16
instance Show Int32
instance Show Int64
instance Show Int8
instance Show IntPtr
instance Show Integer
instance Show Lexeme
instance Show Ordering
instance Show SeekMode
instance Show ThreadId
instance Show TyCon
instance Show TypeRep
instance Show Version
instance Show Word
instance Show Word16
instance Show Word32
instance Show Word64
instance Show Word8
instance Show WordPtr
instance Show ()
instance (Show a, Show b) => Show (a, b)
instance (Show a, Show b, Show c) => Show (a, b, c)
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d)
instance (Show a, Show b, Show c, Show d, Show e) => Show (a, b, c, d, e)
instance (Show a, Show b, Show c, Show d, Show e, Show f) => Show (a, b, c, d, e, f)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g) => Show (a, b, c, d, e, f, g)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h) => Show (a, b, c, d, e, f, g, h)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i) => Show (a, b, c, d, e, f, g, h, i)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j) => Show (a, b, c, d, e, f, g, h, i, j)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k) => Show (a, b, c, d, e, f, g, h, i, j, k)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l) => Show (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Show (a -> b)
instance (RealFloat a, Show a) => Show (Complex a)
instance Show a => Show (Dual a)
instance Show a => Show (First a)
instance HasResolution a => Show (Fixed a)
instance Show (ForeignPtr a)
instance Show (FunPtr a)
instance Show a => Show (Last a)
instance Show a => Show (Maybe a)
instance Show a => Show (Product a)
instance Show (Ptr a)
instance Integral a => Show (Ratio a)
instance Show a => Show (Sum a)
instance Show a => Show [a]
instance (Ix a, Show a, Show b) => Show (Array a b)
instance (Show a, Show b) => Show (Either a b)
instance Show (ST s a)
shows :: Show a => a -> ShowS
showChar :: Char -> ShowS
showString :: String -> ShowS
showParen :: Bool -> ShowS -> ShowS
showListWith :: (a -> ShowS) -> [a] -> ShowS

module Data.Bool
data Bool
False :: Bool
True :: Bool
instance Bounded Bool
instance Data Bool
instance Enum Bool
instance Eq Bool
instance Ix Bool
instance Ord Bool
instance Read Bool
instance Show Bool
instance Storable Bool
instance Typeable Bool
(&&) :: Bool -> Bool -> Bool
(||) :: Bool -> Bool -> Bool
not :: Bool -> Bool
otherwise :: Bool

module Data.Bits
class Num a => Bits a
(.&.) :: Bits a => a -> a -> a
(.|.) :: Bits a => a -> a -> a
xor :: Bits a => a -> a -> a
complement :: Bits a => a -> a
shift :: Bits a => a -> Int -> a
rotate :: Bits a => a -> Int -> a
bit :: Bits a => Int -> a
setBit :: Bits a => a -> Int -> a
clearBit :: Bits a => a -> Int -> a
complementBit :: Bits a => a -> Int -> a
testBit :: Bits a => a -> Int -> Bool
bitSize :: Bits a => a -> Int
isSigned :: Bits a => a -> Bool
shiftL :: Bits a => a -> Int -> a
shiftR :: Bits a => a -> Int -> a
rotateL :: Bits a => a -> Int -> a
rotateR :: Bits a => a -> Int -> a
instance Bits CChar
instance Bits CInt
instance Bits CIntMax
instance Bits CIntPtr
instance Bits CLLong
instance Bits CLong
instance Bits CPtrdiff
instance Bits CSChar
instance Bits CShort
instance Bits CSigAtomic
instance Bits CSize
instance Bits CUChar
instance Bits CUInt
instance Bits CUIntMax
instance Bits CUIntPtr
instance Bits CULLong
instance Bits CULong
instance Bits CUShort
instance Bits CWchar
instance Bits Fd
instance Bits Int
instance Bits Int16
instance Bits Int32
instance Bits Int64
instance Bits Int8
instance Bits IntPtr
instance Bits Integer
instance Bits Word
instance Bits Word16
instance Bits Word32
instance Bits Word64
instance Bits Word8
instance Bits WordPtr

module Control.Monad
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
instance Functor IO
instance Functor Id
instance Functor Maybe
instance Functor ReadP
instance Functor ReadPrec
instance Functor STM
instance Functor ZipList
instance Functor []
instance Ix i => Functor (Array i)
instance Functor (Const m)
instance Functor (Either a)
instance Functor (ST s)
instance Functor (ST s)
instance Monad m => Functor (WrappedMonad m)
instance Functor ((,) a)
instance Functor ((->) r)
instance Arrow a => Functor (WrappedArrow a b)
class Monad m
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a
instance Monad IO
instance Monad Maybe
instance Monad P
instance Monad ReadP
instance Monad ReadPrec
instance Monad STM
instance Monad []
instance ArrowApply a => Monad (ArrowMonad a)
instance Monad (ST s)
instance Monad (ST s)
instance Monad ((->) r)
class Monad m => MonadPlus m
mzero :: MonadPlus m => m a
mplus :: MonadPlus m => m a -> m a -> m a
instance MonadPlus Maybe
instance MonadPlus P
instance MonadPlus ReadP
instance MonadPlus ReadPrec
instance MonadPlus []
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
forM :: Monad m => [a] -> (a -> m b) -> m [b]
forM_ :: Monad m => [a] -> (a -> m b) -> m ()
sequence :: Monad m => [m a] -> m [a]
sequence_ :: Monad m => [m a] -> m ()
(=<<) :: Monad m => (a -> m b) -> m a -> m b
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
forever :: Monad m => m a -> m ()
join :: Monad m => m (m a) -> m a
msum :: MonadPlus m => [m a] -> m a
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
replicateM :: Monad m => Int -> m a -> m [a]
replicateM_ :: Monad m => Int -> m a -> m ()
guard :: MonadPlus m => Bool -> m ()
when :: Monad m => Bool -> m () -> m ()
unless :: Monad m => Bool -> m () -> m ()
liftM :: Monad m => (a1 -> r) -> m a1 -> m r
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
ap :: Monad m => m (a -> b) -> m a -> m b

module Text.ParserCombinators.ReadP
data ReadP a
instance Functor ReadP
instance Monad ReadP
instance MonadPlus ReadP
get :: ReadP Char
look :: ReadP String
(+++) :: ReadP a -> ReadP a -> ReadP a
(<++) :: ReadP a -> ReadP a -> ReadP a
gather :: ReadP a -> ReadP (String, a)
pfail :: ReadP a
satisfy :: (Char -> Bool) -> ReadP Char
char :: Char -> ReadP Char
string :: String -> ReadP String
munch :: (Char -> Bool) -> ReadP String
munch1 :: (Char -> Bool) -> ReadP String
skipSpaces :: ReadP ()
choice :: [ReadP a] -> ReadP a
count :: Int -> ReadP a -> ReadP [a]
between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
option :: a -> ReadP a -> ReadP a
optional :: ReadP a -> ReadP ()
many :: ReadP a -> ReadP [a]
many1 :: ReadP a -> ReadP [a]
skipMany :: ReadP a -> ReadP ()
skipMany1 :: ReadP a -> ReadP ()
sepBy :: ReadP a -> ReadP sep -> ReadP [a]
sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
endBy :: ReadP a -> ReadP sep -> ReadP [a]
endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
manyTill :: ReadP a -> ReadP end -> ReadP [a]
type ReadS a = String -> [(a, String)]
readP_to_S :: ReadP a -> ReadS a
readS_to_P :: ReadS a -> ReadP a

module Text.ParserCombinators.ReadPrec
data ReadPrec a
instance Functor ReadPrec
instance Monad ReadPrec
instance MonadPlus ReadPrec
type Prec = Int
minPrec :: Prec
lift :: ReadP a -> ReadPrec a
prec :: Prec -> ReadPrec a -> ReadPrec a
step :: ReadPrec a -> ReadPrec a
reset :: ReadPrec a -> ReadPrec a
get :: ReadPrec Char
look :: ReadPrec String
(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
pfail :: ReadPrec a
choice :: [ReadPrec a] -> ReadPrec a
readPrec_to_P :: ReadPrec a -> Int -> ReadP a
readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readPrec_to_S :: ReadPrec a -> Int -> ReadS a
readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a

module Text.Read.Lex
data Lexeme
Char :: Char -> Lexeme
String :: String -> Lexeme
Punc :: String -> Lexeme
Ident :: String -> Lexeme
Symbol :: String -> Lexeme
Int :: Integer -> Lexeme
Rat :: Rational -> Lexeme
EOF :: Lexeme
instance Eq Lexeme
instance Read Lexeme
instance Show Lexeme
lex :: ReadP Lexeme
hsLex :: ReadP String
lexChar :: ReadP Char
readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readOctP :: Num a => ReadP a
readDecP :: Num a => ReadP a
readHexP :: Num a => ReadP a

module Data.Word
data Word
instance Bits Word
instance Bounded Word
instance Data Word
instance Enum Word
instance Eq Word
instance Integral Word
instance Ix Word
instance Num Word
instance Ord Word
instance PrintfArg Word
instance Read Word
instance Real Word
instance Show Word
instance Storable Word
instance Typeable Word
data Word8
instance Bits Word8
instance Bounded Word8
instance Data Word8
instance Enum Word8
instance Eq Word8
instance Integral Word8
instance Ix Word8
instance Num Word8
instance Ord Word8
instance PrintfArg Word8
instance Read Word8
instance Real Word8
instance Show Word8
instance Storable Word8
instance Typeable Word8
data Word16
instance Bits Word16
instance Bounded Word16
instance Data Word16
instance Enum Word16
instance Eq Word16
instance Integral Word16
instance Ix Word16
instance Num Word16
instance Ord Word16
instance PrintfArg Word16
instance Read Word16
instance Real Word16
instance Show Word16
instance Storable Word16
instance Typeable Word16
data Word32
instance Bits Word32
instance Bounded Word32
instance Data Word32
instance Enum Word32
instance Eq Word32
instance Integral Word32
instance Ix Word32
instance Num Word32
instance Ord Word32
instance PrintfArg Word32
instance Read Word32
instance Real Word32
instance Show Word32
instance Storable Word32
instance Typeable Word32
data Word64
instance Bits Word64
instance Bounded Word64
instance Data Word64
instance Enum Word64
instance Eq Word64
instance Integral Word64
instance Ix Word64
instance Num Word64
instance Ord Word64
instance PrintfArg Word64
instance Read Word64
instance Real Word64
instance Show Word64
instance Storable Word64
instance Typeable Word64

module Data.Int
data Int
instance Bits Int
instance Bounded Int
instance Data Int
instance Enum Int
instance Eq Int
instance Integral Int
instance Ix Int
instance Num Int
instance Ord Int
instance PrintfArg Int
instance Read Int
instance Real Int
instance Show Int
instance Storable Int
instance Typeable Int
data Int8
instance Bits Int8
instance Bounded Int8
instance Data Int8
instance Enum Int8
instance Eq Int8
instance Integral Int8
instance Ix Int8
instance Num Int8
instance Ord Int8
instance PrintfArg Int8
instance Read Int8
instance Real Int8
instance Show Int8
instance Storable Int8
instance Typeable Int8
data Int16
instance Bits Int16
instance Bounded Int16
instance Data Int16
instance Enum Int16
instance Eq Int16
instance Integral Int16
instance Ix Int16
instance Num Int16
instance Ord Int16
instance PrintfArg Int16
instance Read Int16
instance Real Int16
instance Show Int16
instance Storable Int16
instance Typeable Int16
data Int32
instance Bits Int32
instance Bounded Int32
instance Data Int32
instance Enum Int32
instance Eq Int32
instance Integral Int32
instance Ix Int32
instance Num Int32
instance Ord Int32
instance PrintfArg Int32
instance Read Int32
instance Real Int32
instance Show Int32
instance Storable Int32
instance Typeable Int32
data Int64
instance Bits Int64
instance Bounded Int64
instance Data Int64
instance Enum Int64
instance Eq Int64
instance Integral Int64
instance Ix Int64
instance Num Int64
instance Ord Int64
instance PrintfArg Int64
instance Read Int64
instance Real Int64
instance Show Int64
instance Storable Int64
instance Typeable Int64

module Data.Char
data Char
instance Bounded Char
instance Data Char
instance Enum Char
instance Eq Char
instance IsChar Char
instance Ix Char
instance Ord Char
instance PrintfArg Char
instance Read Char
instance Show Char
instance Storable Char
instance Typeable Char
instance IsString [Char]
type String = [Char]
isControl :: Char -> Bool
isSpace :: Char -> Bool
isLower :: Char -> Bool
isUpper :: Char -> Bool
isAlpha :: Char -> Bool
isAlphaNum :: Char -> Bool
isPrint :: Char -> Bool
isDigit :: Char -> Bool
isOctDigit :: Char -> Bool
isHexDigit :: Char -> Bool
isLetter :: Char -> Bool
isMark :: Char -> Bool
isNumber :: Char -> Bool
isPunctuation :: Char -> Bool
isSymbol :: Char -> Bool
isSeparator :: Char -> Bool
isAscii :: Char -> Bool
isLatin1 :: Char -> Bool
isAsciiUpper :: Char -> Bool
isAsciiLower :: Char -> Bool
data GeneralCategory
UppercaseLetter :: GeneralCategory
LowercaseLetter :: GeneralCategory
TitlecaseLetter :: GeneralCategory
ModifierLetter :: GeneralCategory
OtherLetter :: GeneralCategory
NonSpacingMark :: GeneralCategory
SpacingCombiningMark :: GeneralCategory
EnclosingMark :: GeneralCategory
DecimalNumber :: GeneralCategory
LetterNumber :: GeneralCategory
OtherNumber :: GeneralCategory
ConnectorPunctuation :: GeneralCategory
DashPunctuation :: GeneralCategory
OpenPunctuation :: GeneralCategory
ClosePunctuation :: GeneralCategory
InitialQuote :: GeneralCategory
FinalQuote :: GeneralCategory
OtherPunctuation :: GeneralCategory
MathSymbol :: GeneralCategory
CurrencySymbol :: GeneralCategory
ModifierSymbol :: GeneralCategory
OtherSymbol :: GeneralCategory
Space :: GeneralCategory
LineSeparator :: GeneralCategory
ParagraphSeparator :: GeneralCategory
Control :: GeneralCategory
Format :: GeneralCategory
Surrogate :: GeneralCategory
PrivateUse :: GeneralCategory
NotAssigned :: GeneralCategory
instance Bounded GeneralCategory
instance Enum GeneralCategory
instance Eq GeneralCategory
instance Ix GeneralCategory
instance Ord GeneralCategory
instance Read GeneralCategory
instance Show GeneralCategory
generalCategory :: Char -> GeneralCategory
toUpper :: Char -> Char
toLower :: Char -> Char
toTitle :: Char -> Char
digitToInt :: Char -> Int
intToDigit :: Int -> Char
ord :: Char -> Int
chr :: Int -> Char
showLitChar :: Char -> ShowS
lexLitChar :: ReadS String
readLitChar :: ReadS Char

module Data.List
(++) :: [a] -> [a] -> [a]
head :: [a] -> a
last :: [a] -> a
tail :: [a] -> [a]
init :: [a] -> [a]
null :: [a] -> Bool
length :: [a] -> Int
map :: (a -> b) -> [a] -> [b]
reverse :: [a] -> [a]
intersperse :: a -> [a] -> [a]
intercalate :: [a] -> [[a]] -> [a]
transpose :: [[a]] -> [[a]]
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl1 :: (a -> a -> a) -> [a] -> a
foldl1' :: (a -> a -> a) -> [a] -> a
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr1 :: (a -> a -> a) -> [a] -> a
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]
and :: [Bool] -> Bool
or :: [Bool] -> Bool
any :: (a -> Bool) -> [a] -> Bool
all :: (a -> Bool) -> [a] -> Bool
sum :: Num a => [a] -> a
product :: Num a => [a] -> a
maximum :: Ord a => [a] -> a
minimum :: Ord a => [a] -> a
scanl :: (a -> b -> a) -> a -> [b] -> [a]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
iterate :: (a -> a) -> a -> [a]
repeat :: a -> [a]
replicate :: Int -> a -> [a]
cycle :: [a] -> [a]
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
group :: Eq a => [a] -> [[a]]
inits :: [a] -> [[a]]
tails :: [a] -> [[a]]
isPrefixOf :: Eq a => [a] -> [a] -> Bool
isSuffixOf :: Eq a => [a] -> [a] -> Bool
isInfixOf :: Eq a => [a] -> [a] -> Bool
elem :: Eq a => a -> [a] -> Bool
notElem :: Eq a => a -> [a] -> Bool
lookup :: Eq a => a -> [(a, b)] -> Maybe b
find :: (a -> Bool) -> [a] -> Maybe a
filter :: (a -> Bool) -> [a] -> [a]
partition :: (a -> Bool) -> [a] -> ([a], [a])
(!!) :: [a] -> Int -> a
elemIndex :: Eq a => a -> [a] -> Maybe Int
elemIndices :: Eq a => a -> [a] -> [Int]
findIndex :: (a -> Bool) -> [a] -> Maybe Int
findIndices :: (a -> Bool) -> [a] -> [Int]
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
nub :: Eq a => [a] -> [a]
delete :: Eq a => a -> [a] -> [a]
(\\) :: Eq a => [a] -> [a] -> [a]
union :: Eq a => [a] -> [a] -> [a]
intersect :: Eq a => [a] -> [a] -> [a]
sort :: Ord a => [a] -> [a]
insert :: Ord a => a -> [a] -> [a]
nubBy :: (a -> a -> Bool) -> [a] -> [a]
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
sortBy :: (a -> a -> Ordering) -> [a] -> [a]
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
maximumBy :: (a -> a -> Ordering) -> [a] -> a
minimumBy :: (a -> a -> Ordering) -> [a] -> a
genericLength :: Num i => [b] -> i
genericTake :: Integral i => i -> [a] -> [a]
genericDrop :: Integral i => i -> [a] -> [a]
genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
genericIndex :: Integral a => [b] -> a -> b
genericReplicate :: Integral i => i -> a -> [a]

module Numeric
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
showInt :: Integral a => a -> ShowS
showHex :: Integral a => a -> ShowS
showOct :: Integral a => a -> ShowS
showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
showGFloat :: RealFloat a => Maybe Int -> a -> ShowS
showFloat :: RealFloat a => a -> ShowS
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
readSigned :: Real a => ReadS a -> ReadS a
readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
readDec :: Num a => ReadS a
readOct :: Num a => ReadS a
readHex :: Num a => ReadS a
readFloat :: RealFrac a => ReadS a
lexDigits :: ReadS String
fromRat :: RealFloat a => Rational -> a

module Foreign.C.Types
data CChar
instance Bits CChar
instance Bounded CChar
instance Enum CChar
instance Eq CChar
instance Integral CChar
instance Num CChar
instance Ord CChar
instance Read CChar
instance Real CChar
instance Show CChar
instance Storable CChar
instance Typeable CChar
data CSChar
instance Bits CSChar
instance Bounded CSChar
instance Enum CSChar
instance Eq CSChar
instance Integral CSChar
instance Num CSChar
instance Ord CSChar
instance Read CSChar
instance Real CSChar
instance Show CSChar
instance Storable CSChar
instance Typeable CSChar
data CUChar
instance Bits CUChar
instance Bounded CUChar
instance Enum CUChar
instance Eq CUChar
instance Integral CUChar
instance Num CUChar
instance Ord CUChar
instance Read CUChar
instance Real CUChar
instance Show CUChar
instance Storable CUChar
instance Typeable CUChar
data CShort
instance Bits CShort
instance Bounded CShort
instance Enum CShort
instance Eq CShort
instance Integral CShort
instance Num CShort
instance Ord CShort
instance Read CShort
instance Real CShort
instance Show CShort
instance Storable CShort
instance Typeable CShort
data CUShort
instance Bits CUShort
instance Bounded CUShort
instance Enum CUShort
instance Eq CUShort
instance Integral CUShort
instance Num CUShort
instance Ord CUShort
instance Read CUShort
instance Real CUShort
instance Show CUShort
instance Storable CUShort
instance Typeable CUShort
data CInt
instance Bits CInt
instance Bounded CInt
instance Enum CInt
instance Eq CInt
instance Integral CInt
instance Num CInt
instance Ord CInt
instance Read CInt
instance Real CInt
instance Show CInt
instance Storable CInt
instance Typeable CInt
data CUInt
instance Bits CUInt
instance Bounded CUInt
instance Enum CUInt
instance Eq CUInt
instance Integral CUInt
instance Num CUInt
instance Ord CUInt
instance Read CUInt
instance Real CUInt
instance Show CUInt
instance Storable CUInt
instance Typeable CUInt
data CLong
instance Bits CLong
instance Bounded CLong
instance Enum CLong
instance Eq CLong
instance Integral CLong
instance Num CLong
instance Ord CLong
instance Read CLong
instance Real CLong
instance Show CLong
instance Storable CLong
instance Typeable CLong
data CULong
instance Bits CULong
instance Bounded CULong
instance Enum CULong
instance Eq CULong
instance Integral CULong
instance Num CULong
instance Ord CULong
instance Read CULong
instance Real CULong
instance Show CULong
instance Storable CULong
instance Typeable CULong
data CPtrdiff
instance Bits CPtrdiff
instance Bounded CPtrdiff
instance Enum CPtrdiff
instance Eq CPtrdiff
instance Integral CPtrdiff
instance Num CPtrdiff
instance Ord CPtrdiff
instance Read CPtrdiff
instance Real CPtrdiff
instance Show CPtrdiff
instance Storable CPtrdiff
instance Typeable CPtrdiff
data CSize
instance Bits CSize
instance Bounded CSize
instance Enum CSize
instance Eq CSize
instance Integral CSize
instance Num CSize
instance Ord CSize
instance Read CSize
instance Real CSize
instance Show CSize
instance Storable CSize
instance Typeable CSize
data CWchar
instance Bits CWchar
instance Bounded CWchar
instance Enum CWchar
instance Eq CWchar
instance Integral CWchar
instance Num CWchar
instance Ord CWchar
instance Read CWchar
instance Real CWchar
instance Show CWchar
instance Storable CWchar
instance Typeable CWchar
data CSigAtomic
instance Bits CSigAtomic
instance Bounded CSigAtomic
instance Enum CSigAtomic
instance Eq CSigAtomic
instance Integral CSigAtomic
instance Num CSigAtomic
instance Ord CSigAtomic
instance Read CSigAtomic
instance Real CSigAtomic
instance Show CSigAtomic
instance Storable CSigAtomic
instance Typeable CSigAtomic
data CLLong
instance Bits CLLong
instance Bounded CLLong
instance Enum CLLong
instance Eq CLLong
instance Integral CLLong
instance Num CLLong
instance Ord CLLong
instance Read CLLong
instance Real CLLong
instance Show CLLong
instance Storable CLLong
instance Typeable CLLong
data CULLong
instance Bits CULLong
instance Bounded CULLong
instance Enum CULLong
instance Eq CULLong
instance Integral CULLong
instance Num CULLong
instance Ord CULLong
instance Read CULLong
instance Real CULLong
instance Show CULLong
instance Storable CULLong
instance Typeable CULLong
data CIntPtr
instance Bits CIntPtr
instance Bounded CIntPtr
instance Enum CIntPtr
instance Eq CIntPtr
instance Integral CIntPtr
instance Num CIntPtr
instance Ord CIntPtr
instance Read CIntPtr
instance Real CIntPtr
instance Show CIntPtr
instance Storable CIntPtr
instance Typeable CIntPtr
data CUIntPtr
instance Bits CUIntPtr
instance Bounded CUIntPtr
instance Enum CUIntPtr
instance Eq CUIntPtr
instance Integral CUIntPtr
instance Num CUIntPtr
instance Ord CUIntPtr
instance Read CUIntPtr
instance Real CUIntPtr
instance Show CUIntPtr
instance Storable CUIntPtr
instance Typeable CUIntPtr
data CIntMax
instance Bits CIntMax
instance Bounded CIntMax
instance Enum CIntMax
instance Eq CIntMax
instance Integral CIntMax
instance Num CIntMax
instance Ord CIntMax
instance Read CIntMax
instance Real CIntMax
instance Show CIntMax
instance Storable CIntMax
instance Typeable CIntMax
data CUIntMax
instance Bits CUIntMax
instance Bounded CUIntMax
instance Enum CUIntMax
instance Eq CUIntMax
instance Integral CUIntMax
instance Num CUIntMax
instance Ord CUIntMax
instance Read CUIntMax
instance Real CUIntMax
instance Show CUIntMax
instance Storable CUIntMax
instance Typeable CUIntMax
data CClock
instance Enum CClock
instance Eq CClock
instance Num CClock
instance Ord CClock
instance Read CClock
instance Real CClock
instance Show CClock
instance Storable CClock
instance Typeable CClock
data CTime
instance Enum CTime
instance Eq CTime
instance Num CTime
instance Ord CTime
instance Read CTime
instance Real CTime
instance Show CTime
instance Storable CTime
instance Typeable CTime
data CFloat
instance Enum CFloat
instance Eq CFloat
instance Floating CFloat
instance Fractional CFloat
instance Num CFloat
instance Ord CFloat
instance Read CFloat
instance Real CFloat
instance RealFloat CFloat
instance RealFrac CFloat
instance Show CFloat
instance Storable CFloat
instance Typeable CFloat
data CDouble
instance Enum CDouble
instance Eq CDouble
instance Floating CDouble
instance Fractional CDouble
instance Num CDouble
instance Ord CDouble
instance Read CDouble
instance Real CDouble
instance RealFloat CDouble
instance RealFrac CDouble
instance Show CDouble
instance Storable CDouble
instance Typeable CDouble
data CLDouble
instance Enum CLDouble
instance Eq CLDouble
instance Floating CLDouble
instance Fractional CLDouble
instance Num CLDouble
instance Ord CLDouble
instance Read CLDouble
instance Real CLDouble
instance RealFloat CLDouble
instance RealFrac CLDouble
instance Show CLDouble
instance Storable CLDouble
instance Typeable CLDouble
data CFile
data CFpos
data CJmpBuf

module Foreign.Storable
class Storable a
sizeOf :: Storable a => a -> Int
alignment :: Storable a => a -> Int
peekElemOff :: Storable a => Ptr a -> Int -> IO a
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
peekByteOff :: Storable a => Ptr b -> Int -> IO a
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
peek :: Storable a => Ptr a -> IO a
poke :: Storable a => Ptr a -> a -> IO ()
instance Storable Bool
instance Storable Char
instance Storable Double
instance Storable Fd
instance Storable Float
instance Storable Int
instance Storable Int16
instance Storable Int32
instance Storable Int64
instance Storable Int8
instance Storable IntPtr
instance Storable Word
instance Storable Word16
instance Storable Word32
instance Storable Word64
instance Storable Word8
instance Storable WordPtr
instance Storable (FunPtr a)
instance Storable (Ptr a)
instance Storable (StablePtr a)

module Data.Typeable
class Typeable a
typeOf :: Typeable a => a -> TypeRep
instance Typeable ArithException
instance Typeable ArrayException
instance Typeable AsyncException
instance Typeable Bool
instance Typeable Char
instance Typeable ConsoleEvent
instance Typeable DataType
instance Typeable Double
instance Typeable Dynamic
instance Typeable Exception
instance Typeable Fd
instance Typeable Float
instance Typeable Handle
instance Typeable IOException
instance Typeable Int
instance Typeable Int16
instance Typeable Int32
instance Typeable Int64
instance Typeable Int8
instance Typeable IntPtr
instance Typeable Integer
instance Typeable Ordering
instance Typeable QSem
instance Typeable QSemN
instance Typeable RealWorld
instance Typeable ThreadId
instance Typeable Timeout
instance Typeable TyCon
instance Typeable TypeRep
instance Typeable Version
instance Typeable Word
instance Typeable Word16
instance Typeable Word32
instance Typeable Word64
instance Typeable Word8
instance Typeable WordPtr
instance Typeable ()
instance (Typeable1 s, Typeable a) => Typeable (s a)
cast :: (Typeable a, Typeable b) => a -> Maybe b
gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
data TypeRep
instance Data TypeRep
instance Eq TypeRep
instance Show TypeRep
instance Typeable TypeRep
data TyCon
instance Data TyCon
instance Eq TyCon
instance Show TyCon
instance Typeable TyCon
showsTypeRep :: TypeRep -> ShowS
mkTyCon :: String -> TyCon
mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
mkAppTy :: TypeRep -> TypeRep -> TypeRep
mkFunTy :: TypeRep -> TypeRep -> TypeRep
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
typeRepTyCon :: TypeRep -> TyCon
typeRepArgs :: TypeRep -> [TypeRep]
tyConString :: TyCon -> String
typeRepKey :: TypeRep -> IO Int
class Typeable1 t
typeOf1 :: Typeable1 t => t a -> TypeRep
instance Typeable1 Chan
instance Typeable1 Complex
instance Typeable1 ForeignPtr
instance Typeable1 FunPtr
instance Typeable1 IO
instance Typeable1 IORef
instance Typeable1 MVar
instance Typeable1 Maybe
instance Typeable1 Ptr
instance Typeable1 Ratio
instance Typeable1 STM
instance Typeable1 StableName
instance Typeable1 StablePtr
instance Typeable1 TVar
instance Typeable1 Weak
instance Typeable1 []
instance (Typeable2 s, Typeable a) => Typeable1 (s a)
class Typeable2 t
typeOf2 :: Typeable2 t => t a b -> TypeRep
instance Typeable2 Array
instance Typeable2 Either
instance Typeable2 ST
instance Typeable2 STRef
instance Typeable2 (,)
instance Typeable2 (->)
instance (Typeable3 s, Typeable a) => Typeable2 (s a)
class Typeable3 t
typeOf3 :: Typeable3 t => t a b c -> TypeRep
instance Typeable3 STArray
instance Typeable3 (,,)
instance (Typeable4 s, Typeable a) => Typeable3 (s a)
class Typeable4 t
typeOf4 :: Typeable4 t => t a b c d -> TypeRep
instance Typeable4 (,,,)
instance (Typeable5 s, Typeable a) => Typeable4 (s a)
class Typeable5 t
typeOf5 :: Typeable5 t => t a b c d e -> TypeRep
instance Typeable5 (,,,,)
instance (Typeable6 s, Typeable a) => Typeable5 (s a)
class Typeable6 t
typeOf6 :: Typeable6 t => t a b c d e f -> TypeRep
instance Typeable6 (,,,,,)
instance (Typeable7 s, Typeable a) => Typeable6 (s a)
class Typeable7 t
typeOf7 :: Typeable7 t => t a b c d e f g -> TypeRep
instance Typeable7 (,,,,,,)
gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))
typeOfDefault :: (Typeable1 t, Typeable a) => t a -> TypeRep
typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
typeOf3Default :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
typeOf4Default :: (Typeable5 t, Typeable a) => t a b c d e -> TypeRep
typeOf5Default :: (Typeable6 t, Typeable a) => t a b c d e f -> TypeRep
typeOf6Default :: (Typeable7 t, Typeable a) => t a b c d e f g -> TypeRep

module Data.HashTable
data HashTable key val
new :: (key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)
insert :: HashTable key val -> key -> val -> IO ()
delete :: HashTable key val -> key -> IO ()
lookup :: HashTable key val -> key -> IO (Maybe val)
update :: HashTable key val -> key -> val -> IO Bool
fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
toList :: HashTable key val -> IO [(key, val)]
hashInt :: Int -> Int32
hashString :: String -> Int32
prime :: Int32
longestChain :: HashTable key val -> IO [(key, val)]

module Data.Dynamic
data Dynamic
instance Show Dynamic
instance Typeable Dynamic
toDyn :: Typeable a => a -> Dynamic
fromDyn :: Typeable a => Dynamic -> a -> a
fromDynamic :: Typeable a => Dynamic -> Maybe a
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
dynApp :: Dynamic -> Dynamic -> Dynamic
dynTypeRep :: Dynamic -> TypeRep

module Foreign.StablePtr
data StablePtr a
instance Typeable1 StablePtr
instance Typeable a => Data (StablePtr a)
instance Eq (StablePtr a)
instance Storable (StablePtr a)
newStablePtr :: a -> IO (StablePtr a)
deRefStablePtr :: StablePtr a -> IO a
freeStablePtr :: StablePtr a -> IO ()
castStablePtrToPtr :: StablePtr a -> Ptr ()
castPtrToStablePtr :: Ptr () -> StablePtr a

module System.IO.Error
type IOError = IOException
userError :: String -> IOError
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError
annotateIOError :: IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError
isAlreadyExistsError :: IOError -> Bool
isDoesNotExistError :: IOError -> Bool
isAlreadyInUseError :: IOError -> Bool
isFullError :: IOError -> Bool
isEOFError :: IOError -> Bool
isIllegalOperation :: IOError -> Bool
isPermissionError :: IOError -> Bool
isUserError :: IOError -> Bool
ioeGetErrorType :: IOError -> IOErrorType
ioeGetLocation :: IOError -> String
ioeGetErrorString :: IOError -> String
ioeGetHandle :: IOError -> Maybe Handle
ioeGetFileName :: IOError -> Maybe FilePath
ioeSetErrorType :: IOError -> IOErrorType -> IOError
ioeSetErrorString :: IOError -> String -> IOError
ioeSetLocation :: IOError -> String -> IOError
ioeSetHandle :: IOError -> Handle -> IOError
ioeSetFileName :: IOError -> FilePath -> IOError
data IOErrorType
instance Eq IOErrorType
instance Show IOErrorType
alreadyExistsErrorType :: IOErrorType
doesNotExistErrorType :: IOErrorType
alreadyInUseErrorType :: IOErrorType
fullErrorType :: IOErrorType
eofErrorType :: IOErrorType
illegalOperationErrorType :: IOErrorType
permissionErrorType :: IOErrorType
userErrorType :: IOErrorType
isAlreadyExistsErrorType :: IOErrorType -> Bool
isDoesNotExistErrorType :: IOErrorType -> Bool
isAlreadyInUseErrorType :: IOErrorType -> Bool
isFullErrorType :: IOErrorType -> Bool
isEOFErrorType :: IOErrorType -> Bool
isIllegalOperationErrorType :: IOErrorType -> Bool
isPermissionErrorType :: IOErrorType -> Bool
isUserErrorType :: IOErrorType -> Bool
ioError :: IOError -> IO a
catch :: IO a -> (IOError -> IO a) -> IO a
try :: IO a -> IO (Either IOError a)
modifyIOError :: (IOError -> IOError) -> IO a -> IO a

module System.IO.Unsafe
unsafePerformIO :: IO a -> a
unsafeInterleaveIO :: IO a -> IO a

module Foreign.Ptr
data Ptr a
instance Typeable1 Ptr
instance Typeable a => Data (Ptr a)
instance Eq (Ptr a)
instance Ord (Ptr a)
instance Show (Ptr a)
instance Storable (Ptr a)
nullPtr :: Ptr a
castPtr :: Ptr a -> Ptr b
plusPtr :: Ptr a -> Int -> Ptr b
alignPtr :: Ptr a -> Int -> Ptr a
minusPtr :: Ptr a -> Ptr b -> Int
data FunPtr a
instance Typeable1 FunPtr
instance Eq (FunPtr a)
instance Ord (FunPtr a)
instance Show (FunPtr a)
instance Storable (FunPtr a)
nullFunPtr :: FunPtr a
castFunPtr :: FunPtr a -> FunPtr b
castFunPtrToPtr :: FunPtr a -> Ptr b
castPtrToFunPtr :: Ptr a -> FunPtr b
freeHaskellFunPtr :: FunPtr a -> IO ()
data IntPtr
instance Bits IntPtr
instance Bounded IntPtr
instance Enum IntPtr
instance Eq IntPtr
instance Integral IntPtr
instance Num IntPtr
instance Ord IntPtr
instance Read IntPtr
instance Real IntPtr
instance Show IntPtr
instance Storable IntPtr
instance Typeable IntPtr
ptrToIntPtr :: Ptr a -> IntPtr
intPtrToPtr :: IntPtr -> Ptr a
data WordPtr
instance Bits WordPtr
instance Bounded WordPtr
instance Enum WordPtr
instance Eq WordPtr
instance Integral WordPtr
instance Num WordPtr
instance Ord WordPtr
instance Read WordPtr
instance Real WordPtr
instance Show WordPtr
instance Storable WordPtr
instance Typeable WordPtr
ptrToWordPtr :: Ptr a -> WordPtr
wordPtrToPtr :: WordPtr -> Ptr a

module Foreign.Marshal.Error
throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
void :: IO a -> IO ()

module Foreign.Concurrent
newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()

module Foreign.ForeignPtr
data ForeignPtr a
instance Typeable a => Data (ForeignPtr a)
instance Eq (ForeignPtr a)
instance Ord (ForeignPtr a)
instance Show (ForeignPtr a)
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
finalizeForeignPtr :: ForeignPtr a -> IO ()
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
touchForeignPtr :: ForeignPtr a -> IO ()
castForeignPtr :: ForeignPtr a -> ForeignPtr b
mallocForeignPtr :: Storable a => IO (ForeignPtr a)
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)

module Foreign.Marshal.Alloc
alloca :: Storable a => (Ptr a -> IO b) -> IO b
allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
malloc :: Storable a => IO (Ptr a)
mallocBytes :: Int -> IO (Ptr a)
realloc :: Storable b => Ptr a -> IO (Ptr b)
reallocBytes :: Ptr a -> Int -> IO (Ptr a)
free :: Ptr a -> IO ()
finalizerFree :: FinalizerPtr a

module Foreign.Marshal.Utils
with :: Storable a => a -> (Ptr a -> IO b) -> IO b
new :: Storable a => a -> IO (Ptr a)
fromBool :: Num a => Bool -> a
toBool :: Num a => a -> Bool
maybeNew :: (a -> IO (Ptr a)) -> Maybe a -> IO (Ptr a)
maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c
maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
copyBytes :: Ptr a -> Ptr a -> Int -> IO ()
moveBytes :: Ptr a -> Ptr a -> Int -> IO ()

module Foreign.Marshal.Array
mallocArray :: Storable a => Int -> IO (Ptr a)
mallocArray0 :: Storable a => Int -> IO (Ptr a)
allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)
reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)
peekArray :: Storable a => Int -> Ptr a -> IO [a]
peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
pokeArray :: Storable a => Ptr a -> [a] -> IO ()
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
newArray :: Storable a => [a] -> IO (Ptr a)
newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b
copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
advancePtr :: Storable a => Ptr a -> Int -> Ptr a

module Foreign.C.String
type CString = Ptr CChar
type CStringLen = (Ptr CChar, Int)
peekCString :: CString -> IO String
peekCStringLen :: CStringLen -> IO String
newCString :: String -> IO CString
newCStringLen :: String -> IO CStringLen
withCString :: String -> (CString -> IO a) -> IO a
withCStringLen :: String -> (CStringLen -> IO a) -> IO a
charIsRepresentable :: Char -> IO Bool
castCharToCChar :: Char -> CChar
castCCharToChar :: CChar -> Char
peekCAString :: CString -> IO String
peekCAStringLen :: CStringLen -> IO String
newCAString :: String -> IO CString
newCAStringLen :: String -> IO CStringLen
withCAString :: String -> (CString -> IO a) -> IO a
withCAStringLen :: String -> (CStringLen -> IO a) -> IO a
type CWString = Ptr CWchar
type CWStringLen = (Ptr CWchar, Int)
peekCWString :: CWString -> IO String
peekCWStringLen :: CWStringLen -> IO String
newCWString :: String -> IO CWString
newCWStringLen :: String -> IO CWStringLen
withCWString :: String -> (CWString -> IO a) -> IO a
withCWStringLen :: String -> (CWStringLen -> IO a) -> IO a

module Foreign.C.Error
newtype Errno
Errno :: CInt -> Errno
instance Eq Errno
eOK :: Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno
isValidErrno :: Errno -> Bool
getErrno :: IO Errno
resetErrno :: IO ()
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError
throwErrno :: String -> IO a
throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a
throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
throwErrnoIfMinus1RetryMayBlock :: Num a => String -> IO a -> IO b -> IO a
throwErrnoIfMinus1RetryMayBlock_ :: Num a => String -> IO a -> IO b -> IO ()
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)
throwErrnoPath :: String -> FilePath -> IO a
throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
throwErrnoPathIf_ :: (a -> Bool) -> String -> FilePath -> IO a -> IO ()
throwErrnoPathIfNull :: String -> FilePath -> IO (Ptr a) -> IO (Ptr a)
throwErrnoPathIfMinus1 :: Num a => String -> FilePath -> IO a -> IO a
throwErrnoPathIfMinus1_ :: Num a => String -> FilePath -> IO a -> IO ()

module Foreign.C

module Foreign.Marshal.Pool
data Pool
newPool :: IO Pool
freePool :: Pool -> IO ()
withPool :: (Pool -> IO b) -> IO b
pooledMalloc :: Storable a => Pool -> IO (Ptr a)
pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)
pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)
pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)
pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledNew :: Storable a => Pool -> a -> IO (Ptr a)
pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)
pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)

module Foreign.Marshal

module Foreign
unsafePerformIO :: IO a -> a

module System.Posix.Types
newtype Fd
Fd :: CInt -> Fd
instance Bits Fd
instance Bounded Fd
instance Enum Fd
instance Eq Fd
instance Integral Fd
instance Num Fd
instance Ord Fd
instance Read Fd
instance Real Fd
instance Show Fd
instance Storable Fd
instance Typeable Fd
type ByteCount = CSize
type ClockTick = CClock
type EpochTime = CTime
type FileOffset = COff
type ProcessID = CPid
type ProcessGroupID = CPid
type DeviceID = CDev
type FileID = CIno
type FileMode = CMode
type Limit = CLong

module GHC.Conc
data ThreadId
ThreadId :: ThreadId# -> ThreadId
instance Data ThreadId
instance Eq ThreadId
instance Ord ThreadId
instance Show ThreadId
instance Typeable ThreadId
forkIO :: IO () -> IO ThreadId
forkOnIO :: Int -> IO () -> IO ThreadId
numCapabilities :: Int
childHandler :: Exception -> IO ()
myThreadId :: IO ThreadId
killThread :: ThreadId -> IO ()
throwTo :: ThreadId -> Exception -> IO ()
par :: a -> b -> b
pseq :: a -> b -> b
yield :: IO ()
labelThread :: ThreadId -> String -> IO ()
threadDelay :: Int -> IO ()
registerDelay :: Int -> IO (TVar Bool)
threadWaitRead :: Fd -> IO ()
threadWaitWrite :: Fd -> IO ()
data MVar a
instance Typeable1 MVar
instance Typeable a => Data (MVar a)
instance Eq (MVar a)
newMVar :: a -> IO (MVar a)
newEmptyMVar :: IO (MVar a)
takeMVar :: MVar a -> IO a
putMVar :: MVar a -> a -> IO ()
tryTakeMVar :: MVar a -> IO (Maybe a)
tryPutMVar :: MVar a -> a -> IO Bool
isEmptyMVar :: MVar a -> IO Bool
addMVarFinalizer :: MVar a -> IO () -> IO ()
data STM a
instance Functor STM
instance Monad STM
instance Typeable1 STM
instance Typeable a => Data (STM a)
atomically :: STM a -> IO a
retry :: STM a
orElse :: STM a -> STM a -> STM a
catchSTM :: STM a -> (Exception -> STM a) -> STM a
alwaysSucceeds :: STM a -> STM ()
always :: STM Bool -> STM ()
data TVar a
instance Typeable1 TVar
instance Typeable a => Data (TVar a)
instance Eq (TVar a)
newTVar :: a -> STM (TVar a)
newTVarIO :: a -> IO (TVar a)
readTVar :: TVar a -> STM a
writeTVar :: TVar a -> a -> STM ()
unsafeIOToSTM :: IO a -> STM a
asyncRead :: Int -> Int -> Int -> Ptr a -> IO (Int, Int)
asyncWrite :: Int -> Int -> Int -> Ptr a -> IO (Int, Int)
asyncDoProc :: FunPtr (Ptr a -> IO Int) -> Ptr a -> IO Int
asyncReadBA :: Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)
asyncWriteBA :: Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)
ensureIOManagerIsRunning :: IO ()
data ConsoleEvent
ControlC :: ConsoleEvent
Break :: ConsoleEvent
Close :: ConsoleEvent
Logoff :: ConsoleEvent
Shutdown :: ConsoleEvent
instance Enum ConsoleEvent
instance Eq ConsoleEvent
instance Ord ConsoleEvent
instance Read ConsoleEvent
instance Show ConsoleEvent
instance Typeable ConsoleEvent
win32ConsoleHandler :: MVar (ConsoleEvent -> IO ())

module System.IO
data IO a
instance Applicative IO
instance Functor IO
instance Monad IO
instance MonadFix IO
instance Typeable1 IO
instance Typeable a => Data (IO a)
instance HPrintfType (IO a)
instance PrintfType (IO a)
fixIO :: (a -> IO a) -> IO a
type FilePath = String
data Handle
instance Data Handle
instance Eq Handle
instance Show Handle
instance Typeable Handle
stdin :: Handle
stdout :: Handle
stderr :: Handle
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
openFile :: FilePath -> IOMode -> IO Handle
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
instance Enum IOMode
instance Eq IOMode
instance Ix IOMode
instance Ord IOMode
instance Read IOMode
instance Show IOMode
hClose :: Handle -> IO ()
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
appendFile :: FilePath -> String -> IO ()
hFileSize :: Handle -> IO Integer
hSetFileSize :: Handle -> Integer -> IO ()
hIsEOF :: Handle -> IO Bool
isEOF :: IO Bool
data BufferMode
NoBuffering :: BufferMode
LineBuffering :: BufferMode
BlockBuffering :: Maybe Int -> BufferMode
instance Eq BufferMode
instance Ord BufferMode
instance Read BufferMode
instance Show BufferMode
hSetBuffering :: Handle -> BufferMode -> IO ()
hGetBuffering :: Handle -> IO BufferMode
hFlush :: Handle -> IO ()
hGetPosn :: Handle -> IO HandlePosn
hSetPosn :: HandlePosn -> IO ()
data HandlePosn
instance Eq HandlePosn
instance Show HandlePosn
hSeek :: Handle -> SeekMode -> Integer -> IO ()
data SeekMode
AbsoluteSeek :: SeekMode
RelativeSeek :: SeekMode
SeekFromEnd :: SeekMode
instance Enum SeekMode
instance Eq SeekMode
instance Ix SeekMode
instance Ord SeekMode
instance Read SeekMode
instance Show SeekMode
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool
hIsTerminalDevice :: Handle -> IO Bool
hSetEcho :: Handle -> Bool -> IO ()
hGetEcho :: Handle -> IO Bool
hShow :: Handle -> IO String
hWaitForInput :: Handle -> Int -> IO Bool
hReady :: Handle -> IO Bool
hGetChar :: Handle -> IO Char
hGetLine :: Handle -> IO String
hLookAhead :: Handle -> IO Char
hGetContents :: Handle -> IO String
hPutChar :: Handle -> Char -> IO ()
hPutStr :: Handle -> String -> IO ()
hPutStrLn :: Handle -> String -> IO ()
hPrint :: Show a => Handle -> a -> IO ()
interact :: (String -> String) -> IO ()
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
print :: Show a => a -> IO ()
getChar :: IO Char
getLine :: IO String
getContents :: IO String
readIO :: Read a => String -> IO a
readLn :: Read a => IO a
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
openBinaryFile :: FilePath -> IOMode -> IO Handle
hSetBinaryMode :: Handle -> Bool -> IO ()
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hGetBuf :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
openTempFile :: FilePath -> String -> IO (FilePath, Handle)
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)

module GHC.Dotnet
data Object a
unmarshalObject :: Addr# -> Object a
marshalObject :: Object a -> (Addr# -> IO b) -> IO b
unmarshalString :: Addr# -> String
marshalString :: String -> (Addr# -> IO a) -> IO a
checkResult :: (State# RealWorld -> (State# RealWorld, a, Addr#)) -> IO a

module Text.Read
class Read a
readsPrec :: Read a => Int -> ReadS a
readList :: Read a => ReadS [a]
readPrec :: Read a => ReadPrec a
readListPrec :: Read a => ReadPrec [a]
instance Read All
instance Read Any
instance Read Bool
instance Read BufferMode
instance Read CChar
instance Read CClock
instance Read CDouble
instance Read CFloat
instance Read CInt
instance Read CIntMax
instance Read CIntPtr
instance Read CLDouble
instance Read CLLong
instance Read CLong
instance Read CPtrdiff
instance Read CSChar
instance Read CShort
instance Read CSigAtomic
instance Read CSize
instance Read CTime
instance Read CUChar
instance Read CUInt
instance Read CUIntMax
instance Read CUIntPtr
instance Read CULLong
instance Read CULong
instance Read CUShort
instance Read CWchar
instance Read Char
instance Read ConsoleEvent
instance Read Double
instance Read ExitCode
instance Read Fd
instance Read Float
instance Read GeneralCategory
instance Read IOMode
instance Read Int
instance Read Int16
instance Read Int32
instance Read Int64
instance Read Int8
instance Read IntPtr
instance Read Integer
instance Read Lexeme
instance Read Ordering
instance Read SeekMode
instance Read Version
instance Read Word
instance Read Word16
instance Read Word32
instance Read Word64
instance Read Word8
instance Read WordPtr
instance Read ()
instance (Read a, Read b) => Read (a, b)
instance (Read a, Read b, Read c) => Read (a, b, c)
instance (Read a, Read b, Read c, Read d) => Read (a, b, c, d)
instance (Read a, Read b, Read c, Read d, Read e) => Read (a, b, c, d, e)
instance (Read a, Read b, Read c, Read d, Read e, Read f) => Read (a, b, c, d, e, f)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g) => Read (a, b, c, d, e, f, g)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h) => Read (a, b, c, d, e, f, g, h)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i) => Read (a, b, c, d, e, f, g, h, i)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j) => Read (a, b, c, d, e, f, g, h, i, j)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k) => Read (a, b, c, d, e, f, g, h, i, j, k)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l) => Read (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m) => Read (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m, Read n) => Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m, Read n, Read o) => Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (RealFloat a, Read a) => Read (Complex a)
instance Read a => Read (Dual a)
instance Read a => Read (First a)
instance Read a => Read (Last a)
instance Read a => Read (Maybe a)
instance Read a => Read (Product a)
instance (Integral a, Read a) => Read (Ratio a)
instance Read a => Read (Sum a)
instance Read a => Read [a]
instance (Ix a, Read a, Read b) => Read (Array a b)
instance (Read a, Read b) => Read (Either a b)
type ReadS a = String -> [(a, String)]
reads :: Read a => ReadS a
read :: Read a => String -> a
readParen :: Bool -> ReadS a -> ReadS a
lex :: ReadS String
data Lexeme
Char :: Char -> Lexeme
String :: String -> Lexeme
Punc :: String -> Lexeme
Ident :: String -> Lexeme
Symbol :: String -> Lexeme
Int :: Integer -> Lexeme
Rat :: Rational -> Lexeme
EOF :: Lexeme
instance Eq Lexeme
instance Read Lexeme
instance Show Lexeme
lexP :: ReadPrec Lexeme
parens :: ReadPrec a -> ReadPrec a
readListDefault :: Read a => ReadS [a]
readListPrecDefault :: Read a => ReadPrec [a]

module Prelude
keyword |
keyword ->
keyword <-
keyword @
keyword !
keyword ::
keyword ~
keyword _
keyword as
keyword case
keyword class
keyword data
keyword default
keyword deriving
keyword do
keyword else
keyword forall
keyword hiding
keyword if
keyword import
keyword in
keyword infix
keyword infixl
keyword infixr
keyword instance
keyword let
keyword module
keyword newtype
keyword of
keyword qualified
keyword then
keyword type
keyword where
data Bool
False :: Bool
True :: Bool
instance Bounded Bool
instance Data Bool
instance Enum Bool
instance Eq Bool
instance Ix Bool
instance Ord Bool
instance Read Bool
instance Show Bool
instance Storable Bool
instance Typeable Bool
(&&) :: Bool -> Bool -> Bool
(||) :: Bool -> Bool -> Bool
not :: Bool -> Bool
otherwise :: Bool
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
instance Alternative Maybe
instance Applicative Maybe
instance Foldable Maybe
instance Functor Maybe
instance Monad Maybe
instance MonadFix Maybe
instance MonadPlus Maybe
instance Traversable Maybe
instance Typeable1 Maybe
instance Data a => Data (Maybe a)
instance Eq a => Eq (Maybe a)
instance Monoid a => Monoid (Maybe a)
instance Ord a => Ord (Maybe a)
instance Read a => Read (Maybe a)
instance Show a => Show (Maybe a)
maybe :: b -> (a -> b) -> Maybe a -> b
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b
instance Typeable2 Either
instance Functor (Either a)
instance (Data a, Data b) => Data (Either a b)
instance (Eq a, Eq b) => Eq (Either a b)
instance (Ord a, Ord b) => Ord (Either a b)
instance (Read a, Read b) => Read (Either a b)
instance (Show a, Show b) => Show (Either a b)
either :: (a -> c) -> (b -> c) -> Either a b -> c
data Ordering
LT :: Ordering
EQ :: Ordering
instance Bounded Ordering
instance Data Ordering
instance Enum Ordering
instance Eq Ordering
instance Ix Ordering
instance Monoid Ordering
instance Ord Ordering
instance Read Ordering
instance Show Ordering
instance Typeable Ordering
data Char
instance Bounded Char
instance Data Char
instance Enum Char
instance Eq Char
instance IsChar Char
instance Ix Char
instance Ord Char
instance PrintfArg Char
instance Read Char
instance Show Char
instance Storable Char
instance Typeable Char
instance IsString [Char]
type String = [Char]
fst :: (a, b) -> a
snd :: (a, b) -> b
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
instance Eq All
instance Eq Any
instance Eq ArithException
instance Eq ArrayException
instance Eq AsyncException
instance Eq Bool
instance Eq BufferMode
instance Eq BufferState
instance Eq CChar
instance Eq CClock
instance Eq CDouble
instance Eq CFloat
instance Eq CInt
instance Eq CIntMax
instance Eq CIntPtr
instance Eq CLDouble
instance Eq CLLong
instance Eq CLong
instance Eq CPtrdiff
instance Eq CSChar
instance Eq CShort
instance Eq CSigAtomic
instance Eq CSize
instance Eq CTime
instance Eq CUChar
instance Eq CUInt
instance Eq CUIntMax
instance Eq CUIntPtr
instance Eq CULLong
instance Eq CULong
instance Eq CUShort
instance Eq CWchar
instance Eq Char
instance Eq ConsoleEvent
instance Eq Constr
instance Eq ConstrRep
instance Eq DataRep
instance Eq Double
instance Eq Errno
instance Eq Exception
instance Eq ExitCode
instance Eq FDType
instance Eq Fd
instance Eq Fixity
instance Eq Float
instance Eq GeneralCategory
instance Eq Handle
instance Eq HandlePosn
instance Eq HashData
instance Eq IOErrorType
instance Eq IOException
instance Eq IOMode
instance Eq Inserts
instance Eq Int
instance Eq Int16
instance Eq Int32
instance Eq Int64
instance Eq Int8
instance Eq IntPtr
instance Eq Integer
instance Eq Key
instance Eq KeyPr
instance Eq Lexeme
instance Eq Ordering
instance Eq SeekMode
instance Eq ThreadId
instance Eq Timeout
instance Eq TyCon
instance Eq TypeRep
instance Eq Unique
instance Eq Version
instance Eq Word
instance Eq Word16
instance Eq Word32
instance Eq Word64
instance Eq Word8
instance Eq WordPtr
instance Eq ()
instance (Eq a, Eq b) => Eq (a, b)
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq (a, b, c, d, e, f)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq (a, b, c, d, e, f, g)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) => Eq (a, b, c, d, e, f, g, h)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) => Eq (a, b, c, d, e, f, g, h, i)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j) => Eq (a, b, c, d, e, f, g, h, i, j)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k) => Eq (a, b, c, d, e, f, g, h, i, j, k)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l) => Eq (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m) => Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n) => Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) => Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (RealFloat a, Eq a) => Eq (Complex a)
instance Eq a => Eq (Dual a)
instance Eq a => Eq (First a)
instance Eq (Fixed a)
instance Eq (ForeignPtr a)
instance Eq (FunPtr a)
instance Eq (IORef a)
instance Eq a => Eq (Last a)
instance Eq (MVar a)
instance Eq a => Eq (Maybe a)
instance Eq a => Eq (Product a)
instance Eq (Ptr a)
instance (Integral a, Eq a) => Eq (Ratio a)
instance Eq (StableName a)
instance Eq (StablePtr a)
instance Eq a => Eq (Sum a)
instance Eq (TVar a)
instance Eq a => Eq [a]
instance (Ix i, Eq e) => Eq (Array i e)
instance (Eq a, Eq b) => Eq (Either a b)
instance Eq (IOArray i e)
instance Eq (STRef s a)
instance Eq (STArray s i e)
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
instance Ord All
instance Ord Any
instance Ord ArithException
instance Ord ArrayException
instance Ord AsyncException
instance Ord Bool
instance Ord BufferMode
instance Ord CChar
instance Ord CClock
instance Ord CDouble
instance Ord CFloat
instance Ord CInt
instance Ord CIntMax
instance Ord CIntPtr
instance Ord CLDouble
instance Ord CLLong
instance Ord CLong
instance Ord CPtrdiff
instance Ord CSChar
instance Ord CShort
instance Ord CSigAtomic
instance Ord CSize
instance Ord CTime
instance Ord CUChar
instance Ord CUInt
instance Ord CUIntMax
instance Ord CUIntPtr
instance Ord CULLong
instance Ord CULong
instance Ord CUShort
instance Ord CWchar
instance Ord Char
instance Ord ConsoleEvent
instance Ord Double
instance Ord ExitCode
instance Ord Fd
instance Ord Float
instance Ord GeneralCategory
instance Ord IOMode
instance Ord Int
instance Ord Int16
instance Ord Int32
instance Ord Int64
instance Ord Int8
instance Ord IntPtr
instance Ord Integer
instance Ord Ordering
instance Ord SeekMode
instance Ord ThreadId
instance Ord Unique
instance Ord Version
instance Ord Word
instance Ord Word16
instance Ord Word32
instance Ord Word64
instance Ord Word8
instance Ord WordPtr
instance Ord ()
instance (Ord a, Ord b) => Ord (a, b)
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) => Ord (a, b, c, d, e, f)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) => Ord (a, b, c, d, e, f, g)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h) => Ord (a, b, c, d, e, f, g, h)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i) => Ord (a, b, c, d, e, f, g, h, i)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j) => Ord (a, b, c, d, e, f, g, h, i, j)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k) => Ord (a, b, c, d, e, f, g, h, i, j, k)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l) => Ord (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m) => Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) => Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) => Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Ord a => Ord (Dual a)
instance Ord a => Ord (First a)
instance Ord (Fixed a)
instance Ord (ForeignPtr a)
instance Ord (FunPtr a)
instance Ord a => Ord (Last a)
instance Ord a => Ord (Maybe a)
instance Ord a => Ord (Product a)
instance Ord (Ptr a)
instance Integral a => Ord (Ratio a)
instance Ord a => Ord (Sum a)
instance Ord a => Ord [a]
instance (Ix i, Ord e) => Ord (Array i e)
instance (Ord a, Ord b) => Ord (Either a b)
class Enum a
succ :: Enum a => a -> a
pred :: Enum a => a -> a
toEnum :: Enum a => Int -> a
fromEnum :: Enum a => a -> Int
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
instance Enum Bool
instance Enum CChar
instance Enum CClock
instance Enum CDouble
instance Enum CFloat
instance Enum CInt
instance Enum CIntMax
instance Enum CIntPtr
instance Enum CLDouble
instance Enum CLLong
instance Enum CLong
instance Enum CPtrdiff
instance Enum CSChar
instance Enum CShort
instance Enum CSigAtomic
instance Enum CSize
instance Enum CTime
instance Enum CUChar
instance Enum CUInt
instance Enum CUIntMax
instance Enum CUIntPtr
instance Enum CULLong
instance Enum CULong
instance Enum CUShort
instance Enum CWchar
instance Enum Char
instance Enum ConsoleEvent
instance Enum Double
instance Enum Fd
instance Enum Float
instance Enum GeneralCategory
instance Enum IOMode
instance Enum Int
instance Enum Int16
instance Enum Int32
instance Enum Int64
instance Enum Int8
instance Enum IntPtr
instance Enum Integer
instance Enum Ordering
instance Enum SeekMode
instance Enum Word
instance Enum Word16
instance Enum Word32
instance Enum Word64
instance Enum Word8
instance Enum WordPtr
instance Enum ()
instance Enum (Fixed a)
instance Integral a => Enum (Ratio a)
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a
instance Bounded All
instance Bounded Any
instance Bounded Bool
instance Bounded CChar
instance Bounded CInt
instance Bounded CIntMax
instance Bounded CIntPtr
instance Bounded CLLong
instance Bounded CLong
instance Bounded CPtrdiff
instance Bounded CSChar
instance Bounded CShort
instance Bounded CSigAtomic
instance Bounded CSize
instance Bounded CUChar
instance Bounded CUInt
instance Bounded CUIntMax
instance Bounded CUIntPtr
instance Bounded CULLong
instance Bounded CULong
instance Bounded CUShort
instance Bounded CWchar
instance Bounded Char
instance Bounded Fd
instance Bounded GeneralCategory
instance Bounded Int
instance Bounded Int16
instance Bounded Int32
instance Bounded Int64
instance Bounded Int8
instance Bounded IntPtr
instance Bounded Ordering
instance Bounded Word
instance Bounded Word16
instance Bounded Word32
instance Bounded Word64
instance Bounded Word8
instance Bounded WordPtr
instance Bounded ()
instance (Bounded a, Bounded b) => Bounded (a, b)
instance (Bounded a, Bounded b, Bounded c) => Bounded (a, b, c)
instance (Bounded a, Bounded b, Bounded c, Bounded d) => Bounded (a, b, c, d)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) => Bounded (a, b, c, d, e)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f) => Bounded (a, b, c, d, e, f)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g) => Bounded (a, b, c, d, e, f, g)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h) => Bounded (a, b, c, d, e, f, g, h)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i) => Bounded (a, b, c, d, e, f, g, h, i)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j) => Bounded (a, b, c, d, e, f, g, h, i, j)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k) => Bounded (a, b, c, d, e, f, g, h, i, j, k)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l) => Bounded (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m) => Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n) => Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n, Bounded o) => Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Bounded a => Bounded (Dual a)
instance Bounded a => Bounded (Product a)
instance Bounded a => Bounded (Sum a)
data Int
instance Bits Int
instance Bounded Int
instance Data Int
instance Enum Int
instance Eq Int
instance Integral Int
instance Ix Int
instance Num Int
instance Ord Int
instance PrintfArg Int
instance Read Int
instance Real Int
instance Show Int
instance Storable Int
instance Typeable Int
data Integer
instance Bits Integer
instance Data Integer
instance Enum Integer
instance Eq Integer
instance Integral Integer
instance Ix Integer
instance Num Integer
instance Ord Integer
instance PrintfArg Integer
instance Read Integer
instance Real Integer
instance Show Integer
instance Typeable Integer
data Float
instance Data Float
instance Enum Float
instance Eq Float
instance Floating Float
instance Fractional Float
instance Num Float
instance Ord Float
instance PrintfArg Float
instance Read Float
instance Real Float
instance RealFloat Float
instance RealFrac Float
instance Show Float
instance Storable Float
instance Typeable Float
data Double
instance Data Double
instance Enum Double
instance Eq Double
instance Floating Double
instance Fractional Double
instance Num Double
instance Ord Double
instance PrintfArg Double
instance Read Double
instance Real Double
instance RealFloat Double
instance RealFrac Double
instance Show Double
instance Storable Double
instance Typeable Double
type Rational = Ratio Integer
class (Eq a, Show a) => Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a
negate :: Num a => a -> a
abs :: Num a => a -> a
signum :: Num a => a -> a
fromInteger :: Num a => Integer -> a
instance Num CChar
instance Num CClock
instance Num CDouble
instance Num CFloat
instance Num CInt
instance Num CIntMax
instance Num CIntPtr
instance Num CLDouble
instance Num CLLong
instance Num CLong
instance Num CPtrdiff
instance Num CSChar
instance Num CShort
instance Num CSigAtomic
instance Num CSize
instance Num CTime
instance Num CUChar
instance Num CUInt
instance Num CUIntMax
instance Num CUIntPtr
instance Num CULLong
instance Num CULong
instance Num CUShort
instance Num CWchar
instance Num Double
instance Num Fd
instance Num Float
instance Num Int
instance Num Int16
instance Num Int32
instance Num Int64
instance Num Int8
instance Num IntPtr
instance Num Integer
instance Num Word
instance Num Word16
instance Num Word32
instance Num Word64
instance Num Word8
instance Num WordPtr
instance RealFloat a => Num (Complex a)
instance HasResolution a => Num (Fixed a)
instance Integral a => Num (Ratio a)
class (Num a, Ord a) => Real a
toRational :: Real a => a -> Rational
instance Real CChar
instance Real CClock
instance Real CDouble
instance Real CFloat
instance Real CInt
instance Real CIntMax
instance Real CIntPtr
instance Real CLDouble
instance Real CLLong
instance Real CLong
instance Real CPtrdiff
instance Real CSChar
instance Real CShort
instance Real CSigAtomic
instance Real CSize
instance Real CTime
instance Real CUChar
instance Real CUInt
instance Real CUIntMax
instance Real CUIntPtr
instance Real CULLong
instance Real CULong
instance Real CUShort
instance Real CWchar
instance Real Double
instance Real Fd
instance Real Float
instance Real Int
instance Real Int16
instance Real Int32
instance Real Int64
instance Real Int8
instance Real IntPtr
instance Real Integer
instance Real Word
instance Real Word16
instance Real Word32
instance Real Word64
instance Real Word8
instance Real WordPtr
instance HasResolution a => Real (Fixed a)
instance Integral a => Real (Ratio a)
class (Real a, Enum a) => Integral a
quot :: Integral a => a -> a -> a
rem :: Integral a => a -> a -> a
div :: Integral a => a -> a -> a
mod :: Integral a => a -> a -> a
quotRem :: Integral a => a -> a -> (a, a)
divMod :: Integral a => a -> a -> (a, a)
toInteger :: Integral a => a -> Integer
instance Integral CChar
instance Integral CInt
instance Integral CIntMax
instance Integral CIntPtr
instance Integral CLLong
instance Integral CLong
instance Integral CPtrdiff
instance Integral CSChar
instance Integral CShort
instance Integral CSigAtomic
instance Integral CSize
instance Integral CUChar
instance Integral CUInt
instance Integral CUIntMax
instance Integral CUIntPtr
instance Integral CULLong
instance Integral CULong
instance Integral CUShort
instance Integral CWchar
instance Integral Fd
instance Integral Int
instance Integral Int16
instance Integral Int32
instance Integral Int64
instance Integral Int8
instance Integral IntPtr
instance Integral Integer
instance Integral Word
instance Integral Word16
instance Integral Word32
instance Integral Word64
instance Integral Word8
instance Integral WordPtr
class Num a => Fractional a
(/) :: Fractional a => a -> a -> a
recip :: Fractional a => a -> a
fromRational :: Fractional a => Rational -> a
instance Fractional CDouble
instance Fractional CFloat
instance Fractional CLDouble
instance Fractional Double
instance Fractional Float
instance RealFloat a => Fractional (Complex a)
instance HasResolution a => Fractional (Fixed a)
instance Integral a => Fractional (Ratio a)
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
instance Floating CDouble
instance Floating CFloat
instance Floating CLDouble
instance Floating Double
instance Floating Float
instance RealFloat a => Floating (Complex a)
class (Real a, Fractional a) => RealFrac a
properFraction :: (RealFrac a, Integral b) => a -> (b, a)
truncate :: (RealFrac a, Integral b) => a -> b
round :: (RealFrac a, Integral b) => a -> b
ceiling :: (RealFrac a, Integral b) => a -> b
floor :: (RealFrac a, Integral b) => a -> b
instance RealFrac CDouble
instance RealFrac CFloat
instance RealFrac CLDouble
instance RealFrac Double
instance RealFrac Float
instance HasResolution a => RealFrac (Fixed a)
instance Integral a => RealFrac (Ratio a)
class (RealFrac a, Floating a) => RealFloat a
floatRadix :: RealFloat a => a -> Integer
floatDigits :: RealFloat a => a -> Int
floatRange :: RealFloat a => a -> (Int, Int)
decodeFloat :: RealFloat a => a -> (Integer, Int)
encodeFloat :: RealFloat a => Integer -> Int -> a
exponent :: RealFloat a => a -> Int
significand :: RealFloat a => a -> a
scaleFloat :: RealFloat a => Int -> a -> a
isNaN :: RealFloat a => a -> Bool
isInfinite :: RealFloat a => a -> Bool
isDenormalized :: RealFloat a => a -> Bool
isNegativeZero :: RealFloat a => a -> Bool
isIEEE :: RealFloat a => a -> Bool
atan2 :: RealFloat a => a -> a -> a
instance RealFloat CDouble
instance RealFloat CFloat
instance RealFloat CLDouble
instance RealFloat Double
instance RealFloat Float
subtract :: Num a => a -> a -> a
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool
gcd :: Integral a => a -> a -> a
lcm :: Integral a => a -> a -> a
(^) :: (Num a, Integral b) => a -> b -> a
(^^) :: (Fractional a, Integral b) => a -> b -> a
fromIntegral :: (Integral a, Num b) => a -> b
realToFrac :: (Real a, Fractional b) => a -> b
class Monad m
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a
instance Monad IO
instance Monad Maybe
instance Monad P
instance Monad ReadP
instance Monad ReadPrec
instance Monad STM
instance Monad []
instance ArrowApply a => Monad (ArrowMonad a)
instance Monad (ST s)
instance Monad (ST s)
instance Monad ((->) r)
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
instance Functor IO
instance Functor Id
instance Functor Maybe
instance Functor ReadP
instance Functor ReadPrec
instance Functor STM
instance Functor ZipList
instance Functor []
instance Ix i => Functor (Array i)
instance Functor (Const m)
instance Functor (Either a)
instance Functor (ST s)
instance Functor (ST s)
instance Monad m => Functor (WrappedMonad m)
instance Functor ((,) a)
instance Functor ((->) r)
instance Arrow a => Functor (WrappedArrow a b)
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
sequence :: Monad m => [m a] -> m [a]
sequence_ :: Monad m => [m a] -> m ()
(=<<) :: Monad m => (a -> m b) -> m a -> m b
id :: a -> a
const :: a -> b -> a
(.) :: (b -> c) -> (a -> b) -> a -> c
flip :: (a -> b -> c) -> b -> a -> c
($) :: (a -> b) -> a -> b
until :: (a -> Bool) -> (a -> a) -> a -> a
asTypeOf :: a -> a -> a
error :: String -> a
undefined :: a
seq :: a -> b -> b
($!) :: (a -> b) -> a -> b
map :: (a -> b) -> [a] -> [b]
(++) :: [a] -> [a] -> [a]
filter :: (a -> Bool) -> [a] -> [a]
head :: [a] -> a
last :: [a] -> a
tail :: [a] -> [a]
init :: [a] -> [a]
null :: [a] -> Bool
length :: [a] -> Int
(!!) :: [a] -> Int -> a
reverse :: [a] -> [a]
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl1 :: (a -> a -> a) -> [a] -> a
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr1 :: (a -> a -> a) -> [a] -> a
and :: [Bool] -> Bool
or :: [Bool] -> Bool
any :: (a -> Bool) -> [a] -> Bool
all :: (a -> Bool) -> [a] -> Bool
sum :: Num a => [a] -> a
product :: Num a => [a] -> a
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]
maximum :: Ord a => [a] -> a
minimum :: Ord a => [a] -> a
scanl :: (a -> b -> a) -> a -> [b] -> [a]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
iterate :: (a -> a) -> a -> [a]
repeat :: a -> [a]
replicate :: Int -> a -> [a]
cycle :: [a] -> [a]
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])
elem :: Eq a => a -> [a] -> Bool
notElem :: Eq a => a -> [a] -> Bool
lookup :: Eq a => a -> [(a, b)] -> Maybe b
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
type ShowS = String -> String
class Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS
instance Show All
instance Show Any
instance Show ArithException
instance Show ArrayException
instance Show AsyncException
instance Show Bool
instance Show BufferMode
instance Show CChar
instance Show CClock
instance Show CDouble
instance Show CFloat
instance Show CInt
instance Show CIntMax
instance Show CIntPtr
instance Show CLDouble
instance Show CLLong
instance Show CLong
instance Show CPtrdiff
instance Show CSChar
instance Show CShort
instance Show CSigAtomic
instance Show CSize
instance Show CTime
instance Show CUChar
instance Show CUInt
instance Show CUIntMax
instance Show CUIntPtr
instance Show CULLong
instance Show CULong
instance Show CUShort
instance Show CWchar
instance Show Char
instance Show ConsoleEvent
instance Show Constr
instance Show ConstrRep
instance Show DataRep
instance Show DataType
instance Show Double
instance Show Dynamic
instance Show Exception
instance Show ExitCode
instance Show Fd
instance Show Fixity
instance Show Float
instance Show GeneralCategory
instance Show Handle
instance Show HandlePosn
instance Show HandleType
instance Show HashData
instance Show IOErrorType
instance Show IOException
instance Show IOMode
instance Show Int
instance Show Int16
instance Show Int32
instance Show Int64
instance Show Int8
instance Show IntPtr
instance Show Integer
instance Show Lexeme
instance Show Ordering
instance Show SeekMode
instance Show ThreadId
instance Show TyCon
instance Show TypeRep
instance Show Version
instance Show Word
instance Show Word16
instance Show Word32
instance Show Word64
instance Show Word8
instance Show WordPtr
instance Show ()
instance (Show a, Show b) => Show (a, b)
instance (Show a, Show b, Show c) => Show (a, b, c)
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d)
instance (Show a, Show b, Show c, Show d, Show e) => Show (a, b, c, d, e)
instance (Show a, Show b, Show c, Show d, Show e, Show f) => Show (a, b, c, d, e, f)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g) => Show (a, b, c, d, e, f, g)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h) => Show (a, b, c, d, e, f, g, h)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i) => Show (a, b, c, d, e, f, g, h, i)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j) => Show (a, b, c, d, e, f, g, h, i, j)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k) => Show (a, b, c, d, e, f, g, h, i, j, k)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l) => Show (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Show (a -> b)
instance (RealFloat a, Show a) => Show (Complex a)
instance Show a => Show (Dual a)
instance Show a => Show (First a)
instance HasResolution a => Show (Fixed a)
instance Show (ForeignPtr a)
instance Show (FunPtr a)
instance Show a => Show (Last a)
instance Show a => Show (Maybe a)
instance Show a => Show (Product a)
instance Show (Ptr a)
instance Integral a => Show (Ratio a)
instance Show a => Show (Sum a)
instance Show a => Show [a]
instance (Ix a, Show a, Show b) => Show (Array a b)
instance (Show a, Show b) => Show (Either a b)
instance Show (ST s a)
shows :: Show a => a -> ShowS
showChar :: Char -> ShowS
showString :: String -> ShowS
showParen :: Bool -> ShowS -> ShowS
type ReadS a = String -> [(a, String)]
class Read a
readsPrec :: Read a => Int -> ReadS a
readList :: Read a => ReadS [a]
instance Read All
instance Read Any
instance Read Bool
instance Read BufferMode
instance Read CChar
instance Read CClock
instance Read CDouble
instance Read CFloat
instance Read CInt
instance Read CIntMax
instance Read CIntPtr
instance Read CLDouble
instance Read CLLong
instance Read CLong
instance Read CPtrdiff
instance Read CSChar
instance Read CShort
instance Read CSigAtomic
instance Read CSize
instance Read CTime
instance Read CUChar
instance Read CUInt
instance Read CUIntMax
instance Read CUIntPtr
instance Read CULLong
instance Read CULong
instance Read CUShort
instance Read CWchar
instance Read Char
instance Read ConsoleEvent
instance Read Double
instance Read ExitCode
instance Read Fd
instance Read Float
instance Read GeneralCategory
instance Read IOMode
instance Read Int
instance Read Int16
instance Read Int32
instance Read Int64
instance Read Int8
instance Read IntPtr
instance Read Integer
instance Read Lexeme
instance Read Ordering
instance Read SeekMode
instance Read Version
instance Read Word
instance Read Word16
instance Read Word32
instance Read Word64
instance Read Word8
instance Read WordPtr
instance Read ()
instance (Read a, Read b) => Read (a, b)
instance (Read a, Read b, Read c) => Read (a, b, c)
instance (Read a, Read b, Read c, Read d) => Read (a, b, c, d)
instance (Read a, Read b, Read c, Read d, Read e) => Read (a, b, c, d, e)
instance (Read a, Read b, Read c, Read d, Read e, Read f) => Read (a, b, c, d, e, f)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g) => Read (a, b, c, d, e, f, g)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h) => Read (a, b, c, d, e, f, g, h)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i) => Read (a, b, c, d, e, f, g, h, i)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j) => Read (a, b, c, d, e, f, g, h, i, j)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k) => Read (a, b, c, d, e, f, g, h, i, j, k)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l) => Read (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m) => Read (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m, Read n) => Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m, Read n, Read o) => Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (RealFloat a, Read a) => Read (Complex a)
instance Read a => Read (Dual a)
instance Read a => Read (First a)
instance Read a => Read (Last a)
instance Read a => Read (Maybe a)
instance Read a => Read (Product a)
instance (Integral a, Read a) => Read (Ratio a)
instance Read a => Read (Sum a)
instance Read a => Read [a]
instance (Ix a, Read a, Read b) => Read (Array a b)
instance (Read a, Read b) => Read (Either a b)
reads :: Read a => ReadS a
readParen :: Bool -> ReadS a -> ReadS a
read :: Read a => String -> a
lex :: ReadS String
data IO a
instance Applicative IO
instance Functor IO
instance Monad IO
instance MonadFix IO
instance Typeable1 IO
instance Typeable a => Data (IO a)
instance HPrintfType (IO a)
instance PrintfType (IO a)
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
print :: Show a => a -> IO ()
getChar :: IO Char
getLine :: IO String
getContents :: IO String
interact :: (String -> String) -> IO ()
type FilePath = String
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
appendFile :: FilePath -> String -> IO ()
readIO :: Read a => String -> IO a
readLn :: Read a => IO a
type IOError = IOException
ioError :: IOError -> IO a
userError :: String -> IOError
catch :: IO a -> (IOError -> IO a) -> IO a

module Control.Monad.Instances
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
instance Functor IO
instance Functor Id
instance Functor Maybe
instance Functor ReadP
instance Functor ReadPrec
instance Functor STM
instance Functor ZipList
instance Functor []
instance Ix i => Functor (Array i)
instance Functor (Const m)
instance Functor (Either a)
instance Functor (ST s)
instance Functor (ST s)
instance Monad m => Functor (WrappedMonad m)
instance Functor ((,) a)
instance Functor ((->) r)
instance Arrow a => Functor (WrappedArrow a b)
class Monad m
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a
instance Monad IO
instance Monad Maybe
instance Monad P
instance Monad ReadP
instance Monad ReadPrec
instance Monad STM
instance Monad []
instance ArrowApply a => Monad (ArrowMonad a)
instance Monad (ST s)
instance Monad (ST s)
instance Monad ((->) r)

module Data.Fixed
div' :: (Real a, Integral b) => a -> a -> b
mod' :: Real a => a -> a -> a
divMod' :: (Real a, Integral b) => a -> a -> (b, a)
data Fixed a
instance Enum (Fixed a)
instance Eq (Fixed a)
instance HasResolution a => Fractional (Fixed a)
instance HasResolution a => Num (Fixed a)
instance Ord (Fixed a)
instance HasResolution a => Real (Fixed a)
instance HasResolution a => RealFrac (Fixed a)
instance HasResolution a => Show (Fixed a)
class HasResolution a
resolution :: HasResolution a => a -> Integer
instance HasResolution E12
instance HasResolution E6
showFixed :: HasResolution a => Bool -> Fixed a -> String
data E6
instance HasResolution E6
type Micro = Fixed E6
data E12
instance HasResolution E12
type Pico = Fixed E12

module Data.Function
id :: a -> a
const :: a -> b -> a
(.) :: (b -> c) -> (a -> b) -> a -> c
flip :: (a -> b -> c) -> b -> a -> c
($) :: (a -> b) -> a -> b
fix :: (a -> a) -> a
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c

module Control.Monad.Fix
class Monad m => MonadFix m
mfix :: MonadFix m => (a -> m a) -> m a
instance MonadFix IO
instance MonadFix Maybe
instance MonadFix []
instance MonadFix (ST s)
instance MonadFix (ST s)
instance MonadFix ((->) r)
fix :: (a -> a) -> a

module Control.Monad.ST
data ST s a
instance Typeable2 ST
instance Functor (ST s)
instance Monad (ST s)
instance MonadFix (ST s)
instance (Typeable s, Typeable a) => Data (ST s a)
instance Show (ST s a)
runST :: ST s a -> a
fixST :: (a -> ST s a) -> ST s a
data RealWorld
instance Typeable RealWorld
stToIO :: ST RealWorld a -> IO a
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a
unsafeSTToIO :: ST s a -> IO a

module Control.Monad.ST.Strict

module Control.Monad.ST.Lazy
data ST s a
instance Functor (ST s)
instance Monad (ST s)
instance MonadFix (ST s)
runST :: ST s a -> a
fixST :: (a -> ST s a) -> ST s a
strictToLazyST :: ST s a -> ST s a
lazyToStrictST :: ST s a -> ST s a
data RealWorld
instance Typeable RealWorld
stToIO :: ST RealWorld a -> IO a
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a

module Data.Generics.Basics
class Typeable a => Data a
gfoldl :: Data a => (c (a -> b) -> a -> c b) -> (g -> c g) -> a -> c a
gunfold :: Data a => (c (b -> r) -> c r) -> (r -> c r) -> Constr -> c a
toConstr :: Data a => a -> Constr
dataTypeOf :: Data a => a -> DataType
dataCast1 :: (Data a, Typeable1 t) => c (t a) -> Maybe (c a)
dataCast2 :: (Data a, Typeable2 t) => c (t a b) -> Maybe (c a)
gmapT :: Data a => (b -> b) -> a -> a
gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
gmapQ :: Data a => (a -> u) -> a -> [u]
gmapQi :: Data a => Int -> (a -> u) -> a -> u
gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
instance Data Bool
instance Data Char
instance Data DataType
instance Data Double
instance Data Float
instance Data Handle
instance Data Int
instance Data Int16
instance Data Int32
instance Data Int64
instance Data Int8
instance Data Integer
instance Data Ordering
instance Data ThreadId
instance Data TyCon
instance Data TypeRep
instance Data Word
instance Data Word16
instance Data Word32
instance Data Word64
instance Data Word8
instance Data ()
instance (Data a, Data b) => Data (a, b)
instance (Data a, Data b, Data c) => Data (a, b, c)
instance (Data a, Data b, Data c, Data d) => Data (a, b, c, d)
instance (Data a, Data b, Data c, Data d, Data e) => Data (a, b, c, d, e)
instance (Data a, Data b, Data c, Data d, Data e, Data f) => Data (a, b, c, d, e, f)
instance (Data a, Data b, Data c, Data d, Data e, Data f, Data g) => Data (a, b, c, d, e, f, g)
instance (Data a, Data b) => Data (a -> b)
instance (RealFloat a, Data a) => Data (Complex a)
instance Typeable a => Data (ForeignPtr a)
instance Typeable a => Data (IO a)
instance Typeable a => Data (IORef a)
instance Typeable a => Data (MVar a)
instance Data a => Data (Maybe a)
instance Typeable a => Data (Ptr a)
instance (Data a, Integral a) => Data (Ratio a)
instance Typeable a => Data (STM a)
instance Typeable a => Data (StablePtr a)
instance Typeable a => Data (TVar a)
instance Data a => Data [a]
instance (Typeable a, Data b, Ix a) => Data (Array a b)
instance (Data a, Data b) => Data (Either a b)
instance (Typeable s, Typeable a) => Data (ST s a)
data DataType
instance Data DataType
instance Show DataType
instance Typeable DataType
mkDataType :: String -> [Constr] -> DataType
mkIntType :: String -> DataType
mkFloatType :: String -> DataType
mkStringType :: String -> DataType
mkNorepType :: String -> DataType
dataTypeName :: DataType -> String
data DataRep
AlgRep :: [Constr] -> DataRep
IntRep :: DataRep
FloatRep :: DataRep
StringRep :: DataRep
NoRep :: DataRep
instance Eq DataRep
instance Show DataRep
dataTypeRep :: DataType -> DataRep
repConstr :: DataType -> ConstrRep -> Constr
isAlgType :: DataType -> Bool
dataTypeConstrs :: DataType -> [Constr]
indexConstr :: DataType -> ConIndex -> Constr
maxConstrIndex :: DataType -> ConIndex
isNorepType :: DataType -> Bool
data Constr
instance Eq Constr
instance Show Constr
type ConIndex = Int
data Fixity
Prefix :: Fixity
Infix :: Fixity
instance Eq Fixity
instance Show Fixity
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr
mkIntConstr :: DataType -> Integer -> Constr
mkFloatConstr :: DataType -> Double -> Constr
mkStringConstr :: DataType -> String -> Constr
constrType :: Constr -> DataType
data ConstrRep
AlgConstr :: ConIndex -> ConstrRep
IntConstr :: Integer -> ConstrRep
FloatConstr :: Double -> ConstrRep
StringConstr :: String -> ConstrRep
instance Eq ConstrRep
instance Show ConstrRep
constrRep :: Constr -> ConstrRep
constrFields :: Constr -> [String]
constrFixity :: Constr -> Fixity
constrIndex :: Constr -> ConIndex
showConstr :: Constr -> String
readConstr :: DataType -> String -> Maybe Constr
tyconUQname :: String -> String
tyconModule :: String -> String
fromConstr :: Data a => Constr -> a
fromConstrB :: Data a => a -> Constr -> a
fromConstrM :: (Monad m, Data a) => m a -> Constr -> m a

module Data.Complex
data Complex a
(:+) :: a -> a -> Complex a
instance Typeable1 Complex
instance (RealFloat a, Data a) => Data (Complex a)
instance (RealFloat a, Eq a) => Eq (Complex a)
instance RealFloat a => Floating (Complex a)
instance RealFloat a => Fractional (Complex a)
instance RealFloat a => Num (Complex a)
instance (RealFloat a, Read a) => Read (Complex a)
instance (RealFloat a, Show a) => Show (Complex a)
realPart :: RealFloat a => Complex a -> a
imagPart :: RealFloat a => Complex a -> a
mkPolar :: RealFloat a => a -> a -> Complex a
cis :: RealFloat a => a -> Complex a
polar :: RealFloat a => Complex a -> (a, a)
magnitude :: RealFloat a => Complex a -> a
phase :: RealFloat a => Complex a -> a
conjugate :: RealFloat a => Complex a -> Complex a

module Data.Generics.Aliases
mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
mkM :: (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
mkMp :: (MonadPlus m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
mkR :: (MonadPlus m, Typeable a, Typeable b) => m b -> m a
ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
extB :: (Typeable a, Typeable b) => a -> b -> a
extR :: (Monad m, Typeable a, Typeable b) => m a -> m b -> m a
type GenericT = a -> a
type GenericQ r = a -> r
type GenericM m = a -> m a
type GenericB = a
type GenericR m = m a
type Generic c = a -> c a
data Generic' c
Generic' :: Generic c -> Generic' c
unGeneric' :: Generic' c -> Generic c
newtype GenericT'
unGT :: GenericT' -> (Data a => a -> a)
newtype GenericQ' r
GQ :: GenericQ r -> GenericQ' r
unGQ :: GenericQ' r -> GenericQ r
newtype GenericM' m
unGM :: GenericM' m -> (Data a => a -> m a)
orElse :: Maybe a -> Maybe a -> Maybe a
recoverMp :: MonadPlus m => GenericM m -> GenericM m
recoverQ :: MonadPlus m => r -> GenericQ (m r) -> GenericQ (m r)
choiceMp :: MonadPlus m => GenericM m -> GenericM m -> GenericM m
choiceQ :: MonadPlus m => GenericQ (m r) -> GenericQ (m r) -> GenericQ (m r)
ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
ext1M :: (Monad m, Data d, Typeable1 t) => (d -> m d) -> (t d -> m (t d)) -> d -> m d
ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t d -> q) -> d -> q
ext1R :: (Monad m, Data d, Typeable1 t) => m d -> m (t d) -> m d

module Data.Generics.Instances

module Data.Generics.Schemes
everywhere :: (a -> a) -> a -> a
everywhere' :: (a -> a) -> a -> a
everywhereBut :: GenericQ Bool -> GenericT -> GenericT
everywhereM :: Monad m => GenericM m -> GenericM m
somewhere :: MonadPlus m => GenericM m -> GenericM m
everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
listify :: Typeable r => (r -> Bool) -> GenericQ [r]
something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
synthesize :: s -> (t -> s -> s) -> GenericQ (s -> t) -> GenericQ t
gsize :: Data a => a -> Int
glength :: GenericQ Int
gdepth :: GenericQ Int
gcount :: GenericQ Bool -> GenericQ Int
gnodecount :: GenericQ Int
gtypecount :: Typeable a => a -> GenericQ Int
gfindtype :: (Data x, Typeable y) => x -> Maybe y

module Data.Generics.Text
gshow :: Data a => a -> String
gread :: Data a => ReadS a

module Data.Generics.Twins
gfoldlAccum :: Data d => (a -> c (d -> r) -> d -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
gmapAccumT :: Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)
gmapAccumM :: (Data d, Monad m) => (a -> d -> (a, m d)) -> a -> d -> (a, m d)
gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)
gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)
gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
gzipWithT :: GenericQ GenericT -> GenericQ GenericT
gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
gzipWithQ :: GenericQ (GenericQ r) -> GenericQ (GenericQ [r])
geq :: Data a => a -> a -> Bool
gzip :: GenericQ (GenericM Maybe) -> GenericQ (GenericM Maybe)

module Data.Generics

module Data.IORef
data IORef a
instance Typeable1 IORef
instance Typeable a => Data (IORef a)
instance Eq (IORef a)
newIORef :: a -> IO (IORef a)
readIORef :: IORef a -> IO a
writeIORef :: IORef a -> a -> IO ()
modifyIORef :: IORef a -> (a -> a) -> IO ()
atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))

module Data.Ix
class Ord a => Ix a
range :: Ix a => (a, a) -> [a]
index :: Ix a => (a, a) -> a -> Int
inRange :: Ix a => (a, a) -> a -> Bool
rangeSize :: Ix a => (a, a) -> Int
instance Ix Bool
instance Ix Char
instance Ix GeneralCategory
instance Ix IOMode
instance Ix Int
instance Ix Int16
instance Ix Int32
instance Ix Int64
instance Ix Int8
instance Ix Integer
instance Ix Ordering
instance Ix SeekMode
instance Ix Word
instance Ix Word16
instance Ix Word32
instance Ix Word64
instance Ix Word8
instance Ix ()
instance (Ix a, Ix b) => Ix (a, b)
instance (Ix a1, Ix a2, Ix a3) => Ix (a1, a2, a3)
instance (Ix a1, Ix a2, Ix a3, Ix a4) => Ix (a1, a2, a3, a4)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5) => Ix (a1, a2, a3, a4, a5)

module Data.Monoid
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
instance Monoid All
instance Monoid Any
instance Monoid Ordering
instance Monoid ()
instance (Monoid a, Monoid b) => Monoid (a, b)
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
instance (Monoid a, Monoid b, Monoid c, Monoid d) => Monoid (a, b, c, d)
instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) => Monoid (a, b, c, d, e)
instance Monoid b => Monoid (a -> b)
instance Monoid a => Monoid (Dual a)
instance Monoid (Endo a)
instance Monoid (First a)
instance Monoid (Last a)
instance Monoid a => Monoid (Maybe a)
instance Num a => Monoid (Product a)
instance Num a => Monoid (Sum a)
instance Monoid [a]
newtype Dual a
Dual :: a -> Dual a
getDual :: Dual a -> a
instance Bounded a => Bounded (Dual a)
instance Eq a => Eq (Dual a)
instance Monoid a => Monoid (Dual a)
instance Ord a => Ord (Dual a)
instance Read a => Read (Dual a)
instance Show a => Show (Dual a)
newtype Endo a
Endo :: (a -> a) -> Endo a
appEndo :: Endo a -> a -> a
instance Monoid (Endo a)
newtype All
All :: Bool -> All
getAll :: All -> Bool
instance Bounded All
instance Eq All
instance Monoid All
instance Ord All
instance Read All
instance Show All
newtype Any
Any :: Bool -> Any
getAny :: Any -> Bool
instance Bounded Any
instance Eq Any
instance Monoid Any
instance Ord Any
instance Read Any
instance Show Any
newtype Sum a
Sum :: a -> Sum a
getSum :: Sum a -> a
instance Bounded a => Bounded (Sum a)
instance Eq a => Eq (Sum a)
instance Num a => Monoid (Sum a)
instance Ord a => Ord (Sum a)
instance Read a => Read (Sum a)
instance Show a => Show (Sum a)
newtype Product a
Product :: a -> Product a
getProduct :: Product a -> a
instance Bounded a => Bounded (Product a)
instance Eq a => Eq (Product a)
instance Num a => Monoid (Product a)
instance Ord a => Ord (Product a)
instance Read a => Read (Product a)
instance Show a => Show (Product a)
newtype First a
First :: Maybe a -> First a
getFirst :: First a -> Maybe a
instance Eq a => Eq (First a)
instance Monoid (First a)
instance Ord a => Ord (First a)
instance Read a => Read (First a)
instance Show a => Show (First a)
newtype Last a
Last :: Maybe a -> Last a
getLast :: Last a -> Maybe a
instance Eq a => Eq (Last a)
instance Monoid (Last a)
instance Ord a => Ord (Last a)
instance Read a => Read (Last a)
instance Show a => Show (Last a)

module Data.Ratio
data Ratio a
instance Typeable1 Ratio
instance (Data a, Integral a) => Data (Ratio a)
instance Integral a => Enum (Ratio a)
instance (Integral a, Eq a) => Eq (Ratio a)
instance Integral a => Fractional (Ratio a)
instance Integral a => Num (Ratio a)
instance Integral a => Ord (Ratio a)
instance (Integral a, Read a) => Read (Ratio a)
instance Integral a => Real (Ratio a)
instance Integral a => RealFrac (Ratio a)
instance Integral a => Show (Ratio a)
type Rational = Ratio Integer
(%) :: Integral a => a -> a -> Ratio a
numerator :: Integral a => Ratio a -> a
denominator :: Integral a => Ratio a -> a
approxRational :: RealFrac a => a -> a -> Rational

module Data.STRef
data STRef s a
instance Typeable2 STRef
instance Eq (STRef s a)
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s ()

module Data.STRef.Lazy
data STRef s a
instance Typeable2 STRef
instance Eq (STRef s a)
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s ()

module Data.STRef.Strict

module Data.Version
data Version
Version :: [Int] -> [String] -> Version
versionBranch :: Version -> [Int]
versionTags :: Version -> [String]
instance Eq Version
instance Ord Version
instance Read Version
instance Show Version
instance Typeable Version
showVersion :: Version -> String
parseVersion :: ReadP Version

module Debug.Trace
putTraceMsg :: String -> IO ()
trace :: String -> a -> a

module GHC.Environment
getFullArgs :: IO [String]

module GHC.Exts
data Int
I# :: Int# -> Int
instance Bits Int
instance Bounded Int
instance Data Int
instance Enum Int
instance Eq Int
instance Integral Int
instance Ix Int
instance Num Int
instance Ord Int
instance PrintfArg Int
instance Read Int
instance Real Int
instance Show Int
instance Storable Int
instance Typeable Int
data Word
W# :: Word# -> Word
instance Bits Word
instance Bounded Word
instance Data Word
instance Enum Word
instance Eq Word
instance Integral Word
instance Ix Word
instance Num Word
instance Ord Word
instance PrintfArg Word
instance Read Word
instance Real Word
instance Show Word
instance Storable Word
instance Typeable Word
data Float
F# :: Float# -> Float
instance Data Float
instance Enum Float
instance Eq Float
instance Floating Float
instance Fractional Float
instance Num Float
instance Ord Float
instance PrintfArg Float
instance Read Float
instance Real Float
instance RealFloat Float
instance RealFrac Float
instance Show Float
instance Storable Float
instance Typeable Float
data Double
D# :: Double# -> Double
instance Data Double
instance Enum Double
instance Eq Double
instance Floating Double
instance Fractional Double
instance Num Double
instance Ord Double
instance PrintfArg Double
instance Read Double
instance Real Double
instance RealFloat Double
instance RealFrac Double
instance Show Double
instance Storable Double
instance Typeable Double
data Integer
S# :: Int# -> Integer
J# :: Int# -> ByteArray# -> Integer
instance Bits Integer
instance Data Integer
instance Enum Integer
instance Eq Integer
instance Integral Integer
instance Ix Integer
instance Num Integer
instance Ord Integer
instance PrintfArg Integer
instance Read Integer
instance Real Integer
instance Show Integer
instance Typeable Integer
data Char
C# :: Char# -> Char
instance Bounded Char
instance Data Char
instance Enum Char
instance Eq Char
instance IsChar Char
instance Ix Char
instance Ord Char
instance PrintfArg Char
instance Read Char
instance Show Char
instance Storable Char
instance Typeable Char
instance IsString [Char]
data Ptr a
Ptr :: Addr# -> Ptr a
instance Typeable1 Ptr
instance Typeable a => Data (Ptr a)
instance Eq (Ptr a)
instance Ord (Ptr a)
instance Show (Ptr a)
instance Storable (Ptr a)
data FunPtr a
FunPtr :: Addr# -> FunPtr a
instance Typeable1 FunPtr
instance Eq (FunPtr a)
instance Ord (FunPtr a)
instance Show (FunPtr a)
instance Storable (FunPtr a)
shiftL# :: Word# -> Int# -> Word#
shiftRL# :: Word# -> Int# -> Word#
iShiftL# :: Int# -> Int# -> Int#
iShiftRA# :: Int# -> Int# -> Int#
iShiftRL# :: Int# -> Int# -> Int#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
build :: (a -> b -> b -> b -> b) -> [a]
augment :: (a -> b -> b -> b -> b) -> [a] -> [a]
class IsString a
fromString :: IsString a => String -> a
instance IsString [Char]
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a
lazy :: a -> a
inline :: a -> a

module System.CPUTime
getCPUTime :: IO Integer
cpuTimePrecision :: Integer

module System.Console.GetOpt
getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
usageInfo :: String -> [OptDescr a] -> String
data ArgOrder a
RequireOrder :: ArgOrder a
Permute :: ArgOrder a
ReturnInOrder :: (String -> a) -> ArgOrder a
data OptDescr a
Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a
data ArgDescr a
NoArg :: a -> ArgDescr a
ReqArg :: (String -> a) -> String -> ArgDescr a
OptArg :: (Maybe String -> a) -> String -> ArgDescr a

module System.Exit
data ExitCode
ExitSuccess :: ExitCode
ExitFailure :: Int -> ExitCode
instance Eq ExitCode
instance Ord ExitCode
instance Read ExitCode
instance Show ExitCode
exitWith :: ExitCode -> IO a
exitFailure :: IO a

module System.Info
os :: String
arch :: String
compilerName :: String
compilerVersion :: Version

module System.Mem
performGC :: IO ()

module System.Mem.StableName
data StableName a
instance Typeable1 StableName
instance Eq (StableName a)
makeStableName :: a -> IO (StableName a)
hashStableName :: StableName a -> Int

module System.Mem.Weak
data Weak v
instance Typeable1 Weak
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)
deRefWeak :: Weak v -> IO (Maybe v)
finalize :: Weak v -> IO ()
mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)
addFinalizer :: key -> IO () -> IO ()
mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))

module Text.Printf
printf :: PrintfType r => String -> r
hPrintf :: HPrintfType r => Handle -> String -> r
class PrintfType t
instance (PrintfArg a, PrintfType r) => PrintfType (a -> r)
instance PrintfType (IO a)
instance IsChar c => PrintfType [c]
class HPrintfType t
instance (PrintfArg a, HPrintfType r) => HPrintfType (a -> r)
instance HPrintfType (IO a)
class PrintfArg a
instance PrintfArg Char
instance PrintfArg Double
instance PrintfArg Float
instance PrintfArg Int
instance PrintfArg Int16
instance PrintfArg Int32
instance PrintfArg Int64
instance PrintfArg Int8
instance PrintfArg Integer
instance PrintfArg Word
instance PrintfArg Word16
instance PrintfArg Word32
instance PrintfArg Word64
instance PrintfArg Word8
instance IsChar c => PrintfArg [c]
class IsChar c
instance IsChar Char

module Text.Show.Functions

module Control.Exception
data Exception
ArithException :: ArithException -> Exception
ArrayException :: ArrayException -> Exception
AssertionFailed :: String -> Exception
AsyncException :: AsyncException -> Exception
BlockedOnDeadMVar :: Exception
BlockedIndefinitely :: Exception
NestedAtomically :: Exception
Deadlock :: Exception
DynException :: Dynamic -> Exception
ErrorCall :: String -> Exception
ExitException :: ExitCode -> Exception
IOException :: IOException -> Exception
NoMethodError :: String -> Exception
NonTermination :: Exception
PatternMatchFail :: String -> Exception
RecConError :: String -> Exception
RecSelError :: String -> Exception
RecUpdError :: String -> Exception
instance Eq Exception
instance Show Exception
instance Typeable Exception
data IOException
instance Eq IOException
instance Show IOException
instance Typeable IOException
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException
instance Eq ArithException
instance Ord ArithException
instance Show ArithException
instance Typeable ArithException
data ArrayException
IndexOutOfBounds :: String -> ArrayException
UndefinedElement :: String -> ArrayException
instance Eq ArrayException
instance Ord ArrayException
instance Show ArrayException
instance Typeable ArrayException
data AsyncException
StackOverflow :: AsyncException
HeapOverflow :: AsyncException
ThreadKilled :: AsyncException
instance Eq AsyncException
instance Ord AsyncException
instance Show AsyncException
instance Typeable AsyncException
throwIO :: Exception -> IO a
throw :: Exception -> a
ioError :: IOError -> IO a
throwTo :: ThreadId -> Exception -> IO ()
catch :: IO a -> (Exception -> IO a) -> IO a
catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
handle :: (Exception -> IO a) -> IO a -> IO a
handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
try :: IO a -> IO (Either Exception a)
tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
evaluate :: a -> IO a
mapException :: (Exception -> Exception) -> a -> a
ioErrors :: Exception -> Maybe IOError
arithExceptions :: Exception -> Maybe ArithException
errorCalls :: Exception -> Maybe String
dynExceptions :: Exception -> Maybe Dynamic
assertions :: Exception -> Maybe String
asyncExceptions :: Exception -> Maybe AsyncException
userErrors :: Exception -> Maybe String
throwDyn :: Typeable exception => exception -> b
throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
block :: IO a -> IO a
unblock :: IO a -> IO a
assert :: Bool -> a -> a
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracket_ :: IO a -> IO b -> IO c -> IO c
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
finally :: IO a -> IO b -> IO a
setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (Exception -> IO ())

module System.Environment
getArgs :: IO [String]
getProgName :: IO String
getEnv :: String -> IO String
withArgs :: [String] -> IO a -> IO a
withProgName :: String -> IO a -> IO a
getEnvironment :: IO [(String, String)]

module Control.Concurrent.MVar
data MVar a
instance Typeable1 MVar
instance Typeable a => Data (MVar a)
instance Eq (MVar a)
newEmptyMVar :: IO (MVar a)
newMVar :: a -> IO (MVar a)
takeMVar :: MVar a -> IO a
putMVar :: MVar a -> a -> IO ()
readMVar :: MVar a -> IO a
swapMVar :: MVar a -> a -> IO a
tryTakeMVar :: MVar a -> IO (Maybe a)
tryPutMVar :: MVar a -> a -> IO Bool
isEmptyMVar :: MVar a -> IO Bool
withMVar :: MVar a -> (a -> IO b) -> IO b
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
addMVarFinalizer :: MVar a -> IO () -> IO ()

module Control.Concurrent.QSem
data QSem
instance Typeable QSem
newQSem :: Int -> IO QSem
waitQSem :: QSem -> IO ()
signalQSem :: QSem -> IO ()

module Control.Concurrent.QSemN
data QSemN
instance Typeable QSemN
newQSemN :: Int -> IO QSemN
waitQSemN :: QSemN -> Int -> IO ()
signalQSemN :: QSemN -> Int -> IO ()

module Control.Concurrent.SampleVar
type SampleVar a = MVar (Int, MVar a)
newEmptySampleVar :: IO (SampleVar a)
newSampleVar :: a -> IO (SampleVar a)
emptySampleVar :: SampleVar a -> IO ()
readSampleVar :: SampleVar a -> IO a
writeSampleVar :: SampleVar a -> a -> IO ()
isEmptySampleVar :: SampleVar a -> IO Bool

module Data.Unique
data Unique
instance Eq Unique
instance Ord Unique
newUnique :: IO Unique
hashUnique :: Unique -> Int

module Control.Concurrent.Chan
data Chan a
instance Typeable1 Chan
newChan :: IO (Chan a)
writeChan :: Chan a -> a -> IO ()
readChan :: Chan a -> IO a
dupChan :: Chan a -> IO (Chan a)
unGetChan :: Chan a -> a -> IO ()
isEmptyChan :: Chan a -> IO Bool
getChanContents :: Chan a -> IO [a]
writeList2Chan :: Chan a -> [a] -> IO ()

module Control.Concurrent
data ThreadId
instance Data ThreadId
instance Eq ThreadId
instance Ord ThreadId
instance Show ThreadId
instance Typeable ThreadId
myThreadId :: IO ThreadId
forkIO :: IO () -> IO ThreadId
killThread :: ThreadId -> IO ()
throwTo :: ThreadId -> Exception -> IO ()
yield :: IO ()
threadDelay :: Int -> IO ()
threadWaitRead :: Fd -> IO ()
threadWaitWrite :: Fd -> IO ()
mergeIO :: [a] -> [a] -> IO [a]
nmergeIO :: [[a]] -> IO [a]
rtsSupportsBoundThreads :: Bool
forkOS :: IO () -> IO ThreadId
isCurrentThreadBound :: IO Bool
runInBoundThread :: IO a -> IO a
runInUnboundThread :: IO a -> IO a

module GHC.ConsoleHandler
data Handler
Default :: Handler
Ignore :: Handler
Catch :: (ConsoleEvent -> IO ()) -> Handler
installHandler :: Handler -> IO Handler
data ConsoleEvent
ControlC :: ConsoleEvent
Break :: ConsoleEvent
Close :: ConsoleEvent
Logoff :: ConsoleEvent
Shutdown :: ConsoleEvent
instance Enum ConsoleEvent
instance Eq ConsoleEvent
instance Ord ConsoleEvent
instance Read ConsoleEvent
instance Show ConsoleEvent
instance Typeable ConsoleEvent
flushConsole :: Handle -> IO ()

module System.Timeout
timeout :: Int -> IO a -> IO (Maybe a)

module Control.Arrow
class Arrow a
arr :: Arrow a => (b -> c) -> a b c
pure :: Arrow a => (b -> c) -> a b c
(>>>) :: Arrow a => a b c -> a c d -> a b d
first :: Arrow a => a b c -> a (b, d) (c, d)
second :: Arrow a => a b c -> a (d, b) (d, c)
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
instance Arrow (->)
instance Monad m => Arrow (Kleisli m)
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
runKleisli :: Kleisli m a b -> a -> m b
instance Monad m => Arrow (Kleisli m)
instance Monad m => ArrowApply (Kleisli m)
instance Monad m => ArrowChoice (Kleisli m)
instance MonadFix m => ArrowLoop (Kleisli m)
instance MonadPlus m => ArrowPlus (Kleisli m)
instance MonadPlus m => ArrowZero (Kleisli m)
returnA :: Arrow a => a b b
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
(<<<) :: Arrow a => a c d -> a b c -> a b d
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
class Arrow a => ArrowZero a
zeroArrow :: ArrowZero a => a b c
instance MonadPlus m => ArrowZero (Kleisli m)
class ArrowZero a => ArrowPlus a
(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
instance MonadPlus m => ArrowPlus (Kleisli m)
class Arrow a => ArrowChoice a
left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
instance ArrowChoice (->)
instance Monad m => ArrowChoice (Kleisli m)
class Arrow a => ArrowApply a
app :: ArrowApply a => a (a b c, b) c
instance ArrowApply (->)
instance Monad m => ArrowApply (Kleisli m)
newtype ArrowMonad a b
ArrowMonad :: a () b -> ArrowMonad a b
instance ArrowApply a => Monad (ArrowMonad a)
leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
class Arrow a => ArrowLoop a
loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
instance ArrowLoop (->)
instance MonadFix m => ArrowLoop (Kleisli m)

module Control.Applicative
class Functor f => Applicative f
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
instance Applicative IO
instance Applicative Id
instance Applicative Maybe
instance Applicative ZipList
instance Applicative []
instance Monoid m => Applicative (Const m)
instance Monad m => Applicative (WrappedMonad m)
instance Monoid a => Applicative ((,) a)
instance Applicative ((->) a)
instance Arrow a => Applicative (WrappedArrow a b)
class Applicative f => Alternative f
empty :: Alternative f => f a
(<|>) :: Alternative f => f a -> f a -> f a
instance Alternative Maybe
instance Alternative []
instance MonadPlus m => Alternative (WrappedMonad m)
instance (ArrowZero a, ArrowPlus a) => Alternative (WrappedArrow a b)
newtype Const a b
Const :: a -> Const a b
getConst :: Const a b -> a
instance Monoid m => Applicative (Const m)
instance Functor (Const m)
newtype WrappedMonad m a
WrapMonad :: m a -> WrappedMonad m a
unwrapMonad :: WrappedMonad m a -> m a
instance MonadPlus m => Alternative (WrappedMonad m)
instance Monad m => Applicative (WrappedMonad m)
instance Monad m => Functor (WrappedMonad m)
newtype WrappedArrow a b c
WrapArrow :: a b c -> WrappedArrow a b c
unwrapArrow :: WrappedArrow a b c -> a b c
instance (ArrowZero a, ArrowPlus a) => Alternative (WrappedArrow a b)
instance Arrow a => Applicative (WrappedArrow a b)
instance Arrow a => Functor (WrappedArrow a b)
newtype ZipList a
ZipList :: [a] -> ZipList a
getZipList :: ZipList a -> [a]
instance Applicative ZipList
instance Functor ZipList
(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
liftA :: Applicative f => (a -> b) -> f a -> f b
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
optional :: Alternative f => f a -> f (Maybe a)
some :: Alternative f => f a -> f [a]
many :: Alternative f => f a -> f [a]

module Data.Foldable
class Foldable t
fold :: (Foldable t, Monoid m) => t m -> m
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
instance Foldable Maybe
instance Foldable []
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
asum :: (Foldable t, Alternative f) => t (f a) -> f a
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
toList :: Foldable t => t a -> [a]
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
and :: Foldable t => t Bool -> Bool
or :: Foldable t => t Bool -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
all :: Foldable t => (a -> Bool) -> t a -> Bool
sum :: (Foldable t, Num a) => t a -> a
product :: (Foldable t, Num a) => t a -> a
maximum :: (Foldable t, Ord a) => t a -> a
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
minimum :: (Foldable t, Ord a) => t a -> a
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
elem :: (Foldable t, Eq a) => a -> t a -> Bool
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

module Data.Traversable
class (Functor t, Foldable t) => Traversable t
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
instance Traversable Maybe
instance Traversable []
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
fmapDefault :: Traversable t => (a -> b) -> t a -> t b
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Language.Haskell.Extension
data Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
RecursiveDo :: Extension
ParallelListComp :: Extension
MultiParamTypeClasses :: Extension
NoMonomorphismRestriction :: Extension
FunctionalDependencies :: Extension
Rank2Types :: Extension
RankNTypes :: Extension
PolymorphicComponents :: Extension
ExistentialQuantification :: Extension
ScopedTypeVariables :: Extension
ImplicitParams :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
EmptyDataDecls :: Extension
CPP :: Extension
KindSignatures :: Extension
BangPatterns :: Extension
TypeSynonymInstances :: Extension
TemplateHaskell :: Extension
ForeignFunctionInterface :: Extension
Arrows :: Extension
Generics :: Extension
NoImplicitPrelude :: Extension
NamedFieldPuns :: Extension
PatternGuards :: Extension
GeneralizedNewtypeDeriving :: Extension
ExtensibleRecords :: Extension
RestrictedTypeSynonyms :: Extension
HereDocuments :: Extension
MagicHash :: Extension
TypeFamilies :: Extension
StandaloneDeriving :: Extension
UnicodeSyntax :: Extension
PatternSignatures :: Extension
UnliftedFFITypes :: Extension
LiberalTypeSynonyms :: Extension
TypeOperators :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
DisambiguateRecordFields :: Extension
OverloadedStrings :: Extension
GADTs :: Extension
NoMonoPatBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
UnboxedTuples :: Extension
DeriveDataTypeable :: Extension
ConstrainedClassMethods :: Extension
instance Eq Extension
instance Read Extension
instance Show Extension

module Distribution.Verbosity
data Verbosity
instance Eq Verbosity
instance Ord Verbosity
instance Show Verbosity
silent :: Verbosity
normal :: Verbosity
verbose :: Verbosity
deafening :: Verbosity
moreVerbose :: Verbosity -> Verbosity
lessVerbose :: Verbosity -> Verbosity
intToVerbosity :: Int -> Maybe Verbosity
flagToVerbosity :: Maybe String -> Verbosity
showForCabal :: Verbosity -> String
showForGHC :: Verbosity -> String

module Distribution.System
data OS
Linux :: OS
Windows :: Windows -> OS
OSX :: OS
Solaris :: OS
Other :: String -> OS
data Windows
MingW :: Windows
os :: OS

module Distribution.Simple.PreProcess.Unlit
unlit :: FilePath -> String -> String
plain :: String -> String -> String

module Distribution.Simple.GHC.Makefile
makefileTemplate :: String

module Distribution.License
data License
GPL :: License
LGPL :: License
BSD3 :: License
BSD4 :: License
PublicDomain :: License
AllRightsReserved :: License
OtherLicense :: License
instance Eq License
instance Read License
instance Show License

module Distribution.Extension
data Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
RecursiveDo :: Extension
ParallelListComp :: Extension
MultiParamTypeClasses :: Extension
NoMonomorphismRestriction :: Extension
FunctionalDependencies :: Extension
Rank2Types :: Extension
RankNTypes :: Extension
PolymorphicComponents :: Extension
ExistentialQuantification :: Extension
ScopedTypeVariables :: Extension
ImplicitParams :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
EmptyDataDecls :: Extension
CPP :: Extension
KindSignatures :: Extension
BangPatterns :: Extension
TypeSynonymInstances :: Extension
TemplateHaskell :: Extension
ForeignFunctionInterface :: Extension
Arrows :: Extension
Generics :: Extension
NoImplicitPrelude :: Extension
NamedFieldPuns :: Extension
PatternGuards :: Extension
GeneralizedNewtypeDeriving :: Extension
ExtensibleRecords :: Extension
RestrictedTypeSynonyms :: Extension
HereDocuments :: Extension
MagicHash :: Extension
TypeFamilies :: Extension
StandaloneDeriving :: Extension
UnicodeSyntax :: Extension
PatternSignatures :: Extension
UnliftedFFITypes :: Extension
LiberalTypeSynonyms :: Extension
TypeOperators :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
DisambiguateRecordFields :: Extension
OverloadedStrings :: Extension
GADTs :: Extension
NoMonoPatBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
UnboxedTuples :: Extension
DeriveDataTypeable :: Extension
ConstrainedClassMethods :: Extension
instance Eq Extension
instance Read Extension
instance Show Extension

module Distribution.Compiler
data CompilerFlavor
GHC :: CompilerFlavor
NHC :: CompilerFlavor
Hugs :: CompilerFlavor
HBC :: CompilerFlavor
Helium :: CompilerFlavor
JHC :: CompilerFlavor
OtherCompiler :: String -> CompilerFlavor
instance Eq CompilerFlavor
instance Ord CompilerFlavor
instance Read CompilerFlavor
instance Show CompilerFlavor
defaultCompilerFlavor :: Maybe CompilerFlavor

module Distribution.Compat.ReadP
type ReadP r a = ReadP a

module Distribution.Version
readVersion :: String -> Maybe Version
data VersionRange
AnyVersion :: VersionRange
ThisVersion :: Version -> VersionRange
LaterVersion :: Version -> VersionRange
EarlierVersion :: Version -> VersionRange
UnionVersionRanges :: VersionRange -> VersionRange -> VersionRange
IntersectVersionRanges :: VersionRange -> VersionRange -> VersionRange
instance Eq VersionRange
instance Read VersionRange
instance Show VersionRange
orLaterVersion :: Version -> VersionRange
orEarlierVersion :: Version -> VersionRange
betweenVersionsInclusive :: Version -> Version -> VersionRange
withinRange :: Version -> VersionRange -> Bool
showVersionRange :: VersionRange -> String
parseVersionRange :: ReadP r VersionRange
isAnyVersion :: VersionRange -> Bool
data Dependency
Dependency :: String -> VersionRange -> Dependency
instance Eq Dependency
instance Read Dependency
instance Show Dependency

module Distribution.Configuration
data Flag
MkFlag :: String -> String -> Bool -> Flag
flagName :: Flag -> String
flagDescription :: Flag -> String
flagDefault :: Flag -> Bool
instance Show Flag
data ConfVar
OS :: String -> ConfVar
Arch :: String -> ConfVar
Flag :: ConfFlag -> ConfVar
Impl :: String -> VersionRange -> ConfVar
instance Eq ConfVar
instance Show ConfVar
data Condition c
Var :: c -> Condition c
Lit :: Bool -> Condition c
CNot :: Condition c -> Condition c
COr :: Condition c -> Condition c -> Condition c
CAnd :: Condition c -> Condition c -> Condition c
instance Show c => Show (Condition c)
parseCondition :: ReadP r (Condition ConfVar)
simplifyCondition :: Condition c -> (c -> Either d Bool) -> (Condition d, [d])
data CondTree v c a
CondNode :: a -> c -> [(Condition v, CondTree v c a, Maybe (CondTree v c a))] -> CondTree v c a
condTreeData :: CondTree v c a -> a
condTreeConstraints :: CondTree v c a -> c
condTreeComponents :: CondTree v c a -> [(Condition v, CondTree v c a, Maybe (CondTree v c a))]
instance (Show v, Show c) => Show (CondTree v c a)
ppCondTree :: Show v => CondTree v c a -> (c -> Doc) -> Doc
mapTreeData :: (a -> b) -> CondTree v c a -> CondTree v c b
resolveWithFlags :: Monoid a => [(String, [Bool])] -> String -> String -> (String, Version) -> [CondTree ConfVar [d] a] -> ([d] -> DepTestRslt [d]) -> Either [d] ([a], [d], [(String, Bool)])
ignoreConditions :: (Monoid a, Monoid c) => CondTree v c a -> (a, c)
data DepTestRslt d
DepOk :: DepTestRslt d
MissingDeps :: d -> DepTestRslt d
instance Monoid d => Monoid (DepTestRslt d)

module Distribution.Package
data PackageIdentifier
PackageIdentifier :: String -> Version -> PackageIdentifier
pkgName :: PackageIdentifier -> String
pkgVersion :: PackageIdentifier -> Version
instance Eq PackageIdentifier
instance Ord PackageIdentifier
instance Read PackageIdentifier
instance Show PackageIdentifier
showPackageId :: PackageIdentifier -> String
parsePackageId :: ReadP r PackageIdentifier
parsePackageName :: ReadP r String

module Distribution.InstalledPackageInfo
data InstalledPackageInfo
InstalledPackageInfo :: PackageIdentifier -> License -> String -> String -> String -> String -> String -> String -> String -> String -> Bool -> [String] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [String] -> [PackageIdentifier] -> [String] -> [String] -> [String] -> [FilePath] -> [String] -> [FilePath] -> [FilePath] -> InstalledPackageInfo
package :: InstalledPackageInfo -> PackageIdentifier
license :: InstalledPackageInfo -> License
copyright :: InstalledPackageInfo -> String
maintainer :: InstalledPackageInfo -> String
author :: InstalledPackageInfo -> String
stability :: InstalledPackageInfo -> String
homepage :: InstalledPackageInfo -> String
pkgUrl :: InstalledPackageInfo -> String
description :: InstalledPackageInfo -> String
category :: InstalledPackageInfo -> String
exposed :: InstalledPackageInfo -> Bool
exposedModules :: InstalledPackageInfo -> [String]
hiddenModules :: InstalledPackageInfo -> [String]
importDirs :: InstalledPackageInfo -> [FilePath]
libraryDirs :: InstalledPackageInfo -> [FilePath]
hsLibraries :: InstalledPackageInfo -> [String]
extraLibraries :: InstalledPackageInfo -> [String]
extraGHCiLibraries :: InstalledPackageInfo -> [String]
includeDirs :: InstalledPackageInfo -> [FilePath]
includes :: InstalledPackageInfo -> [String]
depends :: InstalledPackageInfo -> [PackageIdentifier]
hugsOptions :: InstalledPackageInfo -> [String]
ccOptions :: InstalledPackageInfo -> [String]
ldOptions :: InstalledPackageInfo -> [String]
frameworkDirs :: InstalledPackageInfo -> [FilePath]
frameworks :: InstalledPackageInfo -> [String]
haddockInterfaces :: InstalledPackageInfo -> [FilePath]
haddockHTMLs :: InstalledPackageInfo -> [FilePath]
instance Read InstalledPackageInfo
instance Show InstalledPackageInfo
data ParseResult a
ParseFailed :: PError -> ParseResult a
ParseOk :: [PWarning] -> a -> ParseResult a
instance Monad ParseResult
instance Show a => Show (ParseResult a)
data PError
AmbigousParse :: String -> LineNo -> PError
NoParse :: String -> LineNo -> PError
TabsError :: LineNo -> PError
FromString :: String -> Maybe LineNo -> PError
instance Show PError
type PWarning = String
emptyInstalledPackageInfo :: InstalledPackageInfo
parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
showInstalledPackageInfo :: InstalledPackageInfo -> String
showInstalledPackageInfoField :: String -> Maybe (InstalledPackageInfo -> String)

module Distribution.Simple.Compiler
data Compiler
Compiler :: CompilerFlavor -> PackageIdentifier -> [(Extension, Flag)] -> Compiler
compilerFlavor :: Compiler -> CompilerFlavor
compilerId :: Compiler -> PackageIdentifier
compilerExtensions :: Compiler -> [(Extension, Flag)]
instance Read Compiler
instance Show Compiler
showCompilerId :: Compiler -> String
compilerVersion :: Compiler -> Version
data PackageDB
GlobalPackageDB :: PackageDB
UserPackageDB :: PackageDB
SpecificPackageDB :: FilePath -> PackageDB
instance Read PackageDB
instance Show PackageDB
type Flag = String
extensionsToFlags :: Compiler -> [Extension] -> [Flag]
unsupportedExtensions :: Compiler -> [Extension] -> [Extension]

module Distribution.Simple.Utils
die :: String -> IO a
dieWithLocation :: FilePath -> Maybe Int -> String -> IO a
warn :: Verbosity -> String -> IO ()
notice :: Verbosity -> String -> IO ()
info :: Verbosity -> String -> IO ()
debug :: Verbosity -> String -> IO ()
breaks :: (a -> Bool) -> [a] -> [[a]]
wrapText :: Int -> [String] -> [String]
rawSystemExit :: Verbosity -> FilePath -> [String] -> IO ()
rawSystemStdout :: Verbosity -> FilePath -> [String] -> IO String
rawSystemStdout' :: Verbosity -> FilePath -> [String] -> IO (String, ExitCode)
maybeExit :: IO ExitCode -> IO ()
xargs :: Int -> ([String] -> IO ()) -> [String] -> [String] -> IO ()
matchesDescFile :: FilePath -> Bool
rawSystemPathExit :: Verbosity -> String -> [String] -> IO ()
smartCopySources :: Verbosity -> [FilePath] -> FilePath -> [String] -> [String] -> Bool -> Bool -> IO ()
createDirectoryIfMissingVerbose :: Verbosity -> Bool -> FilePath -> IO ()
copyFileVerbose :: Verbosity -> FilePath -> FilePath -> IO ()
copyDirectoryRecursiveVerbose :: Verbosity -> FilePath -> FilePath -> IO ()
moduleToFilePath :: [FilePath] -> String -> [String] -> IO [FilePath]
moduleToFilePath2 :: [FilePath] -> String -> [String] -> IO [(FilePath, FilePath)]
mkLibName :: FilePath -> String -> String
mkProfLibName :: FilePath -> String -> String
mkSharedLibName :: FilePath -> String -> PackageIdentifier -> String
currentDir :: FilePath
dotToSep :: String -> String
findFile :: [FilePath] -> FilePath -> IO FilePath
defaultPackageDesc :: Verbosity -> IO FilePath
findPackageDesc :: Verbosity -> FilePath -> IO FilePath
defaultHookedPackageDesc :: IO (Maybe FilePath)
findHookedPackageDesc :: FilePath -> IO (Maybe FilePath)
exeExtension :: String
objExtension :: String
dllExtension :: String

module Distribution.PackageDescription
data PackageDescription
PackageDescription :: PackageIdentifier -> License -> FilePath -> String -> String -> String -> String -> [(CompilerFlavor, VersionRange)] -> String -> String -> String -> String -> String -> [Dependency] -> VersionRange -> BuildType -> Maybe Library -> [Executable] -> [FilePath] -> [FilePath] -> [FilePath] -> PackageDescription
package :: PackageDescription -> PackageIdentifier
license :: PackageDescription -> License
licenseFile :: PackageDescription -> FilePath
copyright :: PackageDescription -> String
maintainer :: PackageDescription -> String
author :: PackageDescription -> String
stability :: PackageDescription -> String
testedWith :: PackageDescription -> [(CompilerFlavor, VersionRange)]
homepage :: PackageDescription -> String
pkgUrl :: PackageDescription -> String
synopsis :: PackageDescription -> String
description :: PackageDescription -> String
category :: PackageDescription -> String
buildDepends :: PackageDescription -> [Dependency]
descCabalVersion :: PackageDescription -> VersionRange
buildType :: PackageDescription -> BuildType
library :: PackageDescription -> Maybe Library
executables :: PackageDescription -> [Executable]
dataFiles :: PackageDescription -> [FilePath]
extraSrcFiles :: PackageDescription -> [FilePath]
extraTmpFiles :: PackageDescription -> [FilePath]
instance Eq PackageDescription
instance Read PackageDescription
instance Show PackageDescription
data GenericPackageDescription
GenericPackageDescription :: PackageDescription -> [Flag] -> Maybe (CondTree ConfVar [Dependency] Library) -> [(String, CondTree ConfVar [Dependency] Executable)] -> GenericPackageDescription
packageDescription :: GenericPackageDescription -> PackageDescription
genPackageFlags :: GenericPackageDescription -> [Flag]
condLibrary :: GenericPackageDescription -> Maybe (CondTree ConfVar [Dependency] Library)
condExecutables :: GenericPackageDescription -> [(String, CondTree ConfVar [Dependency] Executable)]
instance Show GenericPackageDescription
finalizePackageDescription :: [(String, Bool)] -> Maybe [PackageIdentifier] -> String -> String -> (String, Version) -> GenericPackageDescription -> Either [Dependency] (PackageDescription, [(String, Bool)])
flattenPackageDescription :: GenericPackageDescription -> PackageDescription
emptyPackageDescription :: PackageDescription
readPackageDescription :: Verbosity -> FilePath -> IO GenericPackageDescription
writePackageDescription :: FilePath -> PackageDescription -> IO ()
parsePackageDescription :: String -> ParseResult GenericPackageDescription
showPackageDescription :: PackageDescription -> String
data BuildType
Simple :: BuildType
Configure :: BuildType
Make :: BuildType
Custom :: BuildType
instance Eq BuildType
instance Read BuildType
instance Show BuildType
data Library
Library :: [String] -> BuildInfo -> Library
exposedModules :: Library -> [String]
libBuildInfo :: Library -> BuildInfo
instance Eq Library
instance Monoid Library
instance Read Library
instance Show Library
withLib :: PackageDescription -> a -> (Library -> IO a) -> IO a
hasLibs :: PackageDescription -> Bool
libModules :: PackageDescription -> [String]
data Executable
Executable :: String -> FilePath -> BuildInfo -> Executable
exeName :: Executable -> String
modulePath :: Executable -> FilePath
buildInfo :: Executable -> BuildInfo
instance Eq Executable
instance Monoid Executable
instance Read Executable
instance Show Executable
withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
hasExes :: PackageDescription -> Bool
exeModules :: PackageDescription -> [String]
data FieldDescr a
FieldDescr :: String -> (a -> Doc) -> (LineNo -> String -> a -> ParseResult a) -> FieldDescr a
fieldName :: FieldDescr a -> String
fieldGet :: FieldDescr a -> a -> Doc
fieldSet :: FieldDescr a -> LineNo -> String -> a -> ParseResult a
type LineNo = Int
sanityCheckPackage :: PackageDescription -> IO ([String], [String])
data BuildInfo
BuildInfo :: Bool -> [Dependency] -> [String] -> [String] -> [String] -> [Dependency] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [Extension] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [FilePath] -> [(CompilerFlavor, [String])] -> [String] -> [String] -> BuildInfo
buildable :: BuildInfo -> Bool
buildTools :: BuildInfo -> [Dependency]
cppOptions :: BuildInfo -> [String]
ccOptions :: BuildInfo -> [String]
ldOptions :: BuildInfo -> [String]
pkgconfigDepends :: BuildInfo -> [Dependency]
frameworks :: BuildInfo -> [String]
cSources :: BuildInfo -> [FilePath]
hsSourceDirs :: BuildInfo -> [FilePath]
otherModules :: BuildInfo -> [String]
extensions :: BuildInfo -> [Extension]
extraLibs :: BuildInfo -> [String]
extraLibDirs :: BuildInfo -> [String]
includeDirs :: BuildInfo -> [FilePath]
includes :: BuildInfo -> [FilePath]
installIncludes :: BuildInfo -> [FilePath]
options :: BuildInfo -> [(CompilerFlavor, [String])]
ghcProfOptions :: BuildInfo -> [String]
ghcSharedOptions :: BuildInfo -> [String]
instance Eq BuildInfo
instance Read BuildInfo
instance Show BuildInfo
emptyBuildInfo :: BuildInfo
allBuildInfo :: PackageDescription -> [BuildInfo]
type HookedBuildInfo = (Maybe BuildInfo, [(String, BuildInfo)])
emptyHookedBuildInfo :: HookedBuildInfo
readHookedBuildInfo :: Verbosity -> FilePath -> IO HookedBuildInfo
parseHookedBuildInfo :: String -> ParseResult HookedBuildInfo
writeHookedBuildInfo :: FilePath -> HookedBuildInfo -> IO ()
showHookedBuildInfo :: HookedBuildInfo -> String
updatePackageDescription :: HookedBuildInfo -> PackageDescription -> PackageDescription
satisfyDependency :: [PackageIdentifier] -> Dependency -> Maybe PackageIdentifier
data ParseResult a
ParseFailed :: PError -> ParseResult a
ParseOk :: [PWarning] -> a -> ParseResult a
instance Monad ParseResult
instance Show a => Show (ParseResult a)
hcOptions :: CompilerFlavor -> [(CompilerFlavor, [String])] -> [String]
autogenModuleName :: PackageDescription -> String
haddockName :: PackageDescription -> FilePath
setupMessage :: Verbosity -> String -> PackageDescription -> IO ()
cabalVersion :: Version

module Distribution.Simple.Program
data Program
Program :: String -> (Verbosity -> IO (Maybe FilePath)) -> (Verbosity -> FilePath -> IO (Maybe Version)) -> Program
programName :: Program -> String
programFindLocation :: Program -> Verbosity -> IO (Maybe FilePath)
programFindVersion :: Program -> Verbosity -> FilePath -> IO (Maybe Version)
simpleProgram :: String -> Program
findProgramOnPath :: FilePath -> Verbosity -> IO (Maybe FilePath)
findProgramVersion :: ProgArg -> (String -> String) -> Verbosity -> FilePath -> IO (Maybe Version)
data ConfiguredProgram
ConfiguredProgram :: String -> Maybe Version -> [ProgArg] -> ProgramLocation -> ConfiguredProgram
programId :: ConfiguredProgram -> String
programVersion :: ConfiguredProgram -> Maybe Version
programArgs :: ConfiguredProgram -> [ProgArg]
programLocation :: ConfiguredProgram -> ProgramLocation
instance Read ConfiguredProgram
instance Show ConfiguredProgram
programPath :: ConfiguredProgram -> FilePath
type ProgArg = String
data ProgramLocation
UserSpecified :: FilePath -> ProgramLocation
locationPath :: ProgramLocation -> FilePath
FoundOnSystem :: FilePath -> ProgramLocation
locationPath :: ProgramLocation -> FilePath
instance Read ProgramLocation
instance Show ProgramLocation
rawSystemProgram :: Verbosity -> ConfiguredProgram -> [ProgArg] -> IO ()
rawSystemProgramStdout :: Verbosity -> ConfiguredProgram -> [ProgArg] -> IO String
builtinPrograms :: [Program]
data ProgramConfiguration
instance Read ProgramConfiguration
instance Show ProgramConfiguration
emptyProgramConfiguration :: ProgramConfiguration
defaultProgramConfiguration :: ProgramConfiguration
addKnownProgram :: Program -> ProgramConfiguration -> ProgramConfiguration
lookupKnownProgram :: String -> ProgramConfiguration -> Maybe Program
knownPrograms :: ProgramConfiguration -> [(Program, Maybe ConfiguredProgram)]
userSpecifyPath :: String -> FilePath -> ProgramConfiguration -> ProgramConfiguration
userMaybeSpecifyPath :: String -> Maybe FilePath -> ProgramConfiguration -> ProgramConfiguration
userSpecifyArgs :: String -> [ProgArg] -> ProgramConfiguration -> ProgramConfiguration
lookupProgram :: Program -> ProgramConfiguration -> Maybe ConfiguredProgram
updateProgram :: ConfiguredProgram -> ProgramConfiguration -> ProgramConfiguration
configureAllKnownPrograms :: Verbosity -> ProgramConfiguration -> IO ProgramConfiguration
requireProgram :: Verbosity -> Program -> VersionRange -> ProgramConfiguration -> IO (ConfiguredProgram, ProgramConfiguration)
rawSystemProgramConf :: Verbosity -> Program -> ProgramConfiguration -> [ProgArg] -> IO ()
rawSystemProgramStdoutConf :: Verbosity -> Program -> ProgramConfiguration -> [ProgArg] -> IO String
ghcProgram :: Program
ghcPkgProgram :: Program
nhcProgram :: Program
hmakeProgram :: Program
jhcProgram :: Program
hugsProgram :: Program
ffihugsProgram :: Program
ranlibProgram :: Program
arProgram :: Program
happyProgram :: Program
alexProgram :: Program
hsc2hsProgram :: Program
c2hsProgram :: Program
cpphsProgram :: Program
hscolourProgram :: Program
haddockProgram :: Program
greencardProgram :: Program
ldProgram :: Program
tarProgram :: Program
cppProgram :: Program
pfesetupProgram :: Program
pkgConfigProgram :: Program

module Distribution.Simple.Setup
data Action
ConfigCmd :: ConfigFlags -> Action
BuildCmd :: Action
CleanCmd :: Action
CopyCmd :: CopyDest -> Action
HscolourCmd :: Action
HaddockCmd :: Action
ProgramaticaCmd :: Action
InstallCmd :: Action
SDistCmd :: Action
MakefileCmd :: Action
TestCmd :: Action
RegisterCmd :: Action
UnregisterCmd :: Action
HelpCmd :: Action
instance Show Action
data ConfigFlags
ConfigFlags :: ProgramConfiguration -> Maybe CompilerFlavor -> Maybe FilePath -> Maybe FilePath -> Bool -> Bool -> Bool -> Bool -> [String] -> Bool -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Verbosity -> PackageDB -> Bool -> Bool -> [(String, Bool)] -> ConfigFlags
configPrograms :: ConfigFlags -> ProgramConfiguration
configHcFlavor :: ConfigFlags -> Maybe CompilerFlavor
configHcPath :: ConfigFlags -> Maybe FilePath
configHcPkg :: ConfigFlags -> Maybe FilePath
configVanillaLib :: ConfigFlags -> Bool
configProfLib :: ConfigFlags -> Bool
configSharedLib :: ConfigFlags -> Bool
configProfExe :: ConfigFlags -> Bool
configConfigureArgs :: ConfigFlags -> [String]
configOptimization :: ConfigFlags -> Bool
configPrefix :: ConfigFlags -> Maybe FilePath
configBinDir :: ConfigFlags -> Maybe FilePath
configLibDir :: ConfigFlags -> Maybe FilePath
configLibSubDir :: ConfigFlags -> Maybe FilePath
configLibExecDir :: ConfigFlags -> Maybe FilePath
configDataDir :: ConfigFlags -> Maybe FilePath
configDataSubDir :: ConfigFlags -> Maybe FilePath
configDocDir :: ConfigFlags -> Maybe FilePath
configHtmlDir :: ConfigFlags -> Maybe FilePath
configInterfaceDir :: ConfigFlags -> Maybe FilePath
configVerbose :: ConfigFlags -> Verbosity
configPackageDB :: ConfigFlags -> PackageDB
configGHCiLib :: ConfigFlags -> Bool
configSplitObjs :: ConfigFlags -> Bool
configConfigurationsFlags :: ConfigFlags -> [(String, Bool)]
instance Show ConfigFlags
emptyConfigFlags :: ProgramConfiguration -> ConfigFlags
configureArgs :: ConfigFlags -> [String]
data CopyFlags
CopyFlags :: CopyDest -> Verbosity -> CopyFlags
copyDest :: CopyFlags -> CopyDest
copyVerbose :: CopyFlags -> Verbosity
instance Show CopyFlags
data CopyDest
NoCopyDest :: CopyDest
CopyTo :: FilePath -> CopyDest
CopyPrefix :: FilePath -> CopyDest
instance Eq CopyDest
instance Show CopyDest
emptyCopyFlags :: CopyDest -> CopyFlags
data InstallFlags
InstallFlags :: Maybe PackageDB -> Verbosity -> InstallFlags
installPackageDB :: InstallFlags -> Maybe PackageDB
installVerbose :: InstallFlags -> Verbosity
instance Show InstallFlags
emptyInstallFlags :: InstallFlags
data HaddockFlags
HaddockFlags :: Bool -> Maybe String -> Bool -> Maybe FilePath -> Bool -> Maybe FilePath -> Verbosity -> HaddockFlags
haddockHoogle :: HaddockFlags -> Bool
haddockHtmlLocation :: HaddockFlags -> Maybe String
haddockExecutables :: HaddockFlags -> Bool
haddockCss :: HaddockFlags -> Maybe FilePath
haddockHscolour :: HaddockFlags -> Bool
haddockHscolourCss :: HaddockFlags -> Maybe FilePath
haddockVerbose :: HaddockFlags -> Verbosity
instance Show HaddockFlags
emptyHaddockFlags :: HaddockFlags
data HscolourFlags
HscolourFlags :: Maybe FilePath -> Bool -> Verbosity -> HscolourFlags
hscolourCSS :: HscolourFlags -> Maybe FilePath
hscolourExecutables :: HscolourFlags -> Bool
hscolourVerbose :: HscolourFlags -> Verbosity
instance Show HscolourFlags
emptyHscolourFlags :: HscolourFlags
data BuildFlags
BuildFlags :: Verbosity -> ProgramConfiguration -> BuildFlags
buildVerbose :: BuildFlags -> Verbosity
buildPrograms :: BuildFlags -> ProgramConfiguration
instance Show BuildFlags
emptyBuildFlags :: ProgramConfiguration -> BuildFlags
data CleanFlags
CleanFlags :: Bool -> Verbosity -> CleanFlags
cleanSaveConf :: CleanFlags -> Bool
cleanVerbose :: CleanFlags -> Verbosity
instance Show CleanFlags
emptyCleanFlags :: CleanFlags
data PFEFlags
PFEFlags :: Verbosity -> PFEFlags
pfeVerbose :: PFEFlags -> Verbosity
instance Show PFEFlags
data MakefileFlags
MakefileFlags :: Verbosity -> Maybe FilePath -> MakefileFlags
makefileVerbose :: MakefileFlags -> Verbosity
makefileFile :: MakefileFlags -> Maybe FilePath
instance Show MakefileFlags
emptyMakefileFlags :: MakefileFlags
data RegisterFlags
RegisterFlags :: Maybe PackageDB -> Bool -> Bool -> Maybe FilePath -> Bool -> Verbosity -> RegisterFlags
regPackageDB :: RegisterFlags -> Maybe PackageDB
regGenScript :: RegisterFlags -> Bool
regGenPkgConf :: RegisterFlags -> Bool
regPkgConfFile :: RegisterFlags -> Maybe FilePath
regInPlace :: RegisterFlags -> Bool
regVerbose :: RegisterFlags -> Verbosity
instance Show RegisterFlags
emptyRegisterFlags :: RegisterFlags
data SDistFlags
SDistFlags :: Bool -> Verbosity -> SDistFlags
sDistSnapshot :: SDistFlags -> Bool
sDistVerbose :: SDistFlags -> Verbosity
instance Show SDistFlags
parseGlobalArgs :: ProgramConfiguration -> [String] -> IO (Action, [String])
parseConfigureArgs :: ProgramConfiguration -> ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
parseBuildArgs :: ProgramConfiguration -> BuildFlags -> [String] -> [OptDescr a] -> IO (BuildFlags, [a], [String])
parseCleanArgs :: CleanFlags -> [String] -> [OptDescr a] -> IO (CleanFlags, [a], [String])
parseMakefileArgs :: MakefileFlags -> [String] -> [OptDescr a] -> IO (MakefileFlags, [a], [String])
parseHscolourArgs :: HscolourFlags -> [String] -> [OptDescr a] -> IO (HscolourFlags, [a], [String])
parseHaddockArgs :: HaddockFlags -> [String] -> [OptDescr a] -> IO (HaddockFlags, [a], [String])
parseProgramaticaArgs :: [String] -> [OptDescr a] -> IO (PFEFlags, [a], [String])
parseTestArgs :: [String] -> [OptDescr a] -> IO (Verbosity, [a], [String])
parseInstallArgs :: InstallFlags -> [String] -> [OptDescr a] -> IO (InstallFlags, [a], [String])
parseSDistArgs :: [String] -> [OptDescr a] -> IO (SDistFlags, [a], [String])
parseRegisterArgs :: RegisterFlags -> [String] -> [OptDescr a] -> IO (RegisterFlags, [a], [String])
parseUnregisterArgs :: RegisterFlags -> [String] -> [OptDescr a] -> IO (RegisterFlags, [a], [String])
parseCopyArgs :: CopyFlags -> [String] -> [OptDescr a] -> IO (CopyFlags, [a], [String])
reqPathArg :: (FilePath -> a) -> ArgDescr a
reqDirArg :: (FilePath -> a) -> ArgDescr a

module Distribution.Make
data License
GPL :: License
LGPL :: License
BSD3 :: License
BSD4 :: License
PublicDomain :: License
AllRightsReserved :: License
OtherLicense :: License
instance Eq License
instance Read License
instance Show License
defaultMain :: IO ()
defaultMainArgs :: [String] -> IO ()
defaultMainNoRead :: PackageDescription -> IO ()

module Distribution.Setup

module Distribution.Simple.InstallDirs
data InstallDirs dir
InstallDirs :: dir -> dir -> dir -> dir -> dir -> dir -> dir -> dir -> dir -> dir -> dir -> InstallDirs dir
prefix :: InstallDirs dir -> dir
bindir :: InstallDirs dir -> dir
libdir :: InstallDirs dir -> dir
dynlibdir :: InstallDirs dir -> dir
libexecdir :: InstallDirs dir -> dir
progdir :: InstallDirs dir -> dir
includedir :: InstallDirs dir -> dir
datadir :: InstallDirs dir -> dir
docdir :: InstallDirs dir -> dir
htmldir :: InstallDirs dir -> dir
interfacedir :: InstallDirs dir -> dir
instance Read dir => Read (InstallDirs dir)
instance Show dir => Show (InstallDirs dir)
haddockdir :: InstallDirs FilePath -> PackageDescription -> FilePath
haddockinterfacedir :: InstallDirs FilePath -> PackageDescription -> FilePath
data InstallDirTemplates
InstallDirTemplates :: PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> PathTemplate -> InstallDirTemplates
prefixDirTemplate :: InstallDirTemplates -> PathTemplate
binDirTemplate :: InstallDirTemplates -> PathTemplate
libDirTemplate :: InstallDirTemplates -> PathTemplate
libSubdirTemplate :: InstallDirTemplates -> PathTemplate
libexecDirTemplate :: InstallDirTemplates -> PathTemplate
progDirTemplate :: InstallDirTemplates -> PathTemplate
includeDirTemplate :: InstallDirTemplates -> PathTemplate
dataDirTemplate :: InstallDirTemplates -> PathTemplate
dataSubdirTemplate :: InstallDirTemplates -> PathTemplate
docDirTemplate :: InstallDirTemplates -> PathTemplate
htmlDirTemplate :: InstallDirTemplates -> PathTemplate
interfaceDirTemplate :: InstallDirTemplates -> PathTemplate
instance Read InstallDirTemplates
instance Show InstallDirTemplates
defaultInstallDirs :: CompilerFlavor -> Bool -> IO InstallDirTemplates
absoluteInstallDirs :: PackageIdentifier -> PackageIdentifier -> CopyDest -> InstallDirTemplates -> InstallDirs FilePath
prefixRelativeInstallDirs :: PackageIdentifier -> PackageIdentifier -> InstallDirTemplates -> InstallDirs (Maybe FilePath)
data PathTemplate
instance Read PathTemplate
instance Show PathTemplate
data PathTemplateVariable
PrefixVar :: PathTemplateVariable
BinDirVar :: PathTemplateVariable
LibDirVar :: PathTemplateVariable
LibSubdirVar :: PathTemplateVariable
DataDirVar :: PathTemplateVariable
DataSubdirVar :: PathTemplateVariable
DocDirVar :: PathTemplateVariable
PkgNameVar :: PathTemplateVariable
PkgVerVar :: PathTemplateVariable
PkgIdVar :: PathTemplateVariable
CompilerVar :: PathTemplateVariable
instance Eq PathTemplateVariable
instance Read PathTemplateVariable
instance Show PathTemplateVariable
toPathTemplate :: FilePath -> PathTemplate
fromPathTemplate :: PathTemplate -> FilePath
substPathTemplate :: [(PathTemplateVariable, PathTemplate)] -> PathTemplate -> PathTemplate
initialPathTemplateEnv :: PackageIdentifier -> PackageIdentifier -> [(PathTemplateVariable, PathTemplate)]

module Distribution.Simple.LocalBuildInfo
data LocalBuildInfo
LocalBuildInfo :: InstallDirTemplates -> Compiler -> FilePath -> FilePath -> [PackageIdentifier] -> Maybe FilePath -> PackageDescription -> ProgramConfiguration -> PackageDB -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> LocalBuildInfo
installDirTemplates :: LocalBuildInfo -> InstallDirTemplates
compiler :: LocalBuildInfo -> Compiler
buildDir :: LocalBuildInfo -> FilePath
scratchDir :: LocalBuildInfo -> FilePath
packageDeps :: LocalBuildInfo -> [PackageIdentifier]
pkgDescrFile :: LocalBuildInfo -> Maybe FilePath
localPkgDescr :: LocalBuildInfo -> PackageDescription
withPrograms :: LocalBuildInfo -> ProgramConfiguration
withPackageDB :: LocalBuildInfo -> PackageDB
withVanillaLib :: LocalBuildInfo -> Bool
withProfLib :: LocalBuildInfo -> Bool
withSharedLib :: LocalBuildInfo -> Bool
withProfExe :: LocalBuildInfo -> Bool
withOptimization :: LocalBuildInfo -> Bool
withGHCiLib :: LocalBuildInfo -> Bool
splitObjs :: LocalBuildInfo -> Bool
instance Read LocalBuildInfo
instance Show LocalBuildInfo
absoluteInstallDirs :: PackageDescription -> LocalBuildInfo -> CopyDest -> InstallDirs FilePath
prefixRelativeInstallDirs :: PackageDescription -> LocalBuildInfo -> InstallDirs (Maybe FilePath)
mkLibDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkBinDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkLibexecDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
mkDataDir :: PackageDescription -> LocalBuildInfo -> CopyDest -> FilePath
distPref :: FilePath
srcPref :: FilePath
hscolourPref :: PackageDescription -> FilePath
haddockPref :: PackageDescription -> FilePath
autogenModulesDir :: LocalBuildInfo -> String

module Distribution.Simple.GHC.PackageConfig
data GHCPackageConfig
GHCPackage :: String -> Bool -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> GHCPackageConfig
name :: GHCPackageConfig -> String
auto :: GHCPackageConfig -> Bool
import_dirs :: GHCPackageConfig -> [String]
source_dirs :: GHCPackageConfig -> [String]
library_dirs :: GHCPackageConfig -> [String]
hs_libraries :: GHCPackageConfig -> [String]
extra_libraries :: GHCPackageConfig -> [String]
include_dirs :: GHCPackageConfig -> [String]
c_includes :: GHCPackageConfig -> [String]
package_deps :: GHCPackageConfig -> [String]
extra_ghc_opts :: GHCPackageConfig -> [String]
extra_cc_opts :: GHCPackageConfig -> [String]
extra_ld_opts :: GHCPackageConfig -> [String]
framework_dirs :: GHCPackageConfig -> [String]
extra_frameworks :: GHCPackageConfig -> [String]
mkGHCPackageConfig :: PackageDescription -> LocalBuildInfo -> GHCPackageConfig
defaultGHCPackageConfig :: GHCPackageConfig
showGHCPackageConfig :: GHCPackageConfig -> String
localPackageConfig :: IO FilePath
maybeCreateLocalPackageConfig :: IO Bool
canWriteLocalPackageConfig :: IO Bool
canReadLocalPackageConfig :: IO Bool

module Distribution.Simple.GHC
configure :: Verbosity -> Maybe FilePath -> Maybe FilePath -> ProgramConfiguration -> IO (Compiler, ProgramConfiguration)
getInstalledPackages :: Verbosity -> PackageDB -> ProgramConfiguration -> IO [PackageIdentifier]
build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
makefile :: PackageDescription -> LocalBuildInfo -> MakefileFlags -> IO ()
installLib :: Verbosity -> LocalBuildInfo -> FilePath -> FilePath -> FilePath -> PackageDescription -> IO ()
installExe :: Verbosity -> FilePath -> FilePath -> PackageDescription -> IO ()
ghcVerbosityOptions :: Verbosity -> [String]

module Distribution.Simple.JHC
configure :: Verbosity -> Maybe FilePath -> Maybe FilePath -> ProgramConfiguration -> IO (Compiler, ProgramConfiguration)
getInstalledPackages :: Verbosity -> PackageDB -> ProgramConfiguration -> IO [PackageIdentifier]
build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
installLib :: Verbosity -> FilePath -> FilePath -> PackageDescription -> Library -> IO ()
installExe :: Verbosity -> FilePath -> FilePath -> PackageDescription -> Executable -> IO ()

module Distribution.Simple.NHC
configure :: Verbosity -> Maybe FilePath -> Maybe FilePath -> ProgramConfiguration -> IO (Compiler, ProgramConfiguration)
build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()

module Distribution.Simple.PreProcess
preprocessSources :: PackageDescription -> LocalBuildInfo -> Bool -> Verbosity -> [PPSuffixHandler] -> IO ()
knownSuffixHandlers :: [PPSuffixHandler]
ppSuffixes :: [PPSuffixHandler] -> [String]
type PPSuffixHandler = (String, BuildInfo -> LocalBuildInfo -> PreProcessor)
data PreProcessor
PreProcessor :: Bool -> ((FilePath, FilePath) -> (FilePath, FilePath) -> Verbosity -> IO ()) -> PreProcessor
platformIndependent :: PreProcessor -> Bool
runPreProcessor :: PreProcessor -> (FilePath, FilePath) -> (FilePath, FilePath) -> Verbosity -> IO ()
mkSimplePreProcessor :: (FilePath -> FilePath -> Verbosity -> IO ()) -> (FilePath, FilePath) -> (FilePath, FilePath) -> Verbosity -> IO ()
runSimplePreProcessor :: PreProcessor -> FilePath -> FilePath -> Verbosity -> IO ()
removePreprocessed :: [FilePath] -> [String] -> [String] -> IO ()
removePreprocessedPackage :: PackageDescription -> FilePath -> [String] -> IO ()
ppCpp :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppCpp' :: [String] -> BuildInfo -> LocalBuildInfo -> PreProcessor
ppGreenCard :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppC2hs :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppHsc2hs :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppHappy :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppAlex :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppUnlit :: PreProcessor

module Distribution.Simple.Hugs
configure :: Verbosity -> Maybe FilePath -> Maybe FilePath -> ProgramConfiguration -> IO (Compiler, ProgramConfiguration)
build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
install :: Verbosity -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> PackageDescription -> IO ()

module Distribution.Simple.Install
install :: PackageDescription -> LocalBuildInfo -> CopyFlags -> IO ()

module Distribution.Simple.Register
register :: PackageDescription -> LocalBuildInfo -> RegisterFlags -> IO ()
unregister :: PackageDescription -> LocalBuildInfo -> RegisterFlags -> IO ()
writeInstalledConfig :: PackageDescription -> LocalBuildInfo -> Bool -> Maybe FilePath -> IO ()
removeInstalledConfig :: IO ()
removeRegScripts :: IO ()

module Distribution.Simple.Configure
configure :: (Either GenericPackageDescription PackageDescription, HookedBuildInfo) -> ConfigFlags -> IO LocalBuildInfo
writePersistBuildConfig :: LocalBuildInfo -> IO ()
getPersistBuildConfig :: IO LocalBuildInfo
checkPersistBuildConfig :: FilePath -> IO ()
maybeGetPersistBuildConfig :: IO (Maybe LocalBuildInfo)
localBuildInfoFile :: FilePath
getInstalledPackages :: Verbosity -> Compiler -> PackageDB -> ProgramConfiguration -> IO (Maybe [PackageIdentifier])
configDependency :: Verbosity -> [PackageIdentifier] -> Dependency -> IO PackageIdentifier
configCompiler :: Maybe CompilerFlavor -> Maybe FilePath -> Maybe FilePath -> ProgramConfiguration -> Verbosity -> IO (Compiler, ProgramConfiguration)
configCompilerAux :: ConfigFlags -> IO (Compiler, ProgramConfiguration)

module Distribution.Simple.Build
build :: PackageDescription -> LocalBuildInfo -> BuildFlags -> [PPSuffixHandler] -> IO ()
makefile :: PackageDescription -> LocalBuildInfo -> MakefileFlags -> [PPSuffixHandler] -> IO ()
initialBuildSteps :: PackageDescription -> LocalBuildInfo -> Verbosity -> [PPSuffixHandler] -> IO ()

module Distribution.Simple.Haddock
haddock :: PackageDescription -> LocalBuildInfo -> [PPSuffixHandler] -> HaddockFlags -> IO ()
hscolour :: PackageDescription -> LocalBuildInfo -> [PPSuffixHandler] -> HscolourFlags -> IO ()

module Distribution.Simple.SrcDist
sdist :: PackageDescription -> Maybe LocalBuildInfo -> SDistFlags -> FilePath -> FilePath -> [PPSuffixHandler] -> IO ()
createArchive :: PackageDescription -> Verbosity -> Maybe LocalBuildInfo -> FilePath -> FilePath -> IO FilePath
prepareTree :: PackageDescription -> Verbosity -> Maybe LocalBuildInfo -> Bool -> FilePath -> [PPSuffixHandler] -> Int -> IO FilePath
tarBallName :: PackageDescription -> FilePath
copyFileTo :: Verbosity -> FilePath -> FilePath -> IO ()

module Distribution.Simple
defaultMain :: IO ()
defaultMainNoRead :: PackageDescription -> IO ()
defaultMainArgs :: [String] -> IO ()
data UserHooks
UserHooks :: (Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ()) -> IO (Maybe PackageDescription) -> [PPSuffixHandler] -> [Program] -> (Args -> ConfigFlags -> IO HookedBuildInfo) -> ((Either GenericPackageDescription PackageDescription, HookedBuildInfo) -> ConfigFlags -> IO LocalBuildInfo) -> (Args -> ConfigFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> BuildFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> BuildFlags -> IO ()) -> (Args -> BuildFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> MakefileFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> MakefileFlags -> IO ()) -> (Args -> MakefileFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> CleanFlags -> IO HookedBuildInfo) -> (PackageDescription -> Maybe LocalBuildInfo -> UserHooks -> CleanFlags -> IO ()) -> (Args -> CleanFlags -> PackageDescription -> Maybe LocalBuildInfo -> IO ()) -> (Args -> CopyFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> CopyFlags -> IO ()) -> (Args -> CopyFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> InstallFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> InstallFlags -> IO ()) -> (Args -> InstallFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> SDistFlags -> IO HookedBuildInfo) -> (PackageDescription -> Maybe LocalBuildInfo -> UserHooks -> SDistFlags -> IO ()) -> (Args -> SDistFlags -> PackageDescription -> Maybe LocalBuildInfo -> IO ()) -> (Args -> RegisterFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> RegisterFlags -> IO ()) -> (Args -> RegisterFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> RegisterFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> RegisterFlags -> IO ()) -> (Args -> RegisterFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> HscolourFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> HscolourFlags -> IO ()) -> (Args -> HscolourFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> HaddockFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> HaddockFlags -> IO ()) -> (Args -> HaddockFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> (Args -> PFEFlags -> IO HookedBuildInfo) -> (PackageDescription -> LocalBuildInfo -> UserHooks -> PFEFlags -> IO ()) -> (Args -> PFEFlags -> PackageDescription -> LocalBuildInfo -> IO ()) -> UserHooks
runTests :: UserHooks -> Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ()
readDesc :: UserHooks -> IO (Maybe PackageDescription)
hookedPreProcessors :: UserHooks -> [PPSuffixHandler]
hookedPrograms :: UserHooks -> [Program]
preConf :: UserHooks -> Args -> ConfigFlags -> IO HookedBuildInfo
confHook :: UserHooks -> (Either GenericPackageDescription PackageDescription, HookedBuildInfo) -> ConfigFlags -> IO LocalBuildInfo
postConf :: UserHooks -> Args -> ConfigFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preBuild :: UserHooks -> Args -> BuildFlags -> IO HookedBuildInfo
buildHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> BuildFlags -> IO ()
postBuild :: UserHooks -> Args -> BuildFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preMakefile :: UserHooks -> Args -> MakefileFlags -> IO HookedBuildInfo
makefileHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> MakefileFlags -> IO ()
postMakefile :: UserHooks -> Args -> MakefileFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preClean :: UserHooks -> Args -> CleanFlags -> IO HookedBuildInfo
cleanHook :: UserHooks -> PackageDescription -> Maybe LocalBuildInfo -> UserHooks -> CleanFlags -> IO ()
postClean :: UserHooks -> Args -> CleanFlags -> PackageDescription -> Maybe LocalBuildInfo -> IO ()
preCopy :: UserHooks -> Args -> CopyFlags -> IO HookedBuildInfo
copyHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> CopyFlags -> IO ()
postCopy :: UserHooks -> Args -> CopyFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preInst :: UserHooks -> Args -> InstallFlags -> IO HookedBuildInfo
instHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> InstallFlags -> IO ()
postInst :: UserHooks -> Args -> InstallFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preSDist :: UserHooks -> Args -> SDistFlags -> IO HookedBuildInfo
sDistHook :: UserHooks -> PackageDescription -> Maybe LocalBuildInfo -> UserHooks -> SDistFlags -> IO ()
postSDist :: UserHooks -> Args -> SDistFlags -> PackageDescription -> Maybe LocalBuildInfo -> IO ()
preReg :: UserHooks -> Args -> RegisterFlags -> IO HookedBuildInfo
regHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> RegisterFlags -> IO ()
postReg :: UserHooks -> Args -> RegisterFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preUnreg :: UserHooks -> Args -> RegisterFlags -> IO HookedBuildInfo
unregHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> RegisterFlags -> IO ()
postUnreg :: UserHooks -> Args -> RegisterFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preHscolour :: UserHooks -> Args -> HscolourFlags -> IO HookedBuildInfo
hscolourHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> HscolourFlags -> IO ()
postHscolour :: UserHooks -> Args -> HscolourFlags -> PackageDescription -> LocalBuildInfo -> IO ()
preHaddock :: UserHooks -> Args -> HaddockFlags -> IO HookedBuildInfo
haddockHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> HaddockFlags -> IO ()
postHaddock :: UserHooks -> Args -> HaddockFlags -> PackageDescription -> LocalBuildInfo -> IO ()
prePFE :: UserHooks -> Args -> PFEFlags -> IO HookedBuildInfo
pfeHook :: UserHooks -> PackageDescription -> LocalBuildInfo -> UserHooks -> PFEFlags -> IO ()
postPFE :: UserHooks -> Args -> PFEFlags -> PackageDescription -> LocalBuildInfo -> IO ()
type Args = [String]
defaultMainWithHooks :: UserHooks -> IO ()
defaultMainWithHooksArgs :: UserHooks -> [String] -> IO ()
simpleUserHooks :: UserHooks
defaultUserHooks :: UserHooks
emptyUserHooks :: UserHooks
defaultHookedPackageDesc :: IO (Maybe FilePath)

module Distribution.Simple.SetupWrapper
setupWrapper :: [String] -> Maybe FilePath -> IO ()
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Test.HUnit.Terminal
terminalAppearance :: String -> String

module Test.HUnit.Lang
type Assertion = IO ()
assertFailure :: String -> Assertion
performTestCase :: Assertion -> IO (Maybe (Bool, String))

module Test.HUnit.Base
type Assertion = IO ()
assertFailure :: String -> Assertion
assertString :: String -> Assertion
assertBool :: String -> Bool -> Assertion
assertEqual :: (Eq a, Show a) => String -> a -> a -> Assertion
class Assertable t
assert :: Assertable t => t -> Assertion
instance Assertable Bool
instance Assertable ()
instance Assertable t => Assertable (IO t)
instance ListAssertable t => Assertable [t]
class ListAssertable t
listAssert :: ListAssertable t => [t] -> Assertion
instance ListAssertable Char
type AssertionPredicate = IO Bool
class AssertionPredicable t
assertionPredicate :: AssertionPredicable t => t -> AssertionPredicate
instance AssertionPredicable Bool
instance AssertionPredicable t => AssertionPredicable (IO t)
(@?) :: AssertionPredicable t => t -> String -> Assertion
(@=?) :: (Eq a, Show a) => a -> a -> Assertion
(@?=) :: (Eq a, Show a) => a -> a -> Assertion
data Test
TestCase :: Assertion -> Test
TestList :: [Test] -> Test
TestLabel :: String -> Test -> Test
instance Show Test
instance Testable Test
data Node
ListItem :: Int -> Node
Label :: String -> Node
instance Eq Node
instance Read Node
instance Show Node
type Path = [Node]
testCaseCount :: Test -> Int
class Testable t
test :: Testable t => t -> Test
instance Testable Test
instance Assertable t => Testable (IO t)
instance Testable t => Testable [t]
(~?) :: AssertionPredicable t => t -> String -> Test
(~=?) :: (Eq a, Show a) => a -> a -> Test
(~?=) :: (Eq a, Show a) => a -> a -> Test
(~:) :: Testable t => String -> t -> Test
data Counts
Counts :: Int -> Int -> Int -> Int -> Counts
cases :: Counts -> Int
tried :: Counts -> Int
errors :: Counts -> Int
failures :: Counts -> Int
instance Eq Counts
instance Read Counts
instance Show Counts
data State
State :: Path -> Counts -> State
path :: State -> Path
counts :: State -> Counts
instance Eq State
instance Read State
instance Show State
type ReportStart us = State -> us -> IO us
type ReportProblem us = String -> State -> us -> IO us
testCasePaths :: Test -> [Path]
performTest :: ReportStart us -> ReportProblem us -> ReportProblem us -> us -> Test -> IO (Counts, us)

module Test.HUnit.Text
data PutText st
PutText :: (String -> Bool -> st -> IO st) -> st -> PutText st
putTextToHandle :: Handle -> Bool -> PutText Int
putTextToShowS :: PutText ShowS
runTestText :: PutText st -> Test -> IO (Counts, st)
showPath :: Path -> String
showCounts :: Counts -> String
runTestTT :: Test -> IO Counts

module Test.HUnit
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Test.QuickCheck
quickCheck :: Testable a => a -> IO ()
verboseCheck :: Testable a => a -> IO ()
test :: Testable a => a -> IO ()
data Config
Config :: Int -> Int -> (Int -> Int) -> (Int -> [String] -> String) -> Config
configMaxTest :: Config -> Int
configMaxFail :: Config -> Int
configSize :: Config -> Int -> Int
configEvery :: Config -> Int -> [String] -> String
defaultConfig :: Config
check :: Testable a => Config -> a -> IO ()
forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
(==>) :: Testable a => Bool -> a -> Property
label :: Testable a => String -> a -> Property
collect :: (Show a, Testable b) => a -> b -> Property
classify :: Testable a => Bool -> String -> a -> Property
trivial :: Testable a => Bool -> a -> Property
data Gen a
instance Functor Gen
instance Monad Gen
elements :: [a] -> Gen a
two :: Monad m => m a -> m (a, a)
three :: Monad m => m a -> m (a, a, a)
four :: Monad m => m a -> m (a, a, a, a)
sized :: (Int -> Gen a) -> Gen a
resize :: Int -> Gen a -> Gen a
choose :: Random a => (a, a) -> Gen a
oneof :: [Gen a] -> Gen a
frequency :: [(Int, Gen a)] -> Gen a
vector :: Arbitrary a => Int -> Gen [a]
class Arbitrary a
arbitrary :: Arbitrary a => Gen a
coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
instance Arbitrary Bool
instance Arbitrary Double
instance Arbitrary Float
instance Arbitrary Int
instance Arbitrary Integer
instance Arbitrary ()
instance (Arbitrary a, Arbitrary b) => Arbitrary (a, b)
instance (Arbitrary a, Arbitrary b, Arbitrary c) => Arbitrary (a, b, c)
instance (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => Arbitrary (a, b, c, d)
instance (Arbitrary a, Arbitrary b) => Arbitrary (a -> b)
instance Arbitrary a => Arbitrary (Maybe a)
instance Arbitrary (Poly a)
instance Arbitrary a => Arbitrary [a]
instance (Arbitrary a, Arbitrary b) => Arbitrary (Either a b)
rand :: Gen StdGen
promote :: (a -> Gen b) -> Gen (a -> b)
variant :: Int -> Gen a -> Gen a
class Testable a
property :: Testable a => a -> Property
instance Testable Bool
instance Testable Property
instance Testable Result
instance Testable ()
instance (Arbitrary a, Show a, Testable b) => Testable (a -> b)
data Property
instance Testable Property
data Result
Result :: Maybe Bool -> [String] -> [String] -> Result
ok :: Result -> Maybe Bool
stamp :: Result -> [String]
arguments :: Result -> [String]
instance Testable Result
generate :: Int -> StdGen -> Gen a -> a
evaluate :: Testable a => a -> Gen Result

module Test.QuickCheck.Batch
run :: Testable a => a -> TestOptions -> IO TestResult
runTests :: String -> TestOptions -> [TestOptions -> IO TestResult] -> IO ()
defOpt :: TestOptions
data TestOptions
TestOptions :: Int -> Int -> Bool -> TestOptions
no_of_tests :: TestOptions -> Int
length_of_tests :: TestOptions -> Int
debug_tests :: TestOptions -> Bool
data TestResult
TestOk :: String -> Int -> [[String]] -> TestResult
TestExausted :: String -> Int -> [[String]] -> TestResult
TestFailed :: [String] -> Int -> TestResult
TestAborted :: Exception -> TestResult
isBottom :: a -> Bool
bottom :: a

module Test.QuickCheck.Utils
isAssociativeBy :: (Show a, Testable prop) => (a -> a -> prop) -> Gen a -> (a -> a -> a) -> Property
isAssociative :: (Arbitrary a, Show a, Eq a) => (a -> a -> a) -> Property
isCommutableBy :: (Show a, Testable prop) => (b -> b -> prop) -> Gen a -> (a -> a -> b) -> Property
isCommutable :: (Arbitrary a, Show a, Eq b) => (a -> a -> b) -> Property
isTotalOrder :: (Arbitrary a, Show a, Ord a) => a -> a -> Property

module Test.QuickCheck.Poly
type ALPHA = Poly ALPHA_
type BETA = Poly BETA_
type GAMMA = Poly GAMMA_
type OrdALPHA = Poly OrdALPHA_
type OrdBETA = Poly OrdBETA_
type OrdGAMMA = Poly OrdGAMMA_

module Debug.QuickCheck.Utils

module Debug.QuickCheck.Poly

module Debug.QuickCheck.Batch

module Debug.QuickCheck
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Data.Array

module Data.Array.IArray
class IArray a e
bounds :: (IArray a e, Ix i) => a i e -> (i, i)
instance IArray Array e
instance IArray UArray Bool
instance IArray UArray Char
instance IArray UArray Double
instance IArray UArray Float
instance IArray UArray Int
instance IArray UArray Int16
instance IArray UArray Int32
instance IArray UArray Int64
instance IArray UArray Int8
instance IArray UArray Word
instance IArray UArray Word16
instance IArray UArray Word32
instance IArray UArray Word64
instance IArray UArray Word8
instance IArray UArray (FunPtr a)
instance IArray UArray (Ptr a)
instance IArray UArray (StablePtr a)
instance IArray (IOToDiffArray IOArray) e
instance IArray (IOToDiffArray IOUArray) Char
instance IArray (IOToDiffArray IOUArray) Double
instance IArray (IOToDiffArray IOUArray) Float
instance IArray (IOToDiffArray IOUArray) Int
instance IArray (IOToDiffArray IOUArray) Int16
instance IArray (IOToDiffArray IOUArray) Int32
instance IArray (IOToDiffArray IOUArray) Int64
instance IArray (IOToDiffArray IOUArray) Int8
instance IArray (IOToDiffArray IOUArray) Word
instance IArray (IOToDiffArray IOUArray) Word16
instance IArray (IOToDiffArray IOUArray) Word32
instance IArray (IOToDiffArray IOUArray) Word64
instance IArray (IOToDiffArray IOUArray) Word8
instance IArray (IOToDiffArray IOUArray) (FunPtr a)
instance IArray (IOToDiffArray IOUArray) (Ptr a)
instance IArray (IOToDiffArray IOUArray) (StablePtr a)
array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
(!) :: (IArray a e, Ix i) => a i e -> i -> e
bounds :: (IArray a e, Ix i) => a i e -> (i, i)
indices :: (IArray a e, Ix i) => a i e -> [i]
elems :: (IArray a e, Ix i) => a i e -> [e]
assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e

module Data.Array.MArray
class Monad m => MArray a e m
getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
instance MArray IOArray e IO
instance MArray IOUArray Bool IO
instance MArray IOUArray Char IO
instance MArray IOUArray Double IO
instance MArray IOUArray Float IO
instance MArray IOUArray Int IO
instance MArray IOUArray Int16 IO
instance MArray IOUArray Int32 IO
instance MArray IOUArray Int64 IO
instance MArray IOUArray Int8 IO
instance MArray IOUArray Word IO
instance MArray IOUArray Word16 IO
instance MArray IOUArray Word32 IO
instance MArray IOUArray Word64 IO
instance MArray IOUArray Word8 IO
instance Storable e => MArray StorableArray e IO
instance MArray IOUArray (FunPtr a) IO
instance MArray IOUArray (Ptr a) IO
instance MArray IOUArray (StablePtr a) IO
instance MArray (STArray s) e (ST s)
instance MArray (STArray s) e (ST s)
instance MArray (STUArray s) Bool (ST s)
instance MArray (STUArray s) Char (ST s)
instance MArray (STUArray s) Double (ST s)
instance MArray (STUArray s) Float (ST s)
instance MArray (STUArray s) Int (ST s)
instance MArray (STUArray s) Int16 (ST s)
instance MArray (STUArray s) Int32 (ST s)
instance MArray (STUArray s) Int64 (ST s)
instance MArray (STUArray s) Int8 (ST s)
instance MArray (STUArray s) Word (ST s)
instance MArray (STUArray s) Word16 (ST s)
instance MArray (STUArray s) Word32 (ST s)
instance MArray (STUArray s) Word64 (ST s)
instance MArray (STUArray s) Word8 (ST s)
instance MArray (STUArray s) (FunPtr a) (ST s)
instance MArray (STUArray s) (Ptr a) (ST s)
instance MArray (STUArray s) (StablePtr a) (ST s)
newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
getElems :: (MArray a e m, Ix i) => a i e -> m [e]
getAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]
freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)

module Data.Array.ST
runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
data STUArray s i a
instance Typeable3 STUArray
instance MArray (STUArray s) Bool (ST s)
instance MArray (STUArray s) Char (ST s)
instance MArray (STUArray s) Double (ST s)
instance MArray (STUArray s) Float (ST s)
instance MArray (STUArray s) Int (ST s)
instance MArray (STUArray s) Int16 (ST s)
instance MArray (STUArray s) Int32 (ST s)
instance MArray (STUArray s) Int64 (ST s)
instance MArray (STUArray s) Int8 (ST s)
instance MArray (STUArray s) Word (ST s)
instance MArray (STUArray s) Word16 (ST s)
instance MArray (STUArray s) Word32 (ST s)
instance MArray (STUArray s) Word64 (ST s)
instance MArray (STUArray s) Word8 (ST s)
instance MArray (STUArray s) (FunPtr a) (ST s)
instance MArray (STUArray s) (Ptr a) (ST s)
instance MArray (STUArray s) (StablePtr a) (ST s)
instance Eq (STUArray s i e)
runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)

module Data.Array.Storable
data StorableArray i e
instance Storable e => MArray StorableArray e IO
withStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a
touchStorableArray :: StorableArray i e -> IO ()
unsafeForeignPtrToStorableArray :: Ix i => ForeignPtr e -> (i, i) -> IO (StorableArray i e)

module Data.Array.Unboxed
data UArray i e
instance Typeable2 UArray
instance IArray UArray Bool
instance IArray UArray Char
instance IArray UArray Double
instance IArray UArray Float
instance IArray UArray Int
instance IArray UArray Int16
instance IArray UArray Int32
instance IArray UArray Int64
instance IArray UArray Int8
instance IArray UArray Word
instance IArray UArray Word16
instance IArray UArray Word32
instance IArray UArray Word64
instance IArray UArray Word8
instance IArray UArray (FunPtr a)
instance IArray UArray (Ptr a)
instance IArray UArray (StablePtr a)
instance (Ix ix, Eq e, IArray UArray e) => Eq (UArray ix e)
instance (Ix ix, Ord e, IArray UArray e) => Ord (UArray ix e)
instance (Ix ix, Show ix, Show e, IArray UArray e) => Show (UArray ix e)

module Data.Array.IO
data IOUArray i e
instance Typeable2 IOUArray
instance MArray IOUArray Bool IO
instance MArray IOUArray Char IO
instance MArray IOUArray Double IO
instance MArray IOUArray Float IO
instance MArray IOUArray Int IO
instance MArray IOUArray Int16 IO
instance MArray IOUArray Int32 IO
instance MArray IOUArray Int64 IO
instance MArray IOUArray Int8 IO
instance MArray IOUArray Word IO
instance MArray IOUArray Word16 IO
instance MArray IOUArray Word32 IO
instance MArray IOUArray Word64 IO
instance MArray IOUArray Word8 IO
instance MArray IOUArray (FunPtr a) IO
instance MArray IOUArray (Ptr a) IO
instance MArray IOUArray (StablePtr a) IO
instance IArray (IOToDiffArray IOUArray) Char
instance IArray (IOToDiffArray IOUArray) Double
instance IArray (IOToDiffArray IOUArray) Float
instance IArray (IOToDiffArray IOUArray) Int
instance IArray (IOToDiffArray IOUArray) Int16
instance IArray (IOToDiffArray IOUArray) Int32
instance IArray (IOToDiffArray IOUArray) Int64
instance IArray (IOToDiffArray IOUArray) Int8
instance IArray (IOToDiffArray IOUArray) Word
instance IArray (IOToDiffArray IOUArray) Word16
instance IArray (IOToDiffArray IOUArray) Word32
instance IArray (IOToDiffArray IOUArray) Word64
instance IArray (IOToDiffArray IOUArray) Word8
instance IArray (IOToDiffArray IOUArray) (FunPtr a)
instance IArray (IOToDiffArray IOUArray) (Ptr a)
instance IArray (IOToDiffArray IOUArray) (StablePtr a)
instance Eq (IOUArray i e)
castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
hGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int
hPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()

module Data.Array.Diff
data IOToDiffArray a i e
instance IArray (IOToDiffArray IOArray) e
instance IArray (IOToDiffArray IOUArray) Char
instance IArray (IOToDiffArray IOUArray) Double
instance IArray (IOToDiffArray IOUArray) Float
instance IArray (IOToDiffArray IOUArray) Int
instance IArray (IOToDiffArray IOUArray) Int16
instance IArray (IOToDiffArray IOUArray) Int32
instance IArray (IOToDiffArray IOUArray) Int64
instance IArray (IOToDiffArray IOUArray) Int8
instance IArray (IOToDiffArray IOUArray) Word
instance IArray (IOToDiffArray IOUArray) Word16
instance IArray (IOToDiffArray IOUArray) Word32
instance IArray (IOToDiffArray IOUArray) Word64
instance IArray (IOToDiffArray IOUArray) Word8
instance IArray (IOToDiffArray IOUArray) (FunPtr a)
instance IArray (IOToDiffArray IOUArray) (Ptr a)
instance IArray (IOToDiffArray IOUArray) (StablePtr a)
type DiffArray = IOToDiffArray IOArray
instance (Ix ix, Show ix, Show e) => Show (DiffArray ix e)
type DiffUArray = IOToDiffArray IOUArray
instance (Ix ix, Show ix) => Show (DiffUArray ix Char)
instance (Ix ix, Show ix) => Show (DiffUArray ix Double)
instance (Ix ix, Show ix) => Show (DiffUArray ix Float)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int16)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int32)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int64)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int8)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word16)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word32)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word64)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word8)
newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
readDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> Int -> IO e
replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Control.Arrow.Transformer
class (Arrow a, Arrow (f a)) => ArrowTransformer f a
lift :: ArrowTransformer f a => a b c -> f a b c
instance Arrow a => ArrowTransformer Automaton a
instance Arrow a => ArrowTransformer StreamArrow a
instance ArrowChoice a => ArrowTransformer (ErrorArrow ex) a
instance Arrow a => ArrowTransformer (ReaderArrow r) a
instance Arrow a => ArrowTransformer (StateArrow s) a
instance (Arrow a, Applicative f) => ArrowTransformer (StaticArrow f) a
instance (Arrow a, Monoid w) => ArrowTransformer (WriterArrow w) a

module Control.Arrow.Operations
class Arrow a => ArrowState s a
fetch :: ArrowState s a => a e s
store :: ArrowState s a => a s ()
instance ArrowState s a => ArrowState s (Automaton a)
instance ArrowState s a => ArrowState s (StreamArrow a)
instance (ArrowState s a, ArrowChoice a) => ArrowState s (ErrorArrow ex a)
instance ArrowState s a => ArrowState s (ReaderArrow r a)
instance Arrow a => ArrowState s (StateArrow s a)
instance (ArrowState s a, Applicative f) => ArrowState s (StaticArrow f a)
instance (ArrowState s a, Monoid w) => ArrowState s (WriterArrow w a)
class Arrow a => ArrowReader r a
readState :: ArrowReader r a => a b r
newReader :: ArrowReader r a => a e b -> a (e, r) b
instance ArrowReader r a => ArrowReader r (Automaton a)
instance (ArrowReader r a, ArrowChoice a) => ArrowReader r (ErrorArrow ex a)
instance Arrow a => ArrowReader r (ReaderArrow r a)
instance ArrowReader r a => ArrowReader r (StateArrow s a)
instance (ArrowReader r a, Applicative f) => ArrowReader r (StaticArrow f a)
instance (ArrowReader r a, Monoid w) => ArrowReader r (WriterArrow w a)
class (Monoid w, Arrow a) => ArrowWriter w a
write :: ArrowWriter w a => a w ()
newWriter :: ArrowWriter w a => a e b -> a e (b, w)
instance ArrowWriter w a => ArrowWriter w (Automaton a)
instance ArrowWriter w a => ArrowWriter w (StreamArrow a)
instance ArrowWriter s a => ArrowWriter s (ReaderArrow r a)
instance (ArrowWriter w a, ArrowChoice a) => ArrowWriter w (ErrorArrow ex a)
instance ArrowWriter w a => ArrowWriter w (StateArrow s a)
instance (ArrowWriter w a, Applicative f) => ArrowWriter w (StaticArrow f a)
instance (Arrow a, Monoid w) => ArrowWriter w (WriterArrow w a)
class Arrow a => ArrowError ex a
raise :: ArrowError ex a => a ex b
handle :: ArrowError ex a => a e b -> a (e, ex) b -> a e b
tryInUnless :: ArrowError ex a => a e b -> a (e, b) c -> a (e, ex) c -> a e c
newError :: ArrowError ex a => a e b -> a e (Either ex b)
instance ArrowError r a => ArrowError r (Automaton a)
instance ArrowChoice a => ArrowError ex (ErrorArrow ex a)
instance ArrowError ex a => ArrowError ex (ReaderArrow r a)
instance ArrowError ex a => ArrowError ex (StateArrow s a)
instance (ArrowError ex a, Applicative f) => ArrowError ex (StaticArrow f a)
instance (ArrowError ex a, Monoid w) => ArrowError ex (WriterArrow w a)
tryInUnlessDefault :: (ArrowError ex a, ArrowChoice a) => a e b -> a (e, b) c -> a (e, ex) c -> a e c
class ArrowLoop a => ArrowCircuit a
delay :: ArrowCircuit a => b -> a b b
instance ArrowLoop a => ArrowCircuit (Automaton a)
instance ArrowLoop a => ArrowCircuit (StreamArrow a)
instance ArrowCircuit a => ArrowCircuit (ReaderArrow r a)
instance ArrowCircuit a => ArrowCircuit (StateArrow s a)
instance (ArrowCircuit a, Applicative f) => ArrowCircuit (StaticArrow f a)
instance (ArrowCircuit a, Monoid w) => ArrowCircuit (WriterArrow w a)

module Control.Arrow.Transformer.CoState
data CoStateArrow s a b c
instance Arrow a => Arrow (CoStateArrow s a)
instance ArrowLoop a => ArrowLoop (CoStateArrow s a)
instance ArrowPlus a => ArrowPlus (CoStateArrow s a)
instance ArrowZero a => ArrowZero (CoStateArrow s a)

module Control.Arrow.Transformer.Automaton
data Automaton a b c
instance Arrow a => ArrowTransformer Automaton a
instance ArrowError r a => ArrowError r (Automaton a)
instance ArrowReader r a => ArrowReader r (Automaton a)
instance ArrowState s a => ArrowState s (Automaton a)
instance ArrowWriter w a => ArrowWriter w (Automaton a)
instance ArrowAddReader r a a' => ArrowAddReader r (Automaton a) (Automaton a')
instance ArrowAddState r a a' => ArrowAddState r (Automaton a) (Automaton a')
instance ArrowAddWriter w a a' => ArrowAddWriter w (Automaton a) (Automaton a')
instance Arrow a => Arrow (Automaton a)
instance ArrowChoice a => ArrowChoice (Automaton a)
instance ArrowLoop a => ArrowCircuit (Automaton a)
instance ArrowLoop a => ArrowLoop (Automaton a)
instance ArrowPlus a => ArrowPlus (Automaton a)
instance ArrowZero a => ArrowZero (Automaton a)
instance (ArrowLoop a, ArrowApply a) => ArrowAddStream (Automaton a) a
runAutomaton :: (ArrowLoop a, ArrowApply a) => Automaton a (e, b) c -> a (e, Stream b) (Stream c)

module Control.Arrow.Transformer.Error
data ErrorArrow ex a b c
instance ArrowChoice a => ArrowError ex (ErrorArrow ex a)
instance (ArrowReader r a, ArrowChoice a) => ArrowReader r (ErrorArrow ex a)
instance (ArrowState s a, ArrowChoice a) => ArrowState s (ErrorArrow ex a)
instance (ArrowWriter w a, ArrowChoice a) => ArrowWriter w (ErrorArrow ex a)
instance ArrowChoice a => ArrowAddError ex (ErrorArrow ex a) a
instance (ArrowAddReader r a a', ArrowChoice a, ArrowChoice a') => ArrowAddReader r (ErrorArrow ex a) (ErrorArrow ex a')
instance (ArrowAddState s a a', ArrowChoice a, ArrowChoice a') => ArrowAddState s (ErrorArrow ex a) (ErrorArrow ex a')
instance (ArrowAddWriter w a a', ArrowChoice a, ArrowChoice a') => ArrowAddWriter w (ErrorArrow ex a) (ErrorArrow ex a')
instance ArrowChoice a => ArrowTransformer (ErrorArrow ex) a
instance ArrowChoice a => Arrow (ErrorArrow ex a)
instance (ArrowChoice a, ArrowApply a) => ArrowApply (ErrorArrow ex a)
instance ArrowChoice a => ArrowChoice (ErrorArrow ex a)
instance (ArrowChoice a, ArrowLoop a) => ArrowLoop (ErrorArrow ex a)
instance (Monoid ex, ArrowChoice a) => ArrowPlus (ErrorArrow ex a)
instance (Monoid ex, ArrowChoice a) => ArrowZero (ErrorArrow ex a)
runError :: ArrowChoice a => ErrorArrow ex a e b -> a (e, ex) b -> a e b
class (ArrowError ex a, Arrow a') => ArrowAddError ex a a'
liftError :: ArrowAddError ex a a' => a' e b -> a e b
elimError :: ArrowAddError ex a a' => a e b -> a' (e, ex) b -> a' e b
instance ArrowChoice a => ArrowAddError ex (ErrorArrow ex a) a
instance ArrowAddError ex a a' => ArrowAddError ex (ReaderArrow r a) (ReaderArrow r a')
instance ArrowAddError ex a a' => ArrowAddError ex (StateArrow s a) (StateArrow s a')
instance (ArrowAddError ex a a', Applicative f) => ArrowAddError ex (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddError ex a a', Monoid w) => ArrowAddError ex (WriterArrow w a) (WriterArrow w a')

module Control.Arrow.Transformer.Reader
data ReaderArrow r a b c
instance ArrowError ex a => ArrowError ex (ReaderArrow r a)
instance Arrow a => ArrowReader r (ReaderArrow r a)
instance ArrowState s a => ArrowState s (ReaderArrow r a)
instance ArrowWriter s a => ArrowWriter s (ReaderArrow r a)
instance Arrow a => ArrowAddReader r (ReaderArrow r a) a
instance ArrowAddError ex a a' => ArrowAddError ex (ReaderArrow r a) (ReaderArrow r a')
instance ArrowAddState s a a' => ArrowAddState s (ReaderArrow r a) (ReaderArrow r a')
instance ArrowAddWriter s a a' => ArrowAddWriter s (ReaderArrow r a) (ReaderArrow r a')
instance Arrow a => ArrowTransformer (ReaderArrow r) a
instance Arrow a => Arrow (ReaderArrow r a)
instance ArrowApply a => ArrowApply (ReaderArrow r a)
instance ArrowChoice a => ArrowChoice (ReaderArrow r a)
instance ArrowCircuit a => ArrowCircuit (ReaderArrow r a)
instance ArrowLoop a => ArrowLoop (ReaderArrow r a)
instance ArrowPlus a => ArrowPlus (ReaderArrow r a)
instance ArrowZero a => ArrowZero (ReaderArrow r a)
runReader :: Arrow a => ReaderArrow r a e b -> a (e, r) b
class (ArrowReader r a, Arrow a') => ArrowAddReader r a a'
liftReader :: ArrowAddReader r a a' => a' e b -> a e b
elimReader :: ArrowAddReader r a a' => a e b -> a' (e, r) b
instance ArrowAddReader r a a' => ArrowAddReader r (Automaton a) (Automaton a')
instance Arrow a => ArrowAddReader r (ReaderArrow r a) a
instance (ArrowAddReader r a a', ArrowChoice a, ArrowChoice a') => ArrowAddReader r (ErrorArrow ex a) (ErrorArrow ex a')
instance ArrowAddReader r a a' => ArrowAddReader r (StateArrow s a) (StateArrow s a')
instance (ArrowAddReader r a a', Applicative f) => ArrowAddReader r (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddReader r a a', Monoid w) => ArrowAddReader r (WriterArrow w a) (WriterArrow w a')

module Control.Arrow.Transformer.State
data StateArrow s a b c
instance ArrowError ex a => ArrowError ex (StateArrow s a)
instance ArrowReader r a => ArrowReader r (StateArrow s a)
instance Arrow a => ArrowState s (StateArrow s a)
instance ArrowWriter w a => ArrowWriter w (StateArrow s a)
instance Arrow a => ArrowAddState s (StateArrow s a) a
instance ArrowAddError ex a a' => ArrowAddError ex (StateArrow s a) (StateArrow s a')
instance ArrowAddReader r a a' => ArrowAddReader r (StateArrow s a) (StateArrow s a')
instance ArrowAddWriter w a a' => ArrowAddWriter w (StateArrow s a) (StateArrow s a')
instance Arrow a => ArrowTransformer (StateArrow s) a
instance Arrow a => Arrow (StateArrow s a)
instance ArrowApply a => ArrowApply (StateArrow s a)
instance ArrowChoice a => ArrowChoice (StateArrow s a)
instance ArrowCircuit a => ArrowCircuit (StateArrow s a)
instance ArrowLoop a => ArrowLoop (StateArrow s a)
instance ArrowPlus a => ArrowPlus (StateArrow s a)
instance ArrowZero a => ArrowZero (StateArrow s a)
runState :: Arrow a => StateArrow s a e b -> a (e, s) (b, s)
class (ArrowState s a, Arrow a') => ArrowAddState s a a'
liftState :: ArrowAddState s a a' => a' e b -> a e b
elimState :: ArrowAddState s a a' => a e b -> a' (e, s) (b, s)
instance ArrowAddState r a a' => ArrowAddState r (Automaton a) (Automaton a')
instance Arrow a => ArrowAddState s (StateArrow s a) a
instance (ArrowAddState s a a', ArrowChoice a, ArrowChoice a') => ArrowAddState s (ErrorArrow ex a) (ErrorArrow ex a')
instance ArrowAddState s a a' => ArrowAddState s (ReaderArrow r a) (ReaderArrow r a')
instance (ArrowAddState s a a', Applicative f) => ArrowAddState s (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddState s a a', Monoid w) => ArrowAddState s (WriterArrow w a) (WriterArrow w a')

module Control.Arrow.Transformer.Static
data StaticArrow f a b c
instance (ArrowError ex a, Applicative f) => ArrowError ex (StaticArrow f a)
instance (ArrowReader r a, Applicative f) => ArrowReader r (StaticArrow f a)
instance (ArrowState s a, Applicative f) => ArrowState s (StaticArrow f a)
instance (ArrowWriter w a, Applicative f) => ArrowWriter w (StaticArrow f a)
instance (ArrowAddError ex a a', Applicative f) => ArrowAddError ex (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddReader r a a', Applicative f) => ArrowAddReader r (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddState s a a', Applicative f) => ArrowAddState s (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddWriter w a a', Applicative f) => ArrowAddWriter w (StaticArrow f a) (StaticArrow f a')
instance (Arrow a, Applicative f) => ArrowTransformer (StaticArrow f) a
instance (Arrow a, Applicative f) => Arrow (StaticArrow f a)
instance (ArrowChoice a, Applicative f) => ArrowChoice (StaticArrow f a)
instance (ArrowCircuit a, Applicative f) => ArrowCircuit (StaticArrow f a)
instance (ArrowLoop a, Applicative f) => ArrowLoop (StaticArrow f a)
instance (ArrowPlus a, Applicative f) => ArrowPlus (StaticArrow f a)
instance (ArrowZero a, Applicative f) => ArrowZero (StaticArrow f a)
instance (ArrowAddStream a a', Applicative f) => ArrowAddStream (StaticArrow f a) (StaticArrow f a')
type StaticMonadArrow m = StaticArrow (WrappedMonad m)
type StaticArrowArrow a s = StaticArrow (WrappedArrow a s)
wrapA :: (Arrow a, Arrow a') => a s (a' b c) -> StaticArrowArrow a s a' b c
unwrapA :: (Arrow a, Arrow a') => StaticArrowArrow a s a' b c -> a s (a' b c)
wrapM :: (Monad m, Arrow a) => m (a b c) -> StaticMonadArrow m a b c
unwrapM :: (Monad m, Arrow a) => StaticMonadArrow m a b c -> m (a b c)

module Control.Arrow.Transformer.Stream
data StreamArrow a b c
instance Arrow a => ArrowTransformer StreamArrow a
instance ArrowState s a => ArrowState s (StreamArrow a)
instance ArrowWriter w a => ArrowWriter w (StreamArrow a)
instance Arrow a => Arrow (StreamArrow a)
instance Arrow a => ArrowChoice (StreamArrow a)
instance ArrowLoop a => ArrowCircuit (StreamArrow a)
instance ArrowLoop a => ArrowLoop (StreamArrow a)
instance ArrowPlus a => ArrowPlus (StreamArrow a)
instance ArrowZero a => ArrowZero (StreamArrow a)
instance ArrowLoop a => ArrowAddStream (StreamArrow a) a
runStream :: ArrowLoop a => StreamArrow a (e, b) c -> a (e, Stream b) (Stream c)
type StreamMap = StreamArrow (->)
type StreamMapST s = StreamArrow (Kleisli (ST s))
runStreamST :: StreamMapST s e c -> StreamMap e c
class (ArrowCircuit a, Arrow a') => ArrowAddStream a a'
liftStream :: ArrowAddStream a a' => a' e b -> a e b
elimStream :: ArrowAddStream a a' => a (e, b) c -> a' (e, Stream b) (Stream c)
instance (ArrowLoop a, ArrowApply a) => ArrowAddStream (Automaton a) a
instance ArrowLoop a => ArrowAddStream (StreamArrow a) a
instance (ArrowAddStream a a', Applicative f) => ArrowAddStream (StaticArrow f a) (StaticArrow f a')

module Control.Arrow.Transformer.Writer
data WriterArrow w a b c
instance (ArrowError ex a, Monoid w) => ArrowError ex (WriterArrow w a)
instance (ArrowReader r a, Monoid w) => ArrowReader r (WriterArrow w a)
instance (ArrowState s a, Monoid w) => ArrowState s (WriterArrow w a)
instance (Arrow a, Monoid w) => ArrowWriter w (WriterArrow w a)
instance (Arrow a, Monoid w) => ArrowAddWriter w (WriterArrow w a) a
instance (ArrowAddError ex a a', Monoid w) => ArrowAddError ex (WriterArrow w a) (WriterArrow w a')
instance (ArrowAddReader r a a', Monoid w) => ArrowAddReader r (WriterArrow w a) (WriterArrow w a')
instance (ArrowAddState s a a', Monoid w) => ArrowAddState s (WriterArrow w a) (WriterArrow w a')
instance (Arrow a, Monoid w) => ArrowTransformer (WriterArrow w) a
instance (Arrow a, Monoid w) => Arrow (WriterArrow w a)
instance (ArrowApply a, Monoid w) => ArrowApply (WriterArrow w a)
instance (ArrowChoice a, Monoid w) => ArrowChoice (WriterArrow w a)
instance (ArrowCircuit a, Monoid w) => ArrowCircuit (WriterArrow w a)
instance (ArrowLoop a, Monoid w) => ArrowLoop (WriterArrow w a)
instance (ArrowPlus a, Monoid w) => ArrowPlus (WriterArrow w a)
instance (ArrowZero a, Monoid w) => ArrowZero (WriterArrow w a)
runWriter :: (Arrow a, Monoid w) => WriterArrow w a e b -> a e (b, w)
class (ArrowWriter w a, Arrow a') => ArrowAddWriter w a a'
liftWriter :: ArrowAddWriter w a a' => a' e b -> a e b
elimWriter :: ArrowAddWriter w a a' => a e b -> a' e (b, w)
instance ArrowAddWriter w a a' => ArrowAddWriter w (Automaton a) (Automaton a')
instance (Arrow a, Monoid w) => ArrowAddWriter w (WriterArrow w a) a
instance ArrowAddWriter s a a' => ArrowAddWriter s (ReaderArrow r a) (ReaderArrow r a')
instance (ArrowAddWriter w a a', ArrowChoice a, ArrowChoice a') => ArrowAddWriter w (ErrorArrow ex a) (ErrorArrow ex a')
instance ArrowAddWriter w a a' => ArrowAddWriter w (StateArrow s a) (StateArrow s a')
instance (ArrowAddWriter w a a', Applicative f) => ArrowAddWriter w (StaticArrow f a) (StaticArrow f a')
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Data.ByteString.Internal
data ByteString
PS :: ForeignPtr Word8 -> Int -> Int -> ByteString
instance Data ByteString
instance Eq ByteString
instance Monoid ByteString
instance Ord ByteString
instance Read ByteString
instance Show ByteString
instance Typeable ByteString
create :: Int -> (Ptr Word8 -> IO ()) -> IO ByteString
createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
unsafeCreate :: Int -> (Ptr Word8 -> IO ()) -> ByteString
mallocByteString :: Int -> IO (ForeignPtr a)
fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString
toForeignPtr :: ByteString -> (ForeignPtr Word8, Int, Int)
inlinePerformIO :: IO a -> a
nullForeignPtr :: ForeignPtr Word8
countOccurrences :: (Storable a, Num a) => Ptr a -> Ptr Word8 -> Int -> IO ()
c_strlen :: CString -> IO CSize
c_free_finalizer :: FunPtr (Ptr Word8 -> IO ())
memchr :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
memcmp :: Ptr Word8 -> Ptr Word8 -> CSize -> IO CInt
memcpy :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
memmove :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
memset :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
c_reverse :: Ptr Word8 -> Ptr Word8 -> CULong -> IO ()
c_intersperse :: Ptr Word8 -> Ptr Word8 -> CULong -> Word8 -> IO ()
c_maximum :: Ptr Word8 -> CULong -> IO Word8
c_minimum :: Ptr Word8 -> CULong -> IO Word8
c_count :: Ptr Word8 -> CULong -> Word8 -> IO CULong
memcpy_ptr_baoff :: Ptr a -> RawBuffer -> CInt -> CSize -> IO (Ptr ())
w2c :: Word8 -> Char
c2w :: Char -> Word8
isSpaceWord8 :: Word8 -> Bool

module Data.ByteString.Lazy.Internal
data ByteString
Empty :: ByteString
Chunk :: ByteString -> ByteString -> ByteString
instance Data ByteString
instance Eq ByteString
instance Monoid ByteString
instance Ord ByteString
instance Read ByteString
instance Show ByteString
instance Typeable ByteString
chunk :: ByteString -> ByteString -> ByteString
foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a
foldlChunks :: (a -> ByteString -> a) -> a -> ByteString -> a
invariant :: ByteString -> Bool
checkInvariant :: ByteString -> ByteString
defaultChunkSize :: Int
smallChunkSize :: Int
chunkOverhead :: Int

module Data.ByteString.Unsafe
unsafeHead :: ByteString -> Word8
unsafeTail :: ByteString -> ByteString
unsafeIndex :: ByteString -> Int -> Word8
unsafeTake :: Int -> ByteString -> ByteString
unsafeDrop :: Int -> ByteString -> ByteString
unsafeUseAsCString :: ByteString -> (CString -> IO a) -> IO a
unsafeUseAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
unsafePackCString :: CString -> IO ByteString
unsafePackCStringLen :: CStringLen -> IO ByteString
unsafePackMallocCString :: CString -> IO ByteString
unsafePackAddress :: Addr# -> IO ByteString
unsafePackAddressLen :: Int -> Addr# -> IO ByteString
unsafePackCStringFinalizer :: Ptr Word8 -> Int -> IO () -> IO ByteString
unsafeFinalize :: ByteString -> IO ()

module Data.ByteString
data ByteString
instance Data ByteString
instance Eq ByteString
instance Monoid ByteString
instance Ord ByteString
instance Read ByteString
instance Show ByteString
instance Typeable ByteString
empty :: ByteString
singleton :: Word8 -> ByteString
pack :: [Word8] -> ByteString
unpack :: ByteString -> [Word8]
cons :: Word8 -> ByteString -> ByteString
snoc :: ByteString -> Word8 -> ByteString
append :: ByteString -> ByteString -> ByteString
head :: ByteString -> Word8
uncons :: ByteString -> Maybe (Word8, ByteString)
last :: ByteString -> Word8
tail :: ByteString -> ByteString
init :: ByteString -> ByteString
null :: ByteString -> Bool
length :: ByteString -> Int
map :: (Word8 -> Word8) -> ByteString -> ByteString
reverse :: ByteString -> ByteString
intersperse :: Word8 -> ByteString -> ByteString
intercalate :: ByteString -> [ByteString] -> ByteString
transpose :: [ByteString] -> [ByteString]
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
concat :: [ByteString] -> ByteString
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
any :: (Word8 -> Bool) -> ByteString -> Bool
all :: (Word8 -> Bool) -> ByteString -> Bool
maximum :: ByteString -> Word8
minimum :: ByteString -> Word8
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapIndexed :: (Int -> Word8 -> Word8) -> ByteString -> ByteString
replicate :: Int -> Word8 -> ByteString
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
take :: Int -> ByteString -> ByteString
drop :: Int -> ByteString -> ByteString
splitAt :: Int -> ByteString -> (ByteString, ByteString)
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
group :: ByteString -> [ByteString]
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
inits :: ByteString -> [ByteString]
tails :: ByteString -> [ByteString]
split :: Word8 -> ByteString -> [ByteString]
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
isPrefixOf :: ByteString -> ByteString -> Bool
isSuffixOf :: ByteString -> ByteString -> Bool
isInfixOf :: ByteString -> ByteString -> Bool
isSubstringOf :: ByteString -> ByteString -> Bool
findSubstring :: ByteString -> ByteString -> Maybe Int
findSubstrings :: ByteString -> ByteString -> [Int]
elem :: Word8 -> ByteString -> Bool
notElem :: Word8 -> ByteString -> Bool
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
filter :: (Word8 -> Bool) -> ByteString -> ByteString
partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
index :: ByteString -> Int -> Word8
elemIndex :: Word8 -> ByteString -> Maybe Int
elemIndices :: Word8 -> ByteString -> [Int]
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
findIndices :: (Word8 -> Bool) -> ByteString -> [Int]
count :: Word8 -> ByteString -> Int
zip :: ByteString -> ByteString -> [(Word8, Word8)]
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
sort :: ByteString -> ByteString
copy :: ByteString -> ByteString
packCString :: CString -> IO ByteString
packCStringLen :: CStringLen -> IO ByteString
useAsCString :: ByteString -> (CString -> IO a) -> IO a
useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
getLine :: IO ByteString
getContents :: IO ByteString
putStr :: ByteString -> IO ()
putStrLn :: ByteString -> IO ()
interact :: (ByteString -> ByteString) -> IO ()
readFile :: FilePath -> IO ByteString
writeFile :: FilePath -> ByteString -> IO ()
appendFile :: FilePath -> ByteString -> IO ()
hGetLine :: Handle -> IO ByteString
hGetContents :: Handle -> IO ByteString
hGet :: Handle -> Int -> IO ByteString
hGetNonBlocking :: Handle -> Int -> IO ByteString
hPut :: Handle -> ByteString -> IO ()
hPutStr :: Handle -> ByteString -> IO ()
hPutStrLn :: Handle -> ByteString -> IO ()

module Data.ByteString.Char8
data ByteString
instance Data ByteString
instance Eq ByteString
instance Monoid ByteString
instance Ord ByteString
instance Read ByteString
instance Show ByteString
instance Typeable ByteString
empty :: ByteString
singleton :: Char -> ByteString
pack :: String -> ByteString
unpack :: ByteString -> [Char]
cons :: Char -> ByteString -> ByteString
snoc :: ByteString -> Char -> ByteString
append :: ByteString -> ByteString -> ByteString
head :: ByteString -> Char
uncons :: ByteString -> Maybe (Char, ByteString)
last :: ByteString -> Char
tail :: ByteString -> ByteString
init :: ByteString -> ByteString
null :: ByteString -> Bool
length :: ByteString -> Int
map :: (Char -> Char) -> ByteString -> ByteString
reverse :: ByteString -> ByteString
intersperse :: Char -> ByteString -> ByteString
intercalate :: ByteString -> [ByteString] -> ByteString
transpose :: [ByteString] -> [ByteString]
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr' :: (Char -> a -> a) -> a -> ByteString -> a
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
concat :: [ByteString] -> ByteString
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
any :: (Char -> Bool) -> ByteString -> Bool
all :: (Char -> Bool) -> ByteString -> Bool
maximum :: ByteString -> Char
minimum :: ByteString -> Char
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapIndexed :: (Int -> Char -> Char) -> ByteString -> ByteString
replicate :: Int -> Char -> ByteString
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
take :: Int -> ByteString -> ByteString
drop :: Int -> ByteString -> ByteString
splitAt :: Int -> ByteString -> (ByteString, ByteString)
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
group :: ByteString -> [ByteString]
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
inits :: ByteString -> [ByteString]
tails :: ByteString -> [ByteString]
split :: Char -> ByteString -> [ByteString]
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
lines :: ByteString -> [ByteString]
words :: ByteString -> [ByteString]
unlines :: [ByteString] -> ByteString
unwords :: [ByteString] -> ByteString
isPrefixOf :: ByteString -> ByteString -> Bool
isSuffixOf :: ByteString -> ByteString -> Bool
isInfixOf :: ByteString -> ByteString -> Bool
isSubstringOf :: ByteString -> ByteString -> Bool
findSubstring :: ByteString -> ByteString -> Maybe Int
findSubstrings :: ByteString -> ByteString -> [Int]
elem :: Char -> ByteString -> Bool
notElem :: Char -> ByteString -> Bool
find :: (Char -> Bool) -> ByteString -> Maybe Char
filter :: (Char -> Bool) -> ByteString -> ByteString
index :: ByteString -> Int -> Char
elemIndex :: Char -> ByteString -> Maybe Int
elemIndices :: Char -> ByteString -> [Int]
elemIndexEnd :: Char -> ByteString -> Maybe Int
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
findIndices :: (Char -> Bool) -> ByteString -> [Int]
count :: Char -> ByteString -> Int
zip :: ByteString -> ByteString -> [(Char, Char)]
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
unzip :: [(Char, Char)] -> (ByteString, ByteString)
sort :: ByteString -> ByteString
readInt :: ByteString -> Maybe (Int, ByteString)
readInteger :: ByteString -> Maybe (Integer, ByteString)
copy :: ByteString -> ByteString
packCString :: CString -> IO ByteString
packCStringLen :: CStringLen -> IO ByteString
useAsCString :: ByteString -> (CString -> IO a) -> IO a
useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
getLine :: IO ByteString
getContents :: IO ByteString
putStr :: ByteString -> IO ()
putStrLn :: ByteString -> IO ()
interact :: (ByteString -> ByteString) -> IO ()
readFile :: FilePath -> IO ByteString
writeFile :: FilePath -> ByteString -> IO ()
appendFile :: FilePath -> ByteString -> IO ()
hGetLine :: Handle -> IO ByteString
hGetContents :: Handle -> IO ByteString
hGet :: Handle -> Int -> IO ByteString
hGetNonBlocking :: Handle -> Int -> IO ByteString
hPut :: Handle -> ByteString -> IO ()
hPutStr :: Handle -> ByteString -> IO ()
hPutStrLn :: Handle -> ByteString -> IO ()

module Data.ByteString.Lazy
data ByteString
instance Data ByteString
instance Eq ByteString
instance Monoid ByteString
instance Ord ByteString
instance Read ByteString
instance Show ByteString
instance Typeable ByteString
empty :: ByteString
singleton :: Word8 -> ByteString
pack :: [Word8] -> ByteString
unpack :: ByteString -> [Word8]
fromChunks :: [ByteString] -> ByteString
toChunks :: ByteString -> [ByteString]
cons :: Word8 -> ByteString -> ByteString
cons' :: Word8 -> ByteString -> ByteString
snoc :: ByteString -> Word8 -> ByteString
append :: ByteString -> ByteString -> ByteString
head :: ByteString -> Word8
uncons :: ByteString -> Maybe (Word8, ByteString)
last :: ByteString -> Word8
tail :: ByteString -> ByteString
init :: ByteString -> ByteString
null :: ByteString -> Bool
length :: ByteString -> Int64
map :: (Word8 -> Word8) -> ByteString -> ByteString
reverse :: ByteString -> ByteString
intersperse :: Word8 -> ByteString -> ByteString
intercalate :: ByteString -> [ByteString] -> ByteString
transpose :: [ByteString] -> [ByteString]
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
concat :: [ByteString] -> ByteString
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
any :: (Word8 -> Bool) -> ByteString -> Bool
all :: (Word8 -> Bool) -> ByteString -> Bool
maximum :: ByteString -> Word8
minimum :: ByteString -> Word8
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapIndexed :: (Int -> Word8 -> Word8) -> ByteString -> ByteString
repeat :: Word8 -> ByteString
replicate :: Int64 -> Word8 -> ByteString
cycle :: ByteString -> ByteString
iterate :: (Word8 -> Word8) -> Word8 -> ByteString
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
take :: Int64 -> ByteString -> ByteString
drop :: Int64 -> ByteString -> ByteString
splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
group :: ByteString -> [ByteString]
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
inits :: ByteString -> [ByteString]
tails :: ByteString -> [ByteString]
split :: Word8 -> ByteString -> [ByteString]
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
isPrefixOf :: ByteString -> ByteString -> Bool
isSuffixOf :: ByteString -> ByteString -> Bool
elem :: Word8 -> ByteString -> Bool
notElem :: Word8 -> ByteString -> Bool
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
filter :: (Word8 -> Bool) -> ByteString -> ByteString
partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
index :: ByteString -> Int64 -> Word8
elemIndex :: Word8 -> ByteString -> Maybe Int64
elemIndices :: Word8 -> ByteString -> [Int64]
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int64
findIndices :: (Word8 -> Bool) -> ByteString -> [Int64]
count :: Word8 -> ByteString -> Int64
zip :: ByteString -> ByteString -> [(Word8, Word8)]
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
copy :: ByteString -> ByteString
getContents :: IO ByteString
putStr :: ByteString -> IO ()
putStrLn :: ByteString -> IO ()
interact :: (ByteString -> ByteString) -> IO ()
readFile :: FilePath -> IO ByteString
writeFile :: FilePath -> ByteString -> IO ()
appendFile :: FilePath -> ByteString -> IO ()
hGetContents :: Handle -> IO ByteString
hGet :: Handle -> Int -> IO ByteString
hGetNonBlocking :: Handle -> Int -> IO ByteString
hPut :: Handle -> ByteString -> IO ()
hPutStr :: Handle -> ByteString -> IO ()

module Data.ByteString.Lazy.Char8
data ByteString
instance Data ByteString
instance Eq ByteString
instance Monoid ByteString
instance Ord ByteString
instance Read ByteString
instance Show ByteString
instance Typeable ByteString
empty :: ByteString
singleton :: Char -> ByteString
pack :: [Char] -> ByteString
unpack :: ByteString -> [Char]
fromChunks :: [ByteString] -> ByteString
toChunks :: ByteString -> [ByteString]
cons :: Char -> ByteString -> ByteString
cons' :: Char -> ByteString -> ByteString
snoc :: ByteString -> Char -> ByteString
append :: ByteString -> ByteString -> ByteString
head :: ByteString -> Char
uncons :: ByteString -> Maybe (Char, ByteString)
last :: ByteString -> Char
tail :: ByteString -> ByteString
init :: ByteString -> ByteString
null :: ByteString -> Bool
length :: ByteString -> Int64
map :: (Char -> Char) -> ByteString -> ByteString
reverse :: ByteString -> ByteString
intersperse :: Char -> ByteString -> ByteString
intercalate :: ByteString -> [ByteString] -> ByteString
transpose :: [ByteString] -> [ByteString]
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
concat :: [ByteString] -> ByteString
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
any :: (Char -> Bool) -> ByteString -> Bool
all :: (Char -> Bool) -> ByteString -> Bool
maximum :: ByteString -> Char
minimum :: ByteString -> Char
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapIndexed :: (Int -> Char -> Char) -> ByteString -> ByteString
repeat :: Char -> ByteString
replicate :: Int64 -> Char -> ByteString
cycle :: ByteString -> ByteString
iterate :: (Char -> Char) -> Char -> ByteString
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
take :: Int64 -> ByteString -> ByteString
drop :: Int64 -> ByteString -> ByteString
splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
group :: ByteString -> [ByteString]
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
inits :: ByteString -> [ByteString]
tails :: ByteString -> [ByteString]
split :: Char -> ByteString -> [ByteString]
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
lines :: ByteString -> [ByteString]
words :: ByteString -> [ByteString]
unlines :: [ByteString] -> ByteString
unwords :: [ByteString] -> ByteString
isPrefixOf :: ByteString -> ByteString -> Bool
elem :: Char -> ByteString -> Bool
notElem :: Char -> ByteString -> Bool
find :: (Char -> Bool) -> ByteString -> Maybe Char
filter :: (Char -> Bool) -> ByteString -> ByteString
index :: ByteString -> Int64 -> Char
elemIndex :: Char -> ByteString -> Maybe Int64
elemIndices :: Char -> ByteString -> [Int64]
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
findIndices :: (Char -> Bool) -> ByteString -> [Int64]
count :: Char -> ByteString -> Int64
zip :: ByteString -> ByteString -> [(Char, Char)]
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
copy :: ByteString -> ByteString
readInt :: ByteString -> Maybe (Int, ByteString)
readInteger :: ByteString -> Maybe (Integer, ByteString)
getContents :: IO ByteString
putStr :: ByteString -> IO ()
putStrLn :: ByteString -> IO ()
interact :: (ByteString -> ByteString) -> IO ()
readFile :: FilePath -> IO ByteString
writeFile :: FilePath -> ByteString -> IO ()
appendFile :: FilePath -> ByteString -> IO ()
hGetContents :: Handle -> IO ByteString
hGet :: Handle -> Int -> IO ByteString
hGetNonBlocking :: Handle -> Int -> IO ByteString
hPut :: Handle -> ByteString -> IO ()
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Network.CGI.Protocol
data CGIRequest
CGIRequest :: Map String String -> [(String, Input)] -> ByteString -> CGIRequest
cgiVars :: CGIRequest -> Map String String
cgiInputs :: CGIRequest -> [(String, Input)]
cgiRequestBody :: CGIRequest -> ByteString
instance Show CGIRequest
data Input
Input :: ByteString -> Maybe String -> ContentType -> Input
inputValue :: Input -> ByteString
inputFilename :: Input -> Maybe String
inputContentType :: Input -> ContentType
instance Show Input
data CGIResult
CGIOutput :: ByteString -> CGIResult
CGINothing :: CGIResult
instance Eq CGIResult
instance Ord CGIResult
instance Read CGIResult
instance Show CGIResult
instance Typeable CGIResult
type Headers = [(HeaderName, String)]
newtype HeaderName
HeaderName :: String -> HeaderName
instance Eq HeaderName
instance Ord HeaderName
instance Show HeaderName
hRunCGI :: MonadIO m => [(String, String)] -> Handle -> Handle -> (CGIRequest -> m (Headers, CGIResult)) -> m ()
runCGIEnvFPS :: Monad m => [(String, String)] -> ByteString -> (CGIRequest -> m (Headers, CGIResult)) -> m ByteString
decodeInput :: [(String, String)] -> ByteString -> ([(String, Input)], ByteString)
takeInput :: [(String, String)] -> ByteString -> ByteString
getCGIVars :: MonadIO m => m [(String, String)]
logCGI :: MonadIO m => String -> m ()
formEncode :: [(String, String)] -> String
urlEncode :: String -> String
formDecode :: String -> [(String, String)]
urlDecode :: String -> String
maybeRead :: Read a => String -> Maybe a
replace :: Eq a => a -> a -> [a] -> [a]

module Network.CGI.Monad
class Monad m => MonadCGI m
cgiAddHeader :: MonadCGI m => HeaderName -> String -> m ()
cgiGet :: MonadCGI m => (CGIRequest -> a) -> m a
instance Monad m => MonadCGI (CGIT m)
newtype CGIT m a
CGIT :: ReaderT CGIRequest (WriterT Headers m) a -> CGIT m a
unCGIT :: CGIT m a -> ReaderT CGIRequest (WriterT Headers m) a
instance MonadTrans CGIT
instance MonadError Exception (CGIT IO)
instance Monad m => Functor (CGIT m)
instance Monad m => Monad (CGIT m)
instance Monad m => MonadCGI (CGIT m)
instance MonadIO m => MonadIO (CGIT m)
instance (Typeable1 m, Typeable a) => Typeable (CGIT m a)
type CGI a = CGIT IO a
runCGIT :: Monad m => CGIT m a -> CGIRequest -> m (Headers, a)
data CGIRequest
CGIRequest :: Map String String -> [(String, Input)] -> ByteString -> CGIRequest
cgiVars :: CGIRequest -> Map String String
cgiInputs :: CGIRequest -> [(String, Input)]
cgiRequestBody :: CGIRequest -> ByteString
instance Show CGIRequest
throwCGI :: (MonadCGI m, MonadIO m) => Exception -> m a
catchCGI :: CGI a -> (Exception -> CGI a) -> CGI a
tryCGI :: CGI a -> CGI (Either Exception a)
handleExceptionCGI :: CGI a -> (Exception -> CGI a) -> CGI a

module Network.CGI.Cookie
data Cookie
Cookie :: String -> String -> Maybe CalendarTime -> Maybe String -> Maybe String -> Bool -> Cookie
cookieName :: Cookie -> String
cookieValue :: Cookie -> String
cookieExpires :: Cookie -> Maybe CalendarTime
cookieDomain :: Cookie -> Maybe String
cookiePath :: Cookie -> Maybe String
cookieSecure :: Cookie -> Bool
instance Eq Cookie
instance Ord Cookie
instance Read Cookie
instance Show Cookie
newCookie :: String -> String -> Cookie
findCookie :: String -> String -> Maybe String
deleteCookie :: Cookie -> Cookie
showCookie :: Cookie -> String
readCookies :: String -> [(String, String)]

module Network.CGI
class Monad m => MonadCGI m
instance Monad m => MonadCGI (CGIT m)
data CGIT m a
instance MonadTrans CGIT
instance MonadError Exception (CGIT IO)
instance Monad m => Functor (CGIT m)
instance Monad m => Monad (CGIT m)
instance Monad m => MonadCGI (CGIT m)
instance MonadIO m => MonadIO (CGIT m)
instance (Typeable1 m, Typeable a) => Typeable (CGIT m a)
data CGIResult
instance Eq CGIResult
instance Ord CGIResult
instance Read CGIResult
instance Show CGIResult
instance Typeable CGIResult
type CGI a = CGIT IO a
runCGI :: MonadIO m => CGIT m CGIResult -> m ()
throwCGI :: (MonadCGI m, MonadIO m) => Exception -> m a
catchCGI :: CGI a -> (Exception -> CGI a) -> CGI a
tryCGI :: CGI a -> CGI (Either Exception a)
handleExceptionCGI :: CGI a -> (Exception -> CGI a) -> CGI a
handleErrors :: CGI CGIResult -> CGI CGIResult
logCGI :: MonadIO m => String -> m ()
output :: MonadCGI m => String -> m CGIResult
outputFPS :: MonadCGI m => ByteString -> m CGIResult
outputNothing :: MonadCGI m => m CGIResult
redirect :: MonadCGI m => String -> m CGIResult
setHeader :: MonadCGI m => String -> String -> m ()
setStatus :: MonadCGI m => Int -> String -> m ()
outputError :: (MonadCGI m, MonadIO m) => Int -> String -> [String] -> m CGIResult
outputException :: (MonadCGI m, MonadIO m) => Exception -> m CGIResult
outputNotFound :: (MonadIO m, MonadCGI m) => String -> m CGIResult
outputMethodNotAllowed :: (MonadIO m, MonadCGI m) => [String] -> m CGIResult
outputInternalServerError :: (MonadIO m, MonadCGI m) => [String] -> m CGIResult
getInput :: MonadCGI m => String -> m (Maybe String)
getInputFPS :: MonadCGI m => String -> m (Maybe ByteString)
readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
getInputs :: MonadCGI m => m [(String, String)]
getInputNames :: MonadCGI m => m [String]
getMultiInput :: MonadCGI m => String -> m [String]
getMultiInputFPS :: MonadCGI m => String -> m [ByteString]
getInputFilename :: MonadCGI m => String -> m (Maybe String)
getInputContentType :: MonadCGI m => String -> m (Maybe String)
getVar :: MonadCGI m => String -> m (Maybe String)
getVarWithDefault :: MonadCGI m => String -> String -> m String
getVars :: MonadCGI m => m [(String, String)]
serverName :: MonadCGI m => m String
serverPort :: MonadCGI m => m Int
requestMethod :: MonadCGI m => m String
pathInfo :: MonadCGI m => m String
pathTranslated :: MonadCGI m => m String
scriptName :: MonadCGI m => m String
queryString :: MonadCGI m => m String
remoteHost :: MonadCGI m => m (Maybe String)
remoteAddr :: MonadCGI m => m String
authType :: MonadCGI m => m (Maybe String)
remoteUser :: MonadCGI m => m (Maybe String)
requestContentType :: MonadCGI m => m (Maybe String)
requestContentLength :: MonadCGI m => m (Maybe Int)
requestHeader :: MonadCGI m => String -> m (Maybe String)
progURI :: MonadCGI m => m URI
queryURI :: MonadCGI m => m URI
requestURI :: MonadCGI m => m URI
data ContentType
ContentType :: String -> String -> [(String, String)] -> ContentType
ctType :: ContentType -> String
ctSubtype :: ContentType -> String
ctParameters :: ContentType -> [(String, String)]
instance Eq ContentType
instance Ord ContentType
instance Read ContentType
instance Show ContentType
showContentType :: ContentType -> String
parseContentType :: Monad m => String -> m ContentType
data Cookie
Cookie :: String -> String -> Maybe CalendarTime -> Maybe String -> Maybe String -> Bool -> Cookie
cookieName :: Cookie -> String
cookieValue :: Cookie -> String
cookieExpires :: Cookie -> Maybe CalendarTime
cookieDomain :: Cookie -> Maybe String
cookiePath :: Cookie -> Maybe String
cookieSecure :: Cookie -> Bool
instance Eq Cookie
instance Ord Cookie
instance Read Cookie
instance Show Cookie
newCookie :: String -> String -> Cookie
getCookie :: MonadCGI m => String -> m (Maybe String)
readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
setCookie :: MonadCGI m => Cookie -> m ()
deleteCookie :: MonadCGI m => Cookie -> m ()
formEncode :: [(String, String)] -> String
urlEncode :: String -> String
formDecode :: String -> [(String, String)]
urlDecode :: String -> String
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Data.Set
data Set a
instance Foldable Set
instance Typeable1 Set
instance (Data a, Ord a) => Data (Set a)
instance Eq a => Eq (Set a)
instance Ord a => Monoid (Set a)
instance Ord a => Ord (Set a)
instance (Read a, Ord a) => Read (Set a)
instance Show a => Show (Set a)
(\\) :: Ord a => Set a -> Set a -> Set a
null :: Set a -> Bool
size :: Set a -> Int
member :: Ord a => a -> Set a -> Bool
notMember :: Ord a => a -> Set a -> Bool
isSubsetOf :: Ord a => Set a -> Set a -> Bool
isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
empty :: Set a
singleton :: a -> Set a
insert :: Ord a => a -> Set a -> Set a
delete :: Ord a => a -> Set a -> Set a
union :: Ord a => Set a -> Set a -> Set a
unions :: Ord a => [Set a] -> Set a
difference :: Ord a => Set a -> Set a -> Set a
intersection :: Ord a => Set a -> Set a -> Set a
filter :: Ord a => (a -> Bool) -> Set a -> Set a
partition :: Ord a => (a -> Bool) -> Set a -> (Set a, Set a)
split :: Ord a => a -> Set a -> (Set a, Set a)
splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)
map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
mapMonotonic :: (a -> b) -> Set a -> Set b
fold :: (a -> b -> b) -> b -> Set a -> b
findMin :: Set a -> a
findMax :: Set a -> a
deleteMin :: Set a -> Set a
deleteMax :: Set a -> Set a
deleteFindMin :: Set a -> (a, Set a)
deleteFindMax :: Set a -> (a, Set a)
maxView :: Monad m => Set a -> m (a, Set a)
minView :: Monad m => Set a -> m (a, Set a)
elems :: Set a -> [a]
toList :: Set a -> [a]
fromList :: Ord a => [a] -> Set a
toAscList :: Set a -> [a]
fromAscList :: Eq a => [a] -> Set a
fromDistinctAscList :: [a] -> Set a
showTree :: Show a => Set a -> String
showTreeWith :: Show a => Bool -> Bool -> Set a -> String
valid :: Ord a => Set a -> Bool

module Data.Sequence
data Seq a
instance Foldable Seq
instance Functor Seq
instance Monad Seq
instance MonadPlus Seq
instance Traversable Seq
instance Typeable1 Seq
instance Data a => Data (Seq a)
instance Eq a => Eq (Seq a)
instance Monoid (Seq a)
instance Ord a => Ord (Seq a)
instance Read a => Read (Seq a)
instance Show a => Show (Seq a)
empty :: Seq a
singleton :: a -> Seq a
(<|) :: a -> Seq a -> Seq a
(|>) :: Seq a -> a -> Seq a
(><) :: Seq a -> Seq a -> Seq a
fromList :: [a] -> Seq a
null :: Seq a -> Bool
length :: Seq a -> Int
data ViewL a
EmptyL :: ViewL a
(:<) :: a -> Seq a -> ViewL a
instance Foldable ViewL
instance Functor ViewL
instance Traversable ViewL
instance Typeable1 ViewL
instance Data a => Data (ViewL a)
instance Eq a => Eq (ViewL a)
instance Ord a => Ord (ViewL a)
instance Read a => Read (ViewL a)
instance Show a => Show (ViewL a)
viewl :: Seq a -> ViewL a
data ViewR a
EmptyR :: ViewR a
(:>) :: Seq a -> a -> ViewR a
instance Foldable ViewR
instance Functor ViewR
instance Traversable ViewR
instance Typeable1 ViewR
instance Data a => Data (ViewR a)
instance Eq a => Eq (ViewR a)
instance Ord a => Ord (ViewR a)
instance Read a => Read (ViewR a)
instance Show a => Show (ViewR a)
viewr :: Seq a -> ViewR a
index :: Seq a -> Int -> a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
update :: Int -> a -> Seq a -> Seq a
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
reverse :: Seq a -> Seq a

module Data.Tree
data Tree a
Node :: a -> Forest a -> Tree a
rootLabel :: Tree a -> a
subForest :: Tree a -> Forest a
instance Applicative Tree
instance Foldable Tree
instance Functor Tree
instance Monad Tree
instance Traversable Tree
instance Typeable1 Tree
instance Data a => Data (Tree a)
instance Eq a => Eq (Tree a)
instance Read a => Read (Tree a)
instance Show a => Show (Tree a)
type Forest a = [Tree a]
drawTree :: Tree String -> String
drawForest :: Forest String -> String
flatten :: Tree a -> [a]
levels :: Tree a -> [[a]]
unfoldTree :: (b -> (a, [b])) -> b -> Tree a
unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)

module Data.Map
data Map k a
instance Typeable2 Map
instance Foldable (Map k)
instance Functor (Map k)
instance Traversable (Map k)
instance (Data k, Data a, Ord k) => Data (Map k a)
instance (Eq k, Eq a) => Eq (Map k a)
instance Ord k => Monoid (Map k v)
instance (Ord k, Ord v) => Ord (Map k v)
instance (Ord k, Read k, Read e) => Read (Map k e)
instance (Show k, Show a) => Show (Map k a)
(!) :: Ord k => Map k a -> k -> a
(\\) :: Ord k => Map k a -> Map k b -> Map k a
null :: Map k a -> Bool
size :: Map k a -> Int
member :: Ord k => k -> Map k a -> Bool
notMember :: Ord k => k -> Map k a -> Bool
lookup :: (Monad m, Ord k) => k -> Map k a -> m a
findWithDefault :: Ord k => a -> k -> Map k a -> a
empty :: Map k a
singleton :: k -> a -> Map k a
insert :: Ord k => k -> a -> Map k a -> Map k a
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey' :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
delete :: Ord k => k -> Map k a -> Map k a
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
union :: Ord k => Map k a -> Map k a -> Map k a
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
unions :: Ord k => [Map k a] -> Map k a
unionsWith :: Ord k => (a -> a -> a) -> [Map k a] -> Map k a
difference :: Ord k => Map k a -> Map k b -> Map k a
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
intersection :: Ord k => Map k a -> Map k b -> Map k a
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
map :: (a -> b) -> Map k a -> Map k b
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
fold :: (a -> b -> b) -> b -> Map k a -> b
foldWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
elems :: Map k a -> [a]
keys :: Map k a -> [k]
keysSet :: Map k a -> Set k
assocs :: Map k a -> [(k, a)]
toList :: Map k a -> [(k, a)]
fromList :: Ord k => [(k, a)] -> Map k a
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
toAscList :: Map k a -> [(k, a)]
fromAscList :: Eq k => [(k, a)] -> Map k a
fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctAscList :: [(k, a)] -> Map k a
filter :: Ord k => (a -> Bool) -> Map k a -> Map k a
filterWithKey :: Ord k => (k -> a -> Bool) -> Map k a -> Map k a
partition :: Ord k => (a -> Bool) -> Map k a -> (Map k a, Map k a)
partitionWithKey :: Ord k => (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
mapMaybeWithKey :: Ord k => (k -> a -> Maybe b) -> Map k a -> Map k b
mapEither :: Ord k => (a -> Either b c) -> Map k a -> (Map k b, Map k c)
mapEitherWithKey :: Ord k => (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
split :: Ord k => k -> Map k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
isProperSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
findIndex :: Ord k => k -> Map k a -> Int
elemAt :: Int -> Map k a -> (k, a)
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
deleteAt :: Int -> Map k a -> Map k a
findMin :: Map k a -> (k, a)
findMax :: Map k a -> (k, a)
deleteMin :: Map k a -> Map k a
deleteMax :: Map k a -> Map k a
deleteFindMin :: Map k a -> ((k, a), Map k a)
deleteFindMax :: Map k a -> ((k, a), Map k a)
updateMin :: (a -> Maybe a) -> Map k a -> Map k a
updateMax :: (a -> Maybe a) -> Map k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
minView :: Monad m => Map k a -> m (a, Map k a)
maxView :: Monad m => Map k a -> m (a, Map k a)
minViewWithKey :: Monad m => Map k a -> m ((k, a), Map k a)
maxViewWithKey :: Monad m => Map k a -> m ((k, a), Map k a)
showTree :: (Show k, Show a) => Map k a -> String
showTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String
valid :: Ord k => Map k a -> Bool

module Data.IntSet
data IntSet
instance Data IntSet
instance Eq IntSet
instance Monoid IntSet
instance Ord IntSet
instance Read IntSet
instance Show IntSet
instance Typeable IntSet
(\\) :: IntSet -> IntSet -> IntSet
null :: IntSet -> Bool
size :: IntSet -> Int
member :: Int -> IntSet -> Bool
notMember :: Int -> IntSet -> Bool
isSubsetOf :: IntSet -> IntSet -> Bool
isProperSubsetOf :: IntSet -> IntSet -> Bool
empty :: IntSet
singleton :: Int -> IntSet
insert :: Int -> IntSet -> IntSet
delete :: Int -> IntSet -> IntSet
union :: IntSet -> IntSet -> IntSet
unions :: [IntSet] -> IntSet
difference :: IntSet -> IntSet -> IntSet
intersection :: IntSet -> IntSet -> IntSet
filter :: (Int -> Bool) -> IntSet -> IntSet
partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
split :: Int -> IntSet -> (IntSet, IntSet)
splitMember :: Int -> IntSet -> (IntSet, Bool, IntSet)
findMin :: IntSet -> Int
findMax :: IntSet -> Int
deleteMin :: IntSet -> IntSet
deleteMax :: IntSet -> IntSet
deleteFindMin :: IntSet -> (Int, IntSet)
deleteFindMax :: IntSet -> (Int, IntSet)
maxView :: Monad m => IntSet -> m (Int, IntSet)
minView :: Monad m => IntSet -> m (Int, IntSet)
map :: (Int -> Int) -> IntSet -> IntSet
fold :: (Int -> b -> b) -> b -> IntSet -> b
elems :: IntSet -> [Int]
toList :: IntSet -> [Int]
fromList :: [Int] -> IntSet
toAscList :: IntSet -> [Int]
fromAscList :: [Int] -> IntSet
fromDistinctAscList :: [Int] -> IntSet
showTree :: IntSet -> String
showTreeWith :: Bool -> Bool -> IntSet -> String

module Data.IntMap
data IntMap a
instance Foldable IntMap
instance Functor IntMap
instance Typeable1 IntMap
instance Data a => Data (IntMap a)
instance Eq a => Eq (IntMap a)
instance Monoid (IntMap a)
instance Ord a => Ord (IntMap a)
instance Read e => Read (IntMap e)
instance Show a => Show (IntMap a)
type Key = Int
(!) :: IntMap a -> Key -> a
(\\) :: IntMap a -> IntMap b -> IntMap a
null :: IntMap a -> Bool
size :: IntMap a -> Int
member :: Key -> IntMap a -> Bool
notMember :: Key -> IntMap a -> Bool
lookup :: Monad m => Key -> IntMap a -> m a
findWithDefault :: a -> Key -> IntMap a -> a
empty :: IntMap a
singleton :: Key -> a -> IntMap a
insert :: Key -> a -> IntMap a -> IntMap a
insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
delete :: Key -> IntMap a -> IntMap a
adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
adjustWithKey :: (Key -> a -> a) -> Key -> IntMap a -> IntMap a
update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
union :: IntMap a -> IntMap a -> IntMap a
unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unions :: [IntMap a] -> IntMap a
unionsWith :: (a -> a -> a) -> [IntMap a] -> IntMap a
difference :: IntMap a -> IntMap b -> IntMap a
differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
differenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
intersection :: IntMap a -> IntMap b -> IntMap a
intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
map :: (a -> b) -> IntMap a -> IntMap b
mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
fold :: (a -> b -> b) -> b -> IntMap a -> b
foldWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
elems :: IntMap a -> [a]
keys :: IntMap a -> [Key]
keysSet :: IntMap a -> IntSet
assocs :: IntMap a -> [(Key, a)]
toList :: IntMap a -> [(Key, a)]
fromList :: [(Key, a)] -> IntMap a
fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
toAscList :: IntMap a -> [(Key, a)]
fromAscList :: [(Key, a)] -> IntMap a
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
fromDistinctAscList :: [(Key, a)] -> IntMap a
filter :: (a -> Bool) -> IntMap a -> IntMap a
filterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a
partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
partitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
mapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b
mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
mapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
split :: Key -> IntMap a -> (IntMap a, IntMap a)
splitLookup :: Key -> IntMap a -> (IntMap a, Maybe a, IntMap a)
isSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
updateMin :: (a -> a) -> IntMap a -> IntMap a
updateMax :: (a -> a) -> IntMap a -> IntMap a
updateMinWithKey :: (Key -> a -> a) -> IntMap a -> IntMap a
updateMaxWithKey :: (Key -> a -> a) -> IntMap a -> IntMap a
minViewWithKey :: Monad m => IntMap a -> m ((Key, a), IntMap a)
maxViewWithKey :: Monad m => IntMap a -> m ((Key, a), IntMap a)
showTree :: Show a => IntMap a -> String
showTreeWith :: Show a => Bool -> Bool -> IntMap a -> String

module Data.Graph
stronglyConnComp :: Ord key => [(node, key, [key])] -> [SCC node]
stronglyConnCompR :: Ord key => [(node, key, [key])] -> [SCC (node, key, [key])]
data SCC vertex
AcyclicSCC :: vertex -> SCC vertex
CyclicSCC :: [vertex] -> SCC vertex
flattenSCC :: SCC vertex -> [vertex]
flattenSCCs :: [SCC a] -> [a]
type Graph = Table [Vertex]
type Table a = Array Vertex a
type Bounds = (Vertex, Vertex)
type Edge = (Vertex, Vertex)
type Vertex = Int
graphFromEdges :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)
graphFromEdges' :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]))
buildG :: Bounds -> [Edge] -> Graph
transposeG :: Graph -> Graph
vertices :: Graph -> [Vertex]
edges :: Graph -> [Edge]
outdegree :: Graph -> Table Int
indegree :: Graph -> Table Int
dfs :: Graph -> [Vertex] -> Forest Vertex
dff :: Graph -> Forest Vertex
topSort :: Graph -> [Vertex]
components :: Graph -> Forest Vertex
scc :: Graph -> Forest Vertex
bcc :: Graph -> Forest [Vertex]
reachable :: Graph -> Vertex -> [Vertex]
path :: Graph -> Vertex -> Vertex -> Bool
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module System.Directory
createDirectory :: FilePath -> IO ()
createDirectoryIfMissing :: Bool -> FilePath -> IO ()
removeDirectory :: FilePath -> IO ()
removeDirectoryRecursive :: FilePath -> IO ()
renameDirectory :: FilePath -> FilePath -> IO ()
getDirectoryContents :: FilePath -> IO [FilePath]
getCurrentDirectory :: IO FilePath
setCurrentDirectory :: FilePath -> IO ()
getHomeDirectory :: IO FilePath
getAppUserDataDirectory :: String -> IO FilePath
getUserDocumentsDirectory :: IO FilePath
getTemporaryDirectory :: IO FilePath
removeFile :: FilePath -> IO ()
renameFile :: FilePath -> FilePath -> IO ()
copyFile :: FilePath -> FilePath -> IO ()
canonicalizePath :: FilePath -> IO FilePath
makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
findExecutable :: String -> IO (Maybe FilePath)
doesFileExist :: FilePath -> IO Bool
doesDirectoryExist :: FilePath -> IO Bool
data Permissions
Permissions :: Bool -> Bool -> Bool -> Bool -> Permissions
readable :: Permissions -> Bool
writable :: Permissions -> Bool
executable :: Permissions -> Bool
searchable :: Permissions -> Bool
instance Eq Permissions
instance Ord Permissions
instance Read Permissions
instance Show Permissions
getPermissions :: FilePath -> IO Permissions
setPermissions :: FilePath -> Permissions -> IO ()
getModificationTime :: FilePath -> IO ClockTime
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module System.FilePath.Windows
pathSeparator :: Char
pathSeparators :: [Char]
isPathSeparator :: Char -> Bool
searchPathSeparator :: Char
isSearchPathSeparator :: Char -> Bool
extSeparator :: Char
isExtSeparator :: Char -> Bool
splitSearchPath :: String -> [FilePath]
getSearchPath :: IO [FilePath]
splitExtension :: FilePath -> (String, String)
takeExtension :: FilePath -> String
replaceExtension :: FilePath -> String -> FilePath
dropExtension :: FilePath -> FilePath
addExtension :: FilePath -> String -> FilePath
hasExtension :: FilePath -> Bool
(<.>) :: FilePath -> String -> FilePath
splitExtensions :: FilePath -> (FilePath, String)
dropExtensions :: FilePath -> FilePath
takeExtensions :: FilePath -> String
splitDrive :: FilePath -> (FilePath, FilePath)
joinDrive :: FilePath -> FilePath -> FilePath
takeDrive :: FilePath -> FilePath
hasDrive :: FilePath -> Bool
dropDrive :: FilePath -> FilePath
isDrive :: FilePath -> Bool
splitFileName :: FilePath -> (String, String)
takeFileName :: FilePath -> FilePath
replaceFileName :: FilePath -> String -> FilePath
dropFileName :: FilePath -> FilePath
takeBaseName :: FilePath -> String
replaceBaseName :: FilePath -> String -> FilePath
takeDirectory :: FilePath -> FilePath
replaceDirectory :: FilePath -> String -> FilePath
combine :: FilePath -> FilePath -> FilePath
(</>) :: FilePath -> FilePath -> FilePath
splitPath :: FilePath -> [FilePath]
joinPath :: [FilePath] -> FilePath
splitDirectories :: FilePath -> [FilePath]
hasTrailingPathSeparator :: FilePath -> Bool
addTrailingPathSeparator :: FilePath -> FilePath
dropTrailingPathSeparator :: FilePath -> FilePath
normalise :: FilePath -> FilePath
equalFilePath :: FilePath -> FilePath -> Bool
makeRelative :: FilePath -> FilePath -> FilePath
isRelative :: FilePath -> Bool
isAbsolute :: FilePath -> Bool
isValid :: FilePath -> Bool
makeValid :: FilePath -> FilePath

module System.FilePath.Posix
pathSeparator :: Char
pathSeparators :: [Char]
isPathSeparator :: Char -> Bool
searchPathSeparator :: Char
isSearchPathSeparator :: Char -> Bool
extSeparator :: Char
isExtSeparator :: Char -> Bool
splitSearchPath :: String -> [FilePath]
getSearchPath :: IO [FilePath]
splitExtension :: FilePath -> (String, String)
takeExtension :: FilePath -> String
replaceExtension :: FilePath -> String -> FilePath
dropExtension :: FilePath -> FilePath
addExtension :: FilePath -> String -> FilePath
hasExtension :: FilePath -> Bool
(<.>) :: FilePath -> String -> FilePath
splitExtensions :: FilePath -> (FilePath, String)
dropExtensions :: FilePath -> FilePath
takeExtensions :: FilePath -> String
splitDrive :: FilePath -> (FilePath, FilePath)
joinDrive :: FilePath -> FilePath -> FilePath
takeDrive :: FilePath -> FilePath
hasDrive :: FilePath -> Bool
dropDrive :: FilePath -> FilePath
isDrive :: FilePath -> Bool
splitFileName :: FilePath -> (String, String)
takeFileName :: FilePath -> FilePath
replaceFileName :: FilePath -> String -> FilePath
dropFileName :: FilePath -> FilePath
takeBaseName :: FilePath -> String
replaceBaseName :: FilePath -> String -> FilePath
takeDirectory :: FilePath -> FilePath
replaceDirectory :: FilePath -> String -> FilePath
combine :: FilePath -> FilePath -> FilePath
(</>) :: FilePath -> FilePath -> FilePath
splitPath :: FilePath -> [FilePath]
joinPath :: [FilePath] -> FilePath
splitDirectories :: FilePath -> [FilePath]
hasTrailingPathSeparator :: FilePath -> Bool
addTrailingPathSeparator :: FilePath -> FilePath
dropTrailingPathSeparator :: FilePath -> FilePath
normalise :: FilePath -> FilePath
equalFilePath :: FilePath -> FilePath -> Bool
makeRelative :: FilePath -> FilePath -> FilePath
isRelative :: FilePath -> Bool
isAbsolute :: FilePath -> Bool
isValid :: FilePath -> Bool
makeValid :: FilePath -> FilePath

module System.FilePath
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Language.Haskell.Syntax
data HsModule
HsModule :: SrcLoc -> Module -> Maybe [HsExportSpec] -> [HsImportDecl] -> [HsDecl] -> HsModule
instance Data HsModule
instance Pretty HsModule
instance Show HsModule
instance Typeable HsModule
data HsExportSpec
HsEVar :: HsQName -> HsExportSpec
HsEAbs :: HsQName -> HsExportSpec
HsEThingAll :: HsQName -> HsExportSpec
HsEThingWith :: HsQName -> [HsCName] -> HsExportSpec
HsEModuleContents :: Module -> HsExportSpec
instance Data HsExportSpec
instance Eq HsExportSpec
instance Pretty HsExportSpec
instance Show HsExportSpec
instance Typeable HsExportSpec
data HsImportDecl
HsImportDecl :: SrcLoc -> Module -> Bool -> Maybe Module -> Maybe (Bool, [HsImportSpec]) -> HsImportDecl
importLoc :: HsImportDecl -> SrcLoc
importModule :: HsImportDecl -> Module
importQualified :: HsImportDecl -> Bool
importAs :: HsImportDecl -> Maybe Module
importSpecs :: HsImportDecl -> Maybe (Bool, [HsImportSpec])
instance Data HsImportDecl
instance Eq HsImportDecl
instance Pretty HsImportDecl
instance Show HsImportDecl
instance Typeable HsImportDecl
data HsImportSpec
HsIVar :: HsName -> HsImportSpec
HsIAbs :: HsName -> HsImportSpec
HsIThingAll :: HsName -> HsImportSpec
HsIThingWith :: HsName -> [HsCName] -> HsImportSpec
instance Data HsImportSpec
instance Eq HsImportSpec
instance Pretty HsImportSpec
instance Show HsImportSpec
instance Typeable HsImportSpec
data HsAssoc
HsAssocNone :: HsAssoc
HsAssocLeft :: HsAssoc
HsAssocRight :: HsAssoc
instance Data HsAssoc
instance Eq HsAssoc
instance Pretty HsAssoc
instance Show HsAssoc
instance Typeable HsAssoc
data HsDecl
HsTypeDecl :: SrcLoc -> HsName -> [HsName] -> HsType -> HsDecl
HsDataDecl :: SrcLoc -> HsContext -> HsName -> [HsName] -> [HsConDecl] -> [HsQName] -> HsDecl
HsInfixDecl :: SrcLoc -> HsAssoc -> Int -> [HsOp] -> HsDecl
HsNewTypeDecl :: SrcLoc -> HsContext -> HsName -> [HsName] -> HsConDecl -> [HsQName] -> HsDecl
HsClassDecl :: SrcLoc -> HsContext -> HsName -> [HsName] -> [HsDecl] -> HsDecl
HsInstDecl :: SrcLoc -> HsContext -> HsQName -> [HsType] -> [HsDecl] -> HsDecl
HsDefaultDecl :: SrcLoc -> [HsType] -> HsDecl
HsTypeSig :: SrcLoc -> [HsName] -> HsQualType -> HsDecl
HsFunBind :: [HsMatch] -> HsDecl
HsPatBind :: SrcLoc -> HsPat -> HsRhs -> [HsDecl] -> HsDecl
HsForeignImport :: SrcLoc -> String -> HsSafety -> String -> HsName -> HsType -> HsDecl
HsForeignExport :: SrcLoc -> String -> String -> HsName -> HsType -> HsDecl
instance Data HsDecl
instance Eq HsDecl
instance Pretty HsDecl
instance Show HsDecl
instance Typeable HsDecl
data HsConDecl
HsConDecl :: SrcLoc -> HsName -> [HsBangType] -> HsConDecl
HsRecDecl :: SrcLoc -> HsName -> [([HsName], HsBangType)] -> HsConDecl
instance Data HsConDecl
instance Eq HsConDecl
instance Pretty HsConDecl
instance Show HsConDecl
instance Typeable HsConDecl
data HsBangType
HsBangedTy :: HsType -> HsBangType
HsUnBangedTy :: HsType -> HsBangType
instance Data HsBangType
instance Eq HsBangType
instance Pretty HsBangType
instance Show HsBangType
instance Typeable HsBangType
data HsMatch
HsMatch :: SrcLoc -> HsName -> [HsPat] -> HsRhs -> [HsDecl] -> HsMatch
instance Data HsMatch
instance Eq HsMatch
instance Pretty HsMatch
instance Show HsMatch
instance Typeable HsMatch
data HsRhs
HsUnGuardedRhs :: HsExp -> HsRhs
HsGuardedRhss :: [HsGuardedRhs] -> HsRhs
instance Data HsRhs
instance Eq HsRhs
instance Pretty HsRhs
instance Show HsRhs
instance Typeable HsRhs
data HsGuardedRhs
HsGuardedRhs :: SrcLoc -> HsExp -> HsExp -> HsGuardedRhs
instance Data HsGuardedRhs
instance Eq HsGuardedRhs
instance Pretty HsGuardedRhs
instance Show HsGuardedRhs
instance Typeable HsGuardedRhs
data HsSafety
HsSafe :: HsSafety
HsUnsafe :: HsSafety
instance Data HsSafety
instance Eq HsSafety
instance Ord HsSafety
instance Pretty HsSafety
instance Show HsSafety
instance Typeable HsSafety
data HsQualType
HsQualType :: HsContext -> HsType -> HsQualType
instance Data HsQualType
instance Eq HsQualType
instance Pretty HsQualType
instance Show HsQualType
instance Typeable HsQualType
type HsContext = [HsAsst]
type HsAsst = (HsQName, [HsType])
data HsType
HsTyFun :: HsType -> HsType -> HsType
HsTyTuple :: [HsType] -> HsType
HsTyApp :: HsType -> HsType -> HsType
HsTyVar :: HsName -> HsType
HsTyCon :: HsQName -> HsType
instance Data HsType
instance Eq HsType
instance Pretty HsType
instance Show HsType
instance Typeable HsType
data HsExp
HsVar :: HsQName -> HsExp
HsCon :: HsQName -> HsExp
HsLit :: HsLiteral -> HsExp
HsInfixApp :: HsExp -> HsQOp -> HsExp -> HsExp
HsApp :: HsExp -> HsExp -> HsExp
HsNegApp :: HsExp -> HsExp
HsLambda :: SrcLoc -> [HsPat] -> HsExp -> HsExp
HsLet :: [HsDecl] -> HsExp -> HsExp
HsIf :: HsExp -> HsExp -> HsExp -> HsExp
HsCase :: HsExp -> [HsAlt] -> HsExp
HsDo :: [HsStmt] -> HsExp
HsTuple :: [HsExp] -> HsExp
HsList :: [HsExp] -> HsExp
HsParen :: HsExp -> HsExp
HsLeftSection :: HsExp -> HsQOp -> HsExp
HsRightSection :: HsQOp -> HsExp -> HsExp
HsRecConstr :: HsQName -> [HsFieldUpdate] -> HsExp
HsRecUpdate :: HsExp -> [HsFieldUpdate] -> HsExp
HsEnumFrom :: HsExp -> HsExp
HsEnumFromTo :: HsExp -> HsExp -> HsExp
HsEnumFromThen :: HsExp -> HsExp -> HsExp
HsEnumFromThenTo :: HsExp -> HsExp -> HsExp -> HsExp
HsListComp :: HsExp -> [HsStmt] -> HsExp
HsExpTypeSig :: SrcLoc -> HsExp -> HsQualType -> HsExp
HsAsPat :: HsName -> HsExp -> HsExp
HsWildCard :: HsExp
HsIrrPat :: HsExp -> HsExp
instance Data HsExp
instance Eq HsExp
instance Pretty HsExp
instance Show HsExp
instance Typeable HsExp
data HsStmt
HsGenerator :: SrcLoc -> HsPat -> HsExp -> HsStmt
HsQualifier :: HsExp -> HsStmt
HsLetStmt :: [HsDecl] -> HsStmt
instance Data HsStmt
instance Eq HsStmt
instance Pretty HsStmt
instance Show HsStmt
instance Typeable HsStmt
data HsFieldUpdate
HsFieldUpdate :: HsQName -> HsExp -> HsFieldUpdate
instance Data HsFieldUpdate
instance Eq HsFieldUpdate
instance Pretty HsFieldUpdate
instance Show HsFieldUpdate
instance Typeable HsFieldUpdate
data HsAlt
HsAlt :: SrcLoc -> HsPat -> HsGuardedAlts -> [HsDecl] -> HsAlt
instance Data HsAlt
instance Eq HsAlt
instance Pretty HsAlt
instance Show HsAlt
instance Typeable HsAlt
data HsGuardedAlts
HsUnGuardedAlt :: HsExp -> HsGuardedAlts
HsGuardedAlts :: [HsGuardedAlt] -> HsGuardedAlts
instance Data HsGuardedAlts
instance Eq HsGuardedAlts
instance Pretty HsGuardedAlts
instance Show HsGuardedAlts
instance Typeable HsGuardedAlts
data HsGuardedAlt
HsGuardedAlt :: SrcLoc -> HsExp -> HsExp -> HsGuardedAlt
instance Data HsGuardedAlt
instance Eq HsGuardedAlt
instance Pretty HsGuardedAlt
instance Show HsGuardedAlt
instance Typeable HsGuardedAlt
data HsPat
HsPVar :: HsName -> HsPat
HsPLit :: HsLiteral -> HsPat
HsPNeg :: HsPat -> HsPat
HsPInfixApp :: HsPat -> HsQName -> HsPat -> HsPat
HsPApp :: HsQName -> [HsPat] -> HsPat
HsPTuple :: [HsPat] -> HsPat
HsPList :: [HsPat] -> HsPat
HsPParen :: HsPat -> HsPat
HsPRec :: HsQName -> [HsPatField] -> HsPat
HsPAsPat :: HsName -> HsPat -> HsPat
HsPWildCard :: HsPat
HsPIrrPat :: HsPat -> HsPat
instance Data HsPat
instance Eq HsPat
instance Pretty HsPat
instance Show HsPat
instance Typeable HsPat
data HsPatField
HsPFieldPat :: HsQName -> HsPat -> HsPatField
instance Data HsPatField
instance Eq HsPatField
instance Pretty HsPatField
instance Show HsPatField
instance Typeable HsPatField
data HsLiteral
HsChar :: Char -> HsLiteral
HsString :: String -> HsLiteral
HsInt :: Integer -> HsLiteral
HsFrac :: Rational -> HsLiteral
HsCharPrim :: Char -> HsLiteral
HsStringPrim :: String -> HsLiteral
HsIntPrim :: Integer -> HsLiteral
HsFloatPrim :: Rational -> HsLiteral
HsDoublePrim :: Rational -> HsLiteral
instance Data HsLiteral
instance Eq HsLiteral
instance Pretty HsLiteral
instance Show HsLiteral
instance Typeable HsLiteral
newtype Module
Module :: String -> Module
instance Data Module
instance Eq Module
instance Ord Module
instance Pretty Module
instance Show Module
instance Typeable Module
data HsQName
Qual :: Module -> HsName -> HsQName
UnQual :: HsName -> HsQName
Special :: HsSpecialCon -> HsQName
instance Data HsQName
instance Eq HsQName
instance Ord HsQName
instance Pretty HsQName
instance Show HsQName
instance Typeable HsQName
data HsName
HsIdent :: String -> HsName
HsSymbol :: String -> HsName
instance Data HsName
instance Eq HsName
instance Ord HsName
instance Pretty HsName
instance Show HsName
instance Typeable HsName
data HsQOp
HsQVarOp :: HsQName -> HsQOp
HsQConOp :: HsQName -> HsQOp
instance Data HsQOp
instance Eq HsQOp
instance Ord HsQOp
instance Pretty HsQOp
instance Show HsQOp
instance Typeable HsQOp
data HsOp
HsVarOp :: HsName -> HsOp
HsConOp :: HsName -> HsOp
instance Data HsOp
instance Eq HsOp
instance Ord HsOp
instance Pretty HsOp
instance Show HsOp
instance Typeable HsOp
data HsSpecialCon
HsUnitCon :: HsSpecialCon
HsListCon :: HsSpecialCon
HsFunCon :: HsSpecialCon
HsTupleCon :: Int -> HsSpecialCon
HsCons :: HsSpecialCon
instance Data HsSpecialCon
instance Eq HsSpecialCon
instance Ord HsSpecialCon
instance Show HsSpecialCon
instance Typeable HsSpecialCon
data HsCName
HsVarName :: HsName -> HsCName
HsConName :: HsName -> HsCName
instance Data HsCName
instance Eq HsCName
instance Ord HsCName
instance Pretty HsCName
instance Show HsCName
instance Typeable HsCName
prelude_mod :: Module
main_mod :: Module
main_name :: HsName
unit_con_name :: HsQName
tuple_con_name :: Int -> HsQName
list_cons_name :: HsQName
unit_con :: HsExp
tuple_con :: Int -> HsExp
unit_tycon_name :: HsQName
fun_tycon_name :: HsQName
list_tycon_name :: HsQName
tuple_tycon_name :: Int -> HsQName
unit_tycon :: HsType
fun_tycon :: HsType
list_tycon :: HsType
tuple_tycon :: Int -> HsType
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
srcFilename :: SrcLoc -> String
srcLine :: SrcLoc -> Int
srcColumn :: SrcLoc -> Int
instance Data SrcLoc
instance Eq SrcLoc
instance Ord SrcLoc
instance Show SrcLoc
instance Typeable SrcLoc

module Language.Haskell.Pretty
class Pretty a
instance Pretty HsAlt
instance Pretty HsAssoc
instance Pretty HsBangType
instance Pretty HsCName
instance Pretty HsConDecl
instance Pretty HsDecl
instance Pretty HsExp
instance Pretty HsExportSpec
instance Pretty HsFieldUpdate
instance Pretty HsGuardedAlt
instance Pretty HsGuardedAlts
instance Pretty HsGuardedRhs
instance Pretty HsImportDecl
instance Pretty HsImportSpec
instance Pretty HsLiteral
instance Pretty HsMatch
instance Pretty HsModule
instance Pretty HsName
instance Pretty HsOp
instance Pretty HsPat
instance Pretty HsPatField
instance Pretty HsQName
instance Pretty HsQOp
instance Pretty HsQualType
instance Pretty HsRhs
instance Pretty HsSafety
instance Pretty HsStmt
instance Pretty HsType
instance Pretty Module
prettyPrintStyleMode :: Pretty a => Style -> PPHsMode -> a -> String
prettyPrintWithMode :: Pretty a => PPHsMode -> a -> String
prettyPrint :: Pretty a => a -> String
data PPHsMode
PPHsMode :: Indent -> Indent -> Indent -> Indent -> Indent -> Indent -> Bool -> PPLayout -> Bool -> Bool -> PPHsMode
classIndent :: PPHsMode -> Indent
doIndent :: PPHsMode -> Indent
caseIndent :: PPHsMode -> Indent
letIndent :: PPHsMode -> Indent
whereIndent :: PPHsMode -> Indent
onsideIndent :: PPHsMode -> Indent
spacing :: PPHsMode -> Bool
layout :: PPHsMode -> PPLayout
linePragmas :: PPHsMode -> Bool
comments :: PPHsMode -> Bool
type Indent = Int
data PPLayout
PPOffsideRule :: PPLayout
PPSemiColon :: PPLayout
PPInLine :: PPLayout
PPNoLayout :: PPLayout
instance Eq PPLayout
defaultMode :: PPHsMode

module Language.Haskell.Parser
parseModule :: String -> ParseResult HsModule
parseModuleWithMode :: ParseMode -> String -> ParseResult HsModule
data ParseMode
ParseMode :: String -> ParseMode
parseFilename :: ParseMode -> String
defaultParseMode :: ParseMode
data ParseResult a
ParseOk :: a -> ParseResult a
ParseFailed :: SrcLoc -> String -> ParseResult a
instance Show a => Show (ParseResult a)
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Control.Monad.Writer.Class
class (Monoid w, Monad m) => MonadWriter w m
tell :: MonadWriter w m => w -> m ()
listen :: MonadWriter w m => m a -> m (a, w)
pass :: MonadWriter w m => m (a, w -> w) -> m a
instance Monoid w => MonadWriter w (Writer w)
instance Monoid w => MonadWriter w (Writer w)
instance (Error e, MonadWriter w m) => MonadWriter w (ErrorT e m)
instance MonadWriter w m => MonadWriter w (ReaderT r m)
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadWriter w m => MonadWriter w (StateT s m)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance Monoid w => MonadWriter w (RWS r w s)
instance Monoid w => MonadWriter w (RWS r w s)
instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m)
instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m)
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
censor :: MonadWriter w m => (w -> w) -> m a -> m a

module Control.Monad.Trans
class MonadTrans t
lift :: (MonadTrans t, Monad m) => m a -> t m a
instance MonadTrans ListT
instance MonadTrans (ContT r)
instance Error e => MonadTrans (ErrorT e)
instance MonadTrans (ReaderT r)
instance MonadTrans (StateT s)
instance MonadTrans (StateT s)
instance Monoid w => MonadTrans (WriterT w)
instance Monoid w => MonadTrans (WriterT w)
instance Monoid w => MonadTrans (RWST r w s)
instance Monoid w => MonadTrans (RWST r w s)
class Monad m => MonadIO m
liftIO :: MonadIO m => IO a -> m a
instance MonadIO IO
instance MonadIO m => MonadIO (ListT m)
instance MonadIO m => MonadIO (ContT r m)
instance (Error e, MonadIO m) => MonadIO (ErrorT e m)
instance MonadIO m => MonadIO (ReaderT r m)
instance MonadIO m => MonadIO (StateT s m)
instance MonadIO m => MonadIO (StateT s m)
instance (Monoid w, MonadIO m) => MonadIO (WriterT w m)
instance (Monoid w, MonadIO m) => MonadIO (WriterT w m)
instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m)
instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m)

module Control.Monad.State.Class
class Monad m => MonadState s m
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()
instance MonadState s m => MonadState s (ListT m)
instance MonadState s (State s)
instance MonadState s (State s)
instance MonadState s m => MonadState s (ContT r m)
instance (Error e, MonadState s m) => MonadState s (ErrorT e m)
instance MonadState s m => MonadState s (ReaderT r m)
instance Monad m => MonadState s (StateT s m)
instance Monad m => MonadState s (StateT s m)
instance (Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance (Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance Monoid w => MonadState s (RWS r w s)
instance Monoid w => MonadState s (RWS r w s)
instance (Monoid w, Monad m) => MonadState s (RWST r w s m)
instance (Monoid w, Monad m) => MonadState s (RWST r w s m)
modify :: MonadState s m => (s -> s) -> m ()
gets :: MonadState s m => (s -> a) -> m a

module Control.Monad.Reader.Class
class Monad m => MonadReader r m
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a
instance MonadReader r (Reader r)
instance MonadReader r ((->) r)
instance MonadReader s m => MonadReader s (ListT m)
instance (Error e, MonadReader r m) => MonadReader r (ErrorT e m)
instance Monad m => MonadReader r (ReaderT r m)
instance MonadReader r m => MonadReader r (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance MonadReader r' m => MonadReader r' (ContT r m)
instance Monoid w => MonadReader r (RWS r w s)
instance Monoid w => MonadReader r (RWS r w s)
instance (Monoid w, Monad m) => MonadReader r (RWST r w s m)
instance (Monoid w, Monad m) => MonadReader r (RWST r w s m)
asks :: MonadReader r m => (r -> a) -> m a

module Control.Monad.RWS.Class
class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m) => MonadRWS r w s m
instance (Error e, MonadRWS r w s m) => MonadRWS r w s (ErrorT e m)
instance Monoid w => MonadRWS r w s (RWS r w s)
instance Monoid w => MonadRWS r w s (RWS r w s)
instance (Monoid w, Monad m) => MonadRWS r w s (RWST r w s m)
instance (Monoid w, Monad m) => MonadRWS r w s (RWST r w s m)

module Control.Monad.Identity
newtype Identity a
Identity :: a -> Identity a
runIdentity :: Identity a -> a
instance Functor Identity
instance Monad Identity
instance MonadFix Identity

module Control.Monad.Error.Class
class Error a
noMsg :: Error a => a
strMsg :: Error a => String -> a
instance Error IOError
instance Error String
class Monad m => MonadError e m
throwError :: MonadError e m => e -> m a
catchError :: MonadError e m => m a -> (e -> m a) -> m a
instance MonadError IOError IO
instance Error e => MonadError e (Either e)
instance MonadError e m => MonadError e (ListT m)
instance (Monad m, Error e) => MonadError e (ErrorT e m)
instance MonadError e m => MonadError e (ReaderT r m)
instance MonadError e m => MonadError e (StateT s m)
instance MonadError e m => MonadError e (StateT s m)
instance (Monoid w, MonadError e m) => MonadError e (WriterT w m)
instance (Monoid w, MonadError e m) => MonadError e (WriterT w m)
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)

module Control.Monad.Cont.Class
class Monad m => MonadCont m
callCC :: MonadCont m => (a -> m b -> m a) -> m a
instance MonadCont (Cont r)
instance MonadCont m => MonadCont (ListT m)
instance Monad m => MonadCont (ContT r m)
instance (Error e, MonadCont m) => MonadCont (ErrorT e m)
instance MonadCont m => MonadCont (ReaderT r m)
instance MonadCont m => MonadCont (StateT s m)
instance MonadCont m => MonadCont (StateT s m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)

module Control.Monad.Error
newtype ErrorT e m a
ErrorT :: m (Either e a) -> ErrorT e m a
runErrorT :: ErrorT e m a -> m (Either e a)
instance (Error e, MonadRWS r w s m) => MonadRWS r w s (ErrorT e m)
instance (Monad m, Error e) => MonadError e (ErrorT e m)
instance (Error e, MonadReader r m) => MonadReader r (ErrorT e m)
instance (Error e, MonadState s m) => MonadState s (ErrorT e m)
instance (Error e, MonadWriter w m) => MonadWriter w (ErrorT e m)
instance Error e => MonadTrans (ErrorT e)
instance Monad m => Functor (ErrorT e m)
instance (Monad m, Error e) => Monad (ErrorT e m)
instance (Error e, MonadCont m) => MonadCont (ErrorT e m)
instance (MonadFix m, Error e) => MonadFix (ErrorT e m)
instance (Error e, MonadIO m) => MonadIO (ErrorT e m)
instance (Monad m, Error e) => MonadPlus (ErrorT e m)
mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b

module Control.Monad.List
newtype ListT m a
ListT :: m [a] -> ListT m a
runListT :: ListT m a -> m [a]
instance MonadTrans ListT
instance MonadError e m => MonadError e (ListT m)
instance MonadReader s m => MonadReader s (ListT m)
instance MonadState s m => MonadState s (ListT m)
instance Monad m => Functor (ListT m)
instance Monad m => Monad (ListT m)
instance MonadCont m => MonadCont (ListT m)
instance MonadIO m => MonadIO (ListT m)
instance Monad m => MonadPlus (ListT m)
mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b

module Control.Monad.RWS.Lazy
newtype RWS r w s a
RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
runRWS :: RWS r w s a -> r -> s -> (a, s, w)
instance Monoid w => MonadRWS r w s (RWS r w s)
instance Monoid w => MonadReader r (RWS r w s)
instance Monoid w => MonadState s (RWS r w s)
instance Monoid w => MonadWriter w (RWS r w s)
instance Functor (RWS r w s)
instance Monoid w => Monad (RWS r w s)
instance Monoid w => MonadFix (RWS r w s)
evalRWS :: RWS r w s a -> r -> s -> (a, w)
execRWS :: RWS r w s a -> r -> s -> (s, w)
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
instance (Monoid w, Monad m) => MonadRWS r w s (RWST r w s m)
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance (Monoid w, Monad m) => MonadReader r (RWST r w s m)
instance (Monoid w, Monad m) => MonadState s (RWST r w s m)
instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m)
instance Monoid w => MonadTrans (RWST r w s)
instance Monad m => Functor (RWST r w s m)
instance (Monoid w, Monad m) => Monad (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadFix m) => MonadFix (RWST r w s m)
instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m)
instance (Monoid w, MonadPlus m) => MonadPlus (RWST r w s m)
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

module Control.Monad.RWS

module Control.Monad.RWS.Strict
newtype RWS r w s a
RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
runRWS :: RWS r w s a -> r -> s -> (a, s, w)
instance Monoid w => MonadRWS r w s (RWS r w s)
instance Monoid w => MonadReader r (RWS r w s)
instance Monoid w => MonadState s (RWS r w s)
instance Monoid w => MonadWriter w (RWS r w s)
instance Functor (RWS r w s)
instance Monoid w => Monad (RWS r w s)
instance Monoid w => MonadFix (RWS r w s)
evalRWS :: RWS r w s a -> r -> s -> (a, w)
execRWS :: RWS r w s a -> r -> s -> (s, w)
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
instance (Monoid w, Monad m) => MonadRWS r w s (RWST r w s m)
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance (Monoid w, Monad m) => MonadReader r (RWST r w s m)
instance (Monoid w, Monad m) => MonadState s (RWST r w s m)
instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m)
instance Monoid w => MonadTrans (RWST r w s)
instance Monad m => Functor (RWST r w s m)
instance (Monoid w, Monad m) => Monad (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadFix m) => MonadFix (RWST r w s m)
instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m)
instance (Monoid w, MonadPlus m) => MonadPlus (RWST r w s m)
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

module Control.Monad.Reader
newtype Reader r a
Reader :: (r -> a) -> Reader r a
runReader :: Reader r a -> r -> a
instance MonadReader r (Reader r)
instance Functor (Reader r)
instance Monad (Reader r)
instance MonadFix (Reader r)
mapReader :: (a -> b) -> Reader r a -> Reader r b
withReader :: (r' -> r) -> Reader r a -> Reader r' a
newtype ReaderT r m a
ReaderT :: (r -> m a) -> ReaderT r m a
runReaderT :: ReaderT r m a -> r -> m a
instance MonadError e m => MonadError e (ReaderT r m)
instance Monad m => MonadReader r (ReaderT r m)
instance MonadState s m => MonadState s (ReaderT r m)
instance MonadWriter w m => MonadWriter w (ReaderT r m)
instance MonadTrans (ReaderT r)
instance Monad m => Functor (ReaderT r m)
instance Monad m => Monad (ReaderT r m)
instance MonadCont m => MonadCont (ReaderT r m)
instance MonadFix m => MonadFix (ReaderT r m)
instance MonadIO m => MonadIO (ReaderT r m)
instance MonadPlus m => MonadPlus (ReaderT r m)
mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
withReaderT :: (r' -> r) -> ReaderT r m a -> ReaderT r' m a

module Control.Monad.State.Lazy
newtype State s a
State :: (s -> (a, s)) -> State s a
runState :: State s a -> s -> (a, s)
instance MonadState s (State s)
instance Functor (State s)
instance Monad (State s)
instance MonadFix (State s)
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
withState :: (s -> s) -> State s a -> State s a
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (a, s)
instance MonadError e m => MonadError e (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance Monad m => MonadState s (StateT s m)
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadTrans (StateT s)
instance Monad m => Functor (StateT s m)
instance Monad m => Monad (StateT s m)
instance MonadCont m => MonadCont (StateT s m)
instance MonadFix m => MonadFix (StateT s m)
instance MonadIO m => MonadIO (StateT s m)
instance MonadPlus m => MonadPlus (StateT s m)
evalStateT :: Monad m => StateT s m a -> s -> m a
execStateT :: Monad m => StateT s m a -> s -> m s
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
withStateT :: (s -> s) -> StateT s m a -> StateT s m a

module Control.Monad.State

module Control.Monad.State.Strict
newtype State s a
State :: (s -> (a, s)) -> State s a
runState :: State s a -> s -> (a, s)
instance MonadState s (State s)
instance Functor (State s)
instance Monad (State s)
instance MonadFix (State s)
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
withState :: (s -> s) -> State s a -> State s a
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (a, s)
instance MonadError e m => MonadError e (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance Monad m => MonadState s (StateT s m)
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadTrans (StateT s)
instance Monad m => Functor (StateT s m)
instance Monad m => Monad (StateT s m)
instance MonadCont m => MonadCont (StateT s m)
instance MonadFix m => MonadFix (StateT s m)
instance MonadIO m => MonadIO (StateT s m)
instance MonadPlus m => MonadPlus (StateT s m)
evalStateT :: Monad m => StateT s m a -> s -> m a
execStateT :: Monad m => StateT s m a -> s -> m s
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
withStateT :: (s -> s) -> StateT s m a -> StateT s m a

module Control.Monad.Writer.Lazy
newtype Writer w a
Writer :: (a, w) -> Writer w a
runWriter :: Writer w a -> (a, w)
instance Monoid w => MonadWriter w (Writer w)
instance Functor (Writer w)
instance Monoid w => Monad (Writer w)
instance Monoid w => MonadFix (Writer w)
execWriter :: Writer w a -> w
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
runWriterT :: WriterT w m a -> m (a, w)
instance (Monoid w, MonadError e m) => MonadError e (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance Monoid w => MonadTrans (WriterT w)
instance Monad m => Functor (WriterT w m)
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadFix m) => MonadFix (WriterT w m)
instance (Monoid w, MonadIO m) => MonadIO (WriterT w m)
instance (Monoid w, MonadPlus m) => MonadPlus (WriterT w m)
execWriterT :: Monad m => WriterT w m a -> m w
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b

module Control.Monad.Writer

module Control.Monad.Writer.Strict
newtype Writer w a
Writer :: (a, w) -> Writer w a
runWriter :: Writer w a -> (a, w)
instance Monoid w => MonadWriter w (Writer w)
instance Functor (Writer w)
instance Monoid w => Monad (Writer w)
instance Monoid w => MonadFix (Writer w)
execWriter :: Writer w a -> w
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
runWriterT :: WriterT w m a -> m (a, w)
instance (Monoid w, MonadError e m) => MonadError e (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance Monoid w => MonadTrans (WriterT w)
instance Monad m => Functor (WriterT w m)
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadFix m) => MonadFix (WriterT w m)
instance (Monoid w, MonadIO m) => MonadIO (WriterT w m)
instance (Monoid w, MonadPlus m) => MonadPlus (WriterT w m)
execWriterT :: Monad m => WriterT w m a -> m w
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b

module Control.Monad.Cont
newtype Cont r a
Cont :: (a -> r -> r) -> Cont r a
runCont :: Cont r a -> (a -> r) -> r
instance Functor (Cont r)
instance Monad (Cont r)
instance MonadCont (Cont r)
mapCont :: (r -> r) -> Cont r a -> Cont r a
withCont :: (b -> r -> a -> r) -> Cont r a -> Cont r b
newtype ContT r m a
ContT :: (a -> m r -> m r) -> ContT r m a
runContT :: ContT r m a -> (a -> m r) -> m r
instance MonadReader r' m => MonadReader r' (ContT r m)
instance MonadState s m => MonadState s (ContT r m)
instance MonadTrans (ContT r)
instance Monad m => Functor (ContT r m)
instance Monad m => Monad (ContT r m)
instance Monad m => MonadCont (ContT r m)
instance MonadIO m => MonadIO (ContT r m)
mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
withContT :: (b -> m r -> a -> m r) -> ContT r m a -> ContT r m b
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module System.Locale
data TimeLocale
TimeLocale :: [(String, String)] -> [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> TimeLocale
wDays :: TimeLocale -> [(String, String)]
months :: TimeLocale -> [(String, String)]
intervals :: TimeLocale -> [(String, String)]
amPm :: TimeLocale -> (String, String)
dateTimeFmt :: TimeLocale -> String
dateFmt :: TimeLocale -> String
timeFmt :: TimeLocale -> String
time12Fmt :: TimeLocale -> String
instance Eq TimeLocale
instance Ord TimeLocale
instance Show TimeLocale
defaultTimeLocale :: TimeLocale
iso8601DateFormat :: Maybe String -> String
rfc822DateFormat :: String
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module System.Time
data ClockTime
TOD :: Integer -> Integer -> ClockTime
instance Eq ClockTime
instance Ord ClockTime
instance Show ClockTime
getClockTime :: IO ClockTime
data TimeDiff
TimeDiff :: Int -> Int -> Int -> Int -> Int -> Int -> Integer -> TimeDiff
tdYear :: TimeDiff -> Int
tdMonth :: TimeDiff -> Int
tdDay :: TimeDiff -> Int
tdHour :: TimeDiff -> Int
tdMin :: TimeDiff -> Int
tdSec :: TimeDiff -> Int
tdPicosec :: TimeDiff -> Integer
instance Eq TimeDiff
instance Ord TimeDiff
instance Read TimeDiff
instance Show TimeDiff
noTimeDiff :: TimeDiff
diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
addToClockTime :: TimeDiff -> ClockTime -> ClockTime
normalizeTimeDiff :: TimeDiff -> TimeDiff
timeDiffToString :: TimeDiff -> String
formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
data CalendarTime
CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
ctYear :: CalendarTime -> Int
ctMonth :: CalendarTime -> Month
ctDay :: CalendarTime -> Int
ctHour :: CalendarTime -> Int
ctMin :: CalendarTime -> Int
ctSec :: CalendarTime -> Int
ctPicosec :: CalendarTime -> Integer
ctWDay :: CalendarTime -> Day
ctYDay :: CalendarTime -> Int
ctTZName :: CalendarTime -> String
ctTZ :: CalendarTime -> Int
ctIsDST :: CalendarTime -> Bool
instance Eq CalendarTime
instance Ord CalendarTime
instance Read CalendarTime
instance Show CalendarTime
data Month
January :: Month
February :: Month
March :: Month
April :: Month
May :: Month
June :: Month
July :: Month
August :: Month
September :: Month
October :: Month
November :: Month
December :: Month
instance Bounded Month
instance Enum Month
instance Eq Month
instance Ix Month
instance Ord Month
instance Read Month
instance Show Month
data Day
Sunday :: Day
Monday :: Day
Tuesday :: Day
Wednesday :: Day
Thursday :: Day
Friday :: Day
Saturday :: Day
instance Bounded Day
instance Enum Day
instance Eq Day
instance Ix Day
instance Ord Day
instance Read Day
instance Show Day
toCalendarTime :: ClockTime -> IO CalendarTime
toUTCTime :: ClockTime -> CalendarTime
toClockTime :: CalendarTime -> ClockTime
calendarTimeToString :: CalendarTime -> String
formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Data.PackedString
data PackedString
instance Data PackedString
instance Eq PackedString
instance Ord PackedString
instance Show PackedString
instance Typeable PackedString
packString :: String -> PackedString
unpackPS :: PackedString -> String
hPutPS :: Handle -> PackedString -> IO ()
hGetPS :: Handle -> Int -> IO PackedString
nilPS :: PackedString
consPS :: Char -> PackedString -> PackedString
headPS :: PackedString -> Char
tailPS :: PackedString -> PackedString
nullPS :: PackedString -> Bool
appendPS :: PackedString -> PackedString -> PackedString
lengthPS :: PackedString -> Int
indexPS :: PackedString -> Int -> Char
mapPS :: (Char -> Char) -> PackedString -> PackedString
filterPS :: (Char -> Bool) -> PackedString -> PackedString
reversePS :: PackedString -> PackedString
concatPS :: [PackedString] -> PackedString
elemPS :: Char -> PackedString -> Bool
substrPS :: PackedString -> Int -> Int -> PackedString
takePS :: Int -> PackedString -> PackedString
dropPS :: Int -> PackedString -> PackedString
splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
foldlPS :: (a -> Char -> a) -> a -> PackedString -> a
foldrPS :: (Char -> a -> a) -> a -> PackedString -> a
takeWhilePS :: (Char -> Bool) -> PackedString -> PackedString
dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
linesPS :: PackedString -> [PackedString]
unlinesPS :: [PackedString] -> PackedString
wordsPS :: PackedString -> [PackedString]
unwordsPS :: [PackedString] -> PackedString
splitPS :: Char -> PackedString -> [PackedString]
splitWithPS :: (Char -> Bool) -> PackedString -> [PackedString]
joinPS :: PackedString -> [PackedString] -> PackedString
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Control.Parallel
par :: a -> b -> b
pseq :: a -> b -> b

module Control.Parallel.Strategies
type Done = ()
type Strategy a = a -> Done
(>|) :: Done -> Done -> Done
(>||) :: Done -> Done -> Done
using :: a -> Strategy a -> a
demanding :: a -> Done -> a
sparking :: a -> Done -> a
r0 :: Strategy a
rwhnf :: Strategy a
class NFData a
rnf :: NFData a => Strategy a
instance NFData Bool
instance NFData Char
instance NFData Double
instance NFData Float
instance NFData Int
instance NFData Int16
instance NFData Int32
instance NFData Int64
instance NFData Int8
instance NFData IntSet
instance NFData Integer
instance NFData Word16
instance NFData Word32
instance NFData Word64
instance NFData Word8
instance NFData ()
instance (NFData a, NFData b) => NFData (a, b)
instance (NFData a, NFData b, NFData c) => NFData (a, b, c)
instance (NFData a, NFData b, NFData c, NFData d) => NFData (a, b, c, d)
instance (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5) => NFData (a1, a2, a3, a4, a5)
instance (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6) => NFData (a1, a2, a3, a4, a5, a6)
instance (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6, NFData a7) => NFData (a1, a2, a3, a4, a5, a6, a7)
instance (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6, NFData a7, NFData a8) => NFData (a1, a2, a3, a4, a5, a6, a7, a8)
instance (NFData a1, NFData a2, NFData a3, NFData a4, NFData a5, NFData a6, NFData a7, NFData a8, NFData a9) => NFData (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance (RealFloat a, NFData a) => NFData (Complex a)
instance NFData a => NFData (IntMap a)
instance NFData a => NFData (Maybe a)
instance (Integral a, NFData a) => NFData (Ratio a)
instance NFData a => NFData (Set a)
instance NFData a => NFData (Tree a)
instance NFData a => NFData [a]
instance (Ix a, NFData a, NFData b) => NFData (Array a b)
instance (NFData a, NFData b) => NFData (Assoc a b)
instance (NFData a, NFData b) => NFData (Either a b)
instance (NFData k, NFData a) => NFData (Map k a)
($|) :: (a -> b) -> Strategy a -> a -> b
($||) :: (a -> b) -> Strategy a -> a -> b
(.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
(.||) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
(-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
seqPair :: Strategy a -> Strategy b -> Strategy (a, b)
parPair :: Strategy a -> Strategy b -> Strategy (a, b)
seqTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
parTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
parList :: Strategy a -> Strategy [a]
parListN :: Integral b => b -> Strategy a -> Strategy [a]
parListNth :: Int -> Strategy a -> Strategy [a]
parListChunk :: Int -> Strategy a -> Strategy [a]
parMap :: Strategy b -> (a -> b) -> [a] -> [b]
parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
seqList :: Strategy a -> Strategy [a]
seqListN :: Integral a => a -> Strategy b -> Strategy [b]
seqListNth :: Int -> Strategy b -> Strategy [b]
parBuffer :: Int -> Strategy a -> [a] -> [a]
seqArr :: Ix b => Strategy a -> Strategy (Array b a)
parArr :: Ix b => Strategy a -> Strategy (Array b a)
sPar :: a -> Strategy b
sSeq :: a -> Strategy b
data Assoc a b
(:=) :: a -> b -> Assoc a b
instance (NFData a, NFData b) => NFData (Assoc a b)
fstPairFstList :: NFData a => Strategy [(a, b)]
force :: NFData a => a -> a
sforce :: NFData a => a -> b -> b
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Text.ParserCombinators.Parsec.Pos
type SourceName = String
type Line = Int
type Column = Int
data SourcePos
instance Eq SourcePos
instance Ord SourcePos
instance Show SourcePos
sourceLine :: SourcePos -> Line
sourceColumn :: SourcePos -> Column
sourceName :: SourcePos -> SourceName
incSourceLine :: SourcePos -> Line -> SourcePos
incSourceColumn :: SourcePos -> Column -> SourcePos
setSourceLine :: SourcePos -> Line -> SourcePos
setSourceColumn :: SourcePos -> Column -> SourcePos
setSourceName :: SourcePos -> SourceName -> SourcePos
newPos :: SourceName -> Line -> Column -> SourcePos
initialPos :: SourceName -> SourcePos
updatePosChar :: SourcePos -> Char -> SourcePos
updatePosString :: SourcePos -> String -> SourcePos

module Text.ParserCombinators.Parsec.Error
data Message
SysUnExpect :: String -> Message
UnExpect :: String -> Message
Expect :: String -> Message
Message :: String -> Message
messageString :: Message -> String
messageCompare :: Message -> Message -> Ordering
messageEq :: Message -> Message -> Bool
data ParseError
instance Show ParseError
errorPos :: ParseError -> SourcePos
errorMessages :: ParseError -> [Message]
errorIsUnknown :: ParseError -> Bool
showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
newErrorMessage :: Message -> SourcePos -> ParseError
newErrorUnknown :: SourcePos -> ParseError
addErrorMessage :: Message -> ParseError -> ParseError
setErrorPos :: SourcePos -> ParseError -> ParseError
setErrorMessage :: Message -> ParseError -> ParseError
mergeError :: ParseError -> ParseError -> ParseError

module Text.ParserCombinators.Parsec.Prim
(<?>) :: GenParser tok st a -> String -> GenParser tok st a
(<|>) :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a
type Parser a = GenParser Char () a
data GenParser tok st a
instance Functor (GenParser tok st)
instance Monad (GenParser tok st)
instance MonadPlus (GenParser tok st)
runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)
parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()
token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
tokens :: Eq tok => ([tok] -> String) -> (SourcePos -> [tok] -> SourcePos) -> [tok] -> GenParser tok st [tok]
tokenPrim :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
tokenPrimEx :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> Maybe (SourcePos -> tok -> [tok] -> st -> st) -> (tok -> Maybe a) -> GenParser tok st a
try :: GenParser tok st a -> GenParser tok st a
label :: GenParser tok st a -> String -> GenParser tok st a
labels :: GenParser tok st a -> [String] -> GenParser tok st a
unexpected :: String -> GenParser tok st a
pzero :: GenParser tok st a
many :: GenParser tok st a -> GenParser tok st [a]
skipMany :: GenParser tok st a -> GenParser tok st ()
getState :: GenParser tok st st
setState :: st -> GenParser tok st ()
updateState :: (st -> st) -> GenParser tok st ()
getPosition :: GenParser tok st SourcePos
setPosition :: SourcePos -> GenParser tok st ()
getInput :: GenParser tok st [tok]
setInput :: [tok] -> GenParser tok st ()
data State tok st
State :: [tok] -> SourcePos -> st -> State tok st
stateInput :: State tok st -> [tok]
statePos :: State tok st -> SourcePos
stateUser :: State tok st -> st
getParserState :: GenParser tok st (State tok st)
setParserState :: State tok st -> GenParser tok st (State tok st)

module Text.ParserCombinators.Parsec.Combinator
choice :: [GenParser tok st a] -> GenParser tok st a
count :: Int -> GenParser tok st a -> GenParser tok st [a]
between :: GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a
option :: a -> GenParser tok st a -> GenParser tok st a
optionMaybe :: GenParser tok st a -> GenParser tok st (Maybe a)
optional :: GenParser tok st a -> GenParser tok st ()
skipMany1 :: GenParser tok st a -> GenParser tok st ()
many1 :: GenParser tok st a -> GenParser tok st [a]
sepBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
sepBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
endBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
endBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
sepEndBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
sepEndBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
chainl :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a
chainl1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a
chainr :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a
chainr1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a
eof :: Show tok => GenParser tok st ()
notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]
lookAhead :: GenParser tok st a -> GenParser tok st a
anyToken :: Show tok => GenParser tok st tok

module Text.ParserCombinators.Parsec.Expr
data Assoc
AssocNone :: Assoc
AssocLeft :: Assoc
AssocRight :: Assoc
data Operator t st a
Infix :: GenParser t st (a -> a -> a) -> Assoc -> Operator t st a
Prefix :: GenParser t st (a -> a) -> Operator t st a
Postfix :: GenParser t st (a -> a) -> Operator t st a
type OperatorTable t st a = [[Operator t st a]]
buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a

module Text.ParserCombinators.Parsec.Char
type CharParser st a = GenParser Char st a
spaces :: CharParser st ()
space :: CharParser st Char
newline :: CharParser st Char
tab :: CharParser st Char
upper :: CharParser st Char
lower :: CharParser st Char
alphaNum :: CharParser st Char
letter :: CharParser st Char
digit :: CharParser st Char
hexDigit :: CharParser st Char
octDigit :: CharParser st Char
char :: Char -> CharParser st Char
string :: String -> CharParser st String
anyChar :: CharParser st Char
oneOf :: [Char] -> CharParser st Char
noneOf :: [Char] -> CharParser st Char
satisfy :: (Char -> Bool) -> CharParser st Char

module Text.ParserCombinators.Parsec
data ParseError
instance Show ParseError
errorPos :: ParseError -> SourcePos
data SourcePos
instance Eq SourcePos
instance Ord SourcePos
instance Show SourcePos
type SourceName = String
type Line = Int
type Column = Int
sourceName :: SourcePos -> SourceName
sourceLine :: SourcePos -> Line
sourceColumn :: SourcePos -> Column
incSourceLine :: SourcePos -> Line -> SourcePos
incSourceColumn :: SourcePos -> Column -> SourcePos
setSourceLine :: SourcePos -> Line -> SourcePos
setSourceColumn :: SourcePos -> Column -> SourcePos
setSourceName :: SourcePos -> SourceName -> SourcePos

module Text.ParserCombinators.Parsec.Perm
data PermParser tok st a
permute :: PermParser tok st a -> GenParser tok st a
(<||>) :: PermParser tok st (a -> b) -> GenParser tok st a -> PermParser tok st b
(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b
(<|?>) :: PermParser tok st (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
(<$?>) :: (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b

module Text.ParserCombinators.Parsec.Token
data LanguageDef st
LanguageDef :: String -> String -> String -> Bool -> CharParser st Char -> CharParser st Char -> CharParser st Char -> CharParser st Char -> [String] -> [String] -> Bool -> LanguageDef st
commentStart :: LanguageDef st -> String
commentEnd :: LanguageDef st -> String
commentLine :: LanguageDef st -> String
nestedComments :: LanguageDef st -> Bool
identStart :: LanguageDef st -> CharParser st Char
identLetter :: LanguageDef st -> CharParser st Char
opStart :: LanguageDef st -> CharParser st Char
opLetter :: LanguageDef st -> CharParser st Char
reservedNames :: LanguageDef st -> [String]
reservedOpNames :: LanguageDef st -> [String]
caseSensitive :: LanguageDef st -> Bool
data TokenParser st
TokenParser :: CharParser st String -> (String -> CharParser st ()) -> CharParser st String -> (String -> CharParser st ()) -> CharParser st Char -> CharParser st String -> CharParser st Integer -> CharParser st Integer -> CharParser st Double -> CharParser st (Either Integer Double) -> CharParser st Integer -> CharParser st Integer -> CharParser st Integer -> (String -> CharParser st String) -> (CharParser st a -> CharParser st a) -> CharParser st () -> (CharParser st a -> CharParser st a) -> (CharParser st a -> CharParser st a) -> (CharParser st a -> CharParser st a) -> (CharParser st a -> CharParser st a) -> (CharParser st a -> CharParser st a) -> CharParser st String -> CharParser st String -> CharParser st String -> CharParser st String -> (CharParser st a -> CharParser st [a]) -> (CharParser st a -> CharParser st [a]) -> (CharParser st a -> CharParser st [a]) -> (CharParser st a -> CharParser st [a]) -> TokenParser st
identifier :: TokenParser st -> CharParser st String
reserved :: TokenParser st -> String -> CharParser st ()
operator :: TokenParser st -> CharParser st String
reservedOp :: TokenParser st -> String -> CharParser st ()
charLiteral :: TokenParser st -> CharParser st Char
stringLiteral :: TokenParser st -> CharParser st String
natural :: TokenParser st -> CharParser st Integer
integer :: TokenParser st -> CharParser st Integer
float :: TokenParser st -> CharParser st Double
naturalOrFloat :: TokenParser st -> CharParser st (Either Integer Double)
decimal :: TokenParser st -> CharParser st Integer
hexadecimal :: TokenParser st -> CharParser st Integer
octal :: TokenParser st -> CharParser st Integer
symbol :: TokenParser st -> String -> CharParser st String
lexeme :: TokenParser st -> CharParser st a -> CharParser st a
whiteSpace :: TokenParser st -> CharParser st ()
parens :: TokenParser st -> CharParser st a -> CharParser st a
braces :: TokenParser st -> CharParser st a -> CharParser st a
angles :: TokenParser st -> CharParser st a -> CharParser st a
brackets :: TokenParser st -> CharParser st a -> CharParser st a
squares :: TokenParser st -> CharParser st a -> CharParser st a
semi :: TokenParser st -> CharParser st String
comma :: TokenParser st -> CharParser st String
colon :: TokenParser st -> CharParser st String
dot :: TokenParser st -> CharParser st String
semiSep :: TokenParser st -> CharParser st a -> CharParser st [a]
semiSep1 :: TokenParser st -> CharParser st a -> CharParser st [a]
commaSep :: TokenParser st -> CharParser st a -> CharParser st [a]
commaSep1 :: TokenParser st -> CharParser st a -> CharParser st [a]
makeTokenParser :: LanguageDef st -> TokenParser st

module Text.ParserCombinators.Parsec.Language
haskellDef :: LanguageDef st
haskell :: TokenParser st
mondrianDef :: LanguageDef st
mondrian :: TokenParser st
emptyDef :: LanguageDef st
haskellStyle :: LanguageDef st
javaStyle :: LanguageDef st
data LanguageDef st
LanguageDef :: String -> String -> String -> Bool -> CharParser st Char -> CharParser st Char -> CharParser st Char -> CharParser st Char -> [String] -> [String] -> Bool -> LanguageDef st
commentStart :: LanguageDef st -> String
commentEnd :: LanguageDef st -> String
commentLine :: LanguageDef st -> String
nestedComments :: LanguageDef st -> Bool
identStart :: LanguageDef st -> CharParser st Char
identLetter :: LanguageDef st -> CharParser st Char
opStart :: LanguageDef st -> CharParser st Char
opLetter :: LanguageDef st -> CharParser st Char
reservedNames :: LanguageDef st -> [String]
reservedOpNames :: LanguageDef st -> [String]
caseSensitive :: LanguageDef st -> Bool
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Text.PrettyPrint.HughesPJ
data Doc
instance Show Doc
char :: Char -> Doc
text :: String -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc
empty :: Doc
(<>) :: Doc -> Doc -> Doc
(<+>) :: Doc -> Doc -> Doc
hcat :: [Doc] -> Doc
hsep :: [Doc] -> Doc
($$) :: Doc -> Doc -> Doc
($+$) :: Doc -> Doc -> Doc
vcat :: [Doc] -> Doc
sep :: [Doc] -> Doc
cat :: [Doc] -> Doc
fsep :: [Doc] -> Doc
fcat :: [Doc] -> Doc
nest :: Int -> Doc -> Doc
hang :: Doc -> Int -> Doc -> Doc
punctuate :: Doc -> [Doc] -> [Doc]
isEmpty :: Doc -> Bool
render :: Doc -> String
data Style
Style :: Mode -> Int -> Float -> Style
mode :: Style -> Mode
lineLength :: Style -> Int
ribbonsPerLine :: Style -> Float
style :: Style
renderStyle :: Style -> Doc -> String
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a
data Mode
PageMode :: Mode
ZigZagMode :: Mode
LeftMode :: Mode
OneLineMode :: Mode
data TextDetails
Chr :: Char -> TextDetails
Str :: String -> TextDetails
PStr :: String -> TextDetails

module Text.PrettyPrint
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module System.Process
data ProcessHandle
runCommand :: String -> IO ProcessHandle
runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
waitForProcess :: ProcessHandle -> IO ExitCode
getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
terminateProcess :: ProcessHandle -> IO ()

module System.Cmd
system :: String -> IO ExitCode
rawSystem :: String -> [String] -> IO ExitCode
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module System.Random
class RandomGen g
next :: RandomGen g => g -> (Int, g)
split :: RandomGen g => g -> (g, g)
genRange :: RandomGen g => g -> (Int, Int)
instance RandomGen StdGen
data StdGen
instance RandomGen StdGen
instance Read StdGen
instance Show StdGen
mkStdGen :: Int -> StdGen
getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
getStdGen :: IO StdGen
setStdGen :: StdGen -> IO ()
newStdGen :: IO StdGen
class Random a
randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
random :: (Random a, RandomGen g) => g -> (a, g)
randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
randoms :: (Random a, RandomGen g) => g -> [a]
randomRIO :: Random a => (a, a) -> IO a
randomIO :: Random a => IO a
instance Random Bool
instance Random Char
instance Random Double
instance Random Float
instance Random Int
instance Random Integer
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Control.Monad.STM
check :: Bool -> STM a

module Control.Concurrent.STM.TVar

module Control.Concurrent.STM.TMVar
data TMVar a
newTMVar :: a -> STM (TMVar a)
newEmptyTMVar :: STM (TMVar a)
newTMVarIO :: a -> IO (TMVar a)
newEmptyTMVarIO :: IO (TMVar a)
takeTMVar :: TMVar a -> STM a
putTMVar :: TMVar a -> a -> STM ()
readTMVar :: TMVar a -> STM a
swapTMVar :: TMVar a -> a -> STM a
tryTakeTMVar :: TMVar a -> STM (Maybe a)
tryPutTMVar :: TMVar a -> a -> STM Bool
isEmptyTMVar :: TMVar a -> STM Bool

module Control.Concurrent.STM.TChan
data TChan a
newTChan :: STM (TChan a)
newTChanIO :: IO (TChan a)
readTChan :: TChan a -> STM a
writeTChan :: TChan a -> a -> STM ()
dupTChan :: TChan a -> STM (TChan a)
unGetTChan :: TChan a -> a -> STM ()
isEmptyTChan :: TChan a -> STM Bool

module Control.Concurrent.STM.TArray
data TArray i e
instance MArray TArray e STM

module Control.Concurrent.STM
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Language.Haskell.TH.Syntax
class (Monad m, Functor m) => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qReify :: Quasi m => Name -> m Info
qCurrentModule :: Quasi m => m String
qRunIO :: Quasi m => IO a -> m a
instance Quasi IO
instance Quasi Q
class Lift t
lift :: Lift t => t -> Q Exp
instance Lift Bool
instance Lift Char
instance Lift Int
instance Lift Integer
instance (Lift a, Lift b) => Lift (a, b)
instance (Lift a, Lift b, Lift c) => Lift (a, b, c)
instance (Lift a, Lift b, Lift c, Lift d) => Lift (a, b, c, d)
instance (Lift a, Lift b, Lift c, Lift d, Lift e) => Lift (a, b, c, d, e)
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f) => Lift (a, b, c, d, e, f)
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f, Lift g) => Lift (a, b, c, d, e, f, g)
instance Lift a => Lift (Maybe a)
instance Lift a => Lift [a]
instance (Lift a, Lift b) => Lift (Either a b)
data Q a
instance Functor Q
instance Monad Q
instance Quasi Q
runQ :: Quasi m => Q a -> m a
report :: Bool -> String -> Q ()
recover :: Q a -> Q a -> Q a
reify :: Name -> Q Info
currentModule :: Q String
runIO :: IO a -> Q a
data Name
Name :: OccName -> NameFlavour -> Name
instance Data Name
instance Eq Name
instance Ord Name
instance Ppr Name
instance Show Name
instance Typeable Name
mkName :: String -> Name
newName :: String -> Q Name
nameBase :: Name -> String
nameModule :: Name -> Maybe String
showName :: Name -> String
showName' :: NameIs -> Name -> String
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs
data Dec
FunD :: Name -> [Clause] -> Dec
ValD :: Pat -> Body -> [Dec] -> Dec
DataD :: Cxt -> Name -> [Name] -> [Con] -> [Name] -> Dec
NewtypeD :: Cxt -> Name -> [Name] -> Con -> [Name] -> Dec
TySynD :: Name -> [Name] -> Type -> Dec
ClassD :: Cxt -> Name -> [Name] -> [FunDep] -> [Dec] -> Dec
InstanceD :: Cxt -> Type -> [Dec] -> Dec
SigD :: Name -> Type -> Dec
ForeignD :: Foreign -> Dec
instance Data Dec
instance Eq Dec
instance Ppr Dec
instance Show Dec
instance Typeable Dec
data Exp
VarE :: Name -> Exp
ConE :: Name -> Exp
LitE :: Lit -> Exp
AppE :: Exp -> Exp -> Exp
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
LamE :: [Pat] -> Exp -> Exp
TupE :: [Exp] -> Exp
CondE :: Exp -> Exp -> Exp -> Exp
LetE :: [Dec] -> Exp -> Exp
CaseE :: Exp -> [Match] -> Exp
DoE :: [Stmt] -> Exp
CompE :: [Stmt] -> Exp
ArithSeqE :: Range -> Exp
ListE :: [Exp] -> Exp
SigE :: Exp -> Type -> Exp
RecConE :: Name -> [FieldExp] -> Exp
RecUpdE :: Exp -> [FieldExp] -> Exp
instance Data Exp
instance Eq Exp
instance Ppr Exp
instance Show Exp
instance Typeable Exp
data Con
NormalC :: Name -> [StrictType] -> Con
RecC :: Name -> [VarStrictType] -> Con
InfixC :: StrictType -> Name -> StrictType -> Con
ForallC :: [Name] -> Cxt -> Con -> Con
instance Data Con
instance Eq Con
instance Ppr Con
instance Show Con
instance Typeable Con
data Type
ForallT :: [Name] -> Cxt -> Type -> Type
VarT :: Name -> Type
ConT :: Name -> Type
TupleT :: Int -> Type
ArrowT :: Type
ListT :: Type
AppT :: Type -> Type -> Type
instance Data Type
instance Eq Type
instance Ppr Type
instance Show Type
instance Typeable Type
type Cxt = [Type]
data Match
Match :: Pat -> Body -> [Dec] -> Match
instance Data Match
instance Eq Match
instance Ppr Match
instance Show Match
instance Typeable Match
data Clause
Clause :: [Pat] -> Body -> [Dec] -> Clause
instance Data Clause
instance Eq Clause
instance Ppr Clause
instance Show Clause
instance Typeable Clause
data Body
GuardedB :: [(Guard, Exp)] -> Body
NormalB :: Exp -> Body
instance Data Body
instance Eq Body
instance Show Body
instance Typeable Body
data Guard
NormalG :: Exp -> Guard
PatG :: [Stmt] -> Guard
instance Data Guard
instance Eq Guard
instance Show Guard
instance Typeable Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
instance Data Stmt
instance Eq Stmt
instance Ppr Stmt
instance Show Stmt
instance Typeable Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
instance Data Range
instance Eq Range
instance Ppr Range
instance Show Range
instance Typeable Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit
instance Data Lit
instance Eq Lit
instance Show Lit
instance Typeable Lit
data Pat
LitP :: Lit -> Pat
VarP :: Name -> Pat
TupP :: [Pat] -> Pat
ConP :: Name -> [Pat] -> Pat
InfixP :: Pat -> Name -> Pat -> Pat
TildeP :: Pat -> Pat
AsP :: Name -> Pat -> Pat
WildP :: Pat
RecP :: Name -> [FieldPat] -> Pat
ListP :: [Pat] -> Pat
SigP :: Pat -> Type -> Pat
instance Data Pat
instance Eq Pat
instance Ppr Pat
instance Show Pat
instance Typeable Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Strict
IsStrict :: Strict
NotStrict :: Strict
instance Data Strict
instance Eq Strict
instance Show Strict
instance Typeable Strict
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
instance Data Foreign
instance Eq Foreign
instance Ppr Foreign
instance Show Foreign
instance Typeable Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
instance Data Callconv
instance Eq Callconv
instance Show Callconv
instance Typeable Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Threadsafe :: Safety
instance Data Safety
instance Eq Safety
instance Show Safety
instance Typeable Safety
type StrictType = (Strict, Type)
type VarStrictType = (Name, Strict, Type)
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
instance Data FunDep
instance Eq FunDep
instance Ppr FunDep
instance Show FunDep
instance Typeable FunDep
data Info
ClassI :: Dec -> Info
ClassOpI :: Name -> Type -> Name -> Fixity -> Info
TyConI :: Dec -> Info
PrimTyConI :: Name -> Int -> Bool -> Info
DataConI :: Name -> Type -> Name -> Fixity -> Info
VarI :: Name -> Type -> Maybe Dec -> Fixity -> Info
TyVarI :: Name -> Type -> Info
instance Data Info
instance Ppr Info
instance Show Info
instance Typeable Info
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
instance Data Fixity
instance Eq Fixity
instance Show Fixity
instance Typeable Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
instance Data FixityDirection
instance Eq FixityDirection
instance Show FixityDirection
instance Typeable FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
returnQ :: a -> Q a
bindQ :: Q a -> (a -> Q b) -> Q b
sequenceQ :: [Q a] -> Q [a]
data NameFlavour
NameS :: NameFlavour
NameQ :: ModName -> NameFlavour
NameU :: Int# -> NameFlavour
NameL :: Int# -> NameFlavour
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
instance Data NameFlavour
instance Eq NameFlavour
instance Ord NameFlavour
instance Typeable NameFlavour
data NameSpace
VarName :: NameSpace
DataName :: NameSpace
TcClsName :: NameSpace
instance Data NameSpace
instance Eq NameSpace
instance Ord NameSpace
instance Typeable NameSpace
mkNameG_v :: String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
type Uniq = Int
mkNameL :: String -> Uniq -> Name
mkNameU :: String -> Uniq -> Name
tupleTypeName :: Int -> Name
tupleDataName :: Int -> Name
type OccName = PackedString
mkOccName :: String -> OccName
occString :: OccName -> String
type ModName = PackedString
mkModName :: String -> ModName
modString :: ModName -> String
type PkgName = PackedString
mkPkgName :: String -> PkgName
pkgString :: PkgName -> String

module Language.Haskell.TH.PprLib
type Doc = PprM Doc
instance Show Doc
data PprM a
instance Monad PprM
empty :: Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc
(<>) :: Doc -> Doc -> Doc
(<+>) :: Doc -> Doc -> Doc
hcat :: [Doc] -> Doc
hsep :: [Doc] -> Doc
($$) :: Doc -> Doc -> Doc
($+$) :: Doc -> Doc -> Doc
vcat :: [Doc] -> Doc
sep :: [Doc] -> Doc
cat :: [Doc] -> Doc
fsep :: [Doc] -> Doc
fcat :: [Doc] -> Doc
nest :: Int -> Doc -> Doc
hang :: Doc -> Int -> Doc -> Doc
punctuate :: Doc -> [Doc] -> [Doc]
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc

module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
opPrec :: Precedence
noPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
instance Ppr Clause
instance Ppr Con
instance Ppr Dec
instance Ppr Exp
instance Ppr Foreign
instance Ppr FunDep
instance Ppr Info
instance Ppr Match
instance Ppr Name
instance Ppr Pat
instance Ppr Range
instance Ppr Stmt
instance Ppr Type
instance Ppr a => Ppr [a]
pprFixity :: Name -> Fixity -> Doc
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprVarStrictType :: (Name, Strict, Type) -> Doc
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprTyApp :: (Type, [Type]) -> Doc
split :: Type -> (Type, [Type])
pprCxt :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc

module Language.Haskell.TH.Lib
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type DecQ = Q Dec
type ConQ = Q Con
type TypeQ = Q Type
type CxtQ = Q Cxt
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
intPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ
dyn :: String -> Q Exp
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ
lam1E :: PatQ -> ExpQ -> ExpQ
tupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [Name] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [Name] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [Name] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [Name] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
cxt :: [TypeQ] -> CxtQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [Name] -> CxtQ -> ConQ -> ConQ
forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
isStrict :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cCall :: Callconv
stdCall :: Callconv
unsafe :: Safety
safe :: Safety
threadsafe :: Safety
funDep :: [Name] -> [Name] -> FunDep
combine :: [([(Name, Name)], Pat)] -> ([(Name, Name)], [Pat])
rename :: Pat -> Q ([(Name, Name)], Pat)
genpat :: Pat -> Q (Name -> ExpQ, Pat)
alpha :: [(Name, Name)] -> Name -> ExpQ
appsE :: [ExpQ] -> ExpQ
simpleMatch :: Pat -> Exp -> Match

module Language.Haskell.TH
data Q a
instance Functor Q
instance Monad Q
instance Quasi Q
runQ :: Quasi m => Q a -> m a
report :: Bool -> String -> Q ()
recover :: Q a -> Q a -> Q a
reify :: Name -> Q Info
currentModule :: Q String
runIO :: IO a -> Q a
data Name
instance Data Name
instance Eq Name
instance Ord Name
instance Ppr Name
instance Show Name
instance Typeable Name
mkName :: String -> Name
newName :: String -> Q Name
nameBase :: Name -> String
nameModule :: Name -> Maybe String
tupleTypeName :: Int -> Name
tupleDataName :: Int -> Name
data Dec
FunD :: Name -> [Clause] -> Dec
ValD :: Pat -> Body -> [Dec] -> Dec
DataD :: Cxt -> Name -> [Name] -> [Con] -> [Name] -> Dec
NewtypeD :: Cxt -> Name -> [Name] -> Con -> [Name] -> Dec
TySynD :: Name -> [Name] -> Type -> Dec
ClassD :: Cxt -> Name -> [Name] -> [FunDep] -> [Dec] -> Dec
InstanceD :: Cxt -> Type -> [Dec] -> Dec
SigD :: Name -> Type -> Dec
ForeignD :: Foreign -> Dec
instance Data Dec
instance Eq Dec
instance Ppr Dec
instance Show Dec
instance Typeable Dec
data Exp
VarE :: Name -> Exp
ConE :: Name -> Exp
LitE :: Lit -> Exp
AppE :: Exp -> Exp -> Exp
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
LamE :: [Pat] -> Exp -> Exp
TupE :: [Exp] -> Exp
CondE :: Exp -> Exp -> Exp -> Exp
LetE :: [Dec] -> Exp -> Exp
CaseE :: Exp -> [Match] -> Exp
DoE :: [Stmt] -> Exp
CompE :: [Stmt] -> Exp
ArithSeqE :: Range -> Exp
ListE :: [Exp] -> Exp
SigE :: Exp -> Type -> Exp
RecConE :: Name -> [FieldExp] -> Exp
RecUpdE :: Exp -> [FieldExp] -> Exp
instance Data Exp
instance Eq Exp
instance Ppr Exp
instance Show Exp
instance Typeable Exp
data Con
NormalC :: Name -> [StrictType] -> Con
RecC :: Name -> [VarStrictType] -> Con
InfixC :: StrictType -> Name -> StrictType -> Con
ForallC :: [Name] -> Cxt -> Con -> Con
instance Data Con
instance Eq Con
instance Ppr Con
instance Show Con
instance Typeable Con
data Type
ForallT :: [Name] -> Cxt -> Type -> Type
VarT :: Name -> Type
ConT :: Name -> Type
TupleT :: Int -> Type
ArrowT :: Type
ListT :: Type
AppT :: Type -> Type -> Type
instance Data Type
instance Eq Type
instance Ppr Type
instance Show Type
instance Typeable Type
type Cxt = [Type]
data Match
Match :: Pat -> Body -> [Dec] -> Match
instance Data Match
instance Eq Match
instance Ppr Match
instance Show Match
instance Typeable Match
data Clause
Clause :: [Pat] -> Body -> [Dec] -> Clause
instance Data Clause
instance Eq Clause
instance Ppr Clause
instance Show Clause
instance Typeable Clause
data Body
GuardedB :: [(Guard, Exp)] -> Body
NormalB :: Exp -> Body
instance Data Body
instance Eq Body
instance Show Body
instance Typeable Body
data Guard
NormalG :: Exp -> Guard
PatG :: [Stmt] -> Guard
instance Data Guard
instance Eq Guard
instance Show Guard
instance Typeable Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
instance Data Stmt
instance Eq Stmt
instance Ppr Stmt
instance Show Stmt
instance Typeable Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
instance Data Range
instance Eq Range
instance Ppr Range
instance Show Range
instance Typeable Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit
instance Data Lit
instance Eq Lit
instance Show Lit
instance Typeable Lit
data Pat
LitP :: Lit -> Pat
VarP :: Name -> Pat
TupP :: [Pat] -> Pat
ConP :: Name -> [Pat] -> Pat
InfixP :: Pat -> Name -> Pat -> Pat
TildeP :: Pat -> Pat
AsP :: Name -> Pat -> Pat
WildP :: Pat
RecP :: Name -> [FieldPat] -> Pat
ListP :: [Pat] -> Pat
SigP :: Pat -> Type -> Pat
instance Data Pat
instance Eq Pat
instance Ppr Pat
instance Show Pat
instance Typeable Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Strict
IsStrict :: Strict
NotStrict :: Strict
instance Data Strict
instance Eq Strict
instance Show Strict
instance Typeable Strict
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
instance Data Foreign
instance Eq Foreign
instance Ppr Foreign
instance Show Foreign
instance Typeable Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
instance Data Callconv
instance Eq Callconv
instance Show Callconv
instance Typeable Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Threadsafe :: Safety
instance Data Safety
instance Eq Safety
instance Show Safety
instance Typeable Safety
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
instance Data FunDep
instance Eq FunDep
instance Ppr FunDep
instance Show FunDep
instance Typeable FunDep
data Info
ClassI :: Dec -> Info
ClassOpI :: Name -> Type -> Name -> Fixity -> Info
TyConI :: Dec -> Info
PrimTyConI :: Name -> Int -> Bool -> Info
DataConI :: Name -> Type -> Name -> Fixity -> Info
VarI :: Name -> Type -> Maybe Dec -> Fixity -> Info
TyVarI :: Name -> Type -> Info
instance Data Info
instance Ppr Info
instance Show Info
instance Typeable Info
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
instance Data Fixity
instance Eq Fixity
instance Show Fixity
instance Typeable Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
instance Data FixityDirection
instance Eq FixityDirection
instance Show FixityDirection
instance Typeable FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
type InfoQ = Q Info
type ExpQ = Q Exp
type DecQ = Q Dec
type ConQ = Q Con
type TypeQ = Q Type
type CxtQ = Q Cxt
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
intPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ
dyn :: String -> Q Exp
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ
lam1E :: PatQ -> ExpQ -> ExpQ
tupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
appsE :: [ExpQ] -> ExpQ
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [Name] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [Name] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [Name] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [Name] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
cxt :: [TypeQ] -> CxtQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
isStrict :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cCall :: Callconv
stdCall :: Callconv
unsafe :: Safety
safe :: Safety
threadsafe :: Safety
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
instance Ppr Clause
instance Ppr Con
instance Ppr Dec
instance Ppr Exp
instance Ppr Foreign
instance Ppr FunDep
instance Ppr Info
instance Ppr Match
instance Ppr Name
instance Ppr Pat
instance Ppr Range
instance Ppr Stmt
instance Ppr Type
instance Ppr a => Ppr [a]
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Data.Time.Calendar.MonthDay
monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
dayOfYearToMonthAndDay :: Bool -> Int -> (Int, Int)
monthLength :: Bool -> Int -> Int

module Data.Time.Calendar.Julian
toJulianYearAndDay :: Day -> (Integer, Int)
fromJulianYearAndDay :: Integer -> Int -> Day
showJulianYearAndDay :: Day -> String
isJulianLeapYear :: Integer -> Bool
toJulian :: Day -> (Integer, Int, Int)
fromJulian :: Integer -> Int -> Int -> Day
showJulian :: Day -> String
julianMonthLength :: Integer -> Int -> Int
addJulianMonthsClip :: Integer -> Day -> Day
addJulianMonthsRollOver :: Integer -> Day -> Day
addJulianYearsClip :: Integer -> Day -> Day
addJulianYearsRollOver :: Integer -> Day -> Day

module Data.Time.Calendar.OrdinalDate
toOrdinalDate :: Day -> (Integer, Int)
fromOrdinalDate :: Integer -> Int -> Day
showOrdinalDate :: Day -> String
isLeapYear :: Integer -> Bool
mondayStartWeek :: Day -> (Int, Int)
sundayStartWeek :: Day -> (Int, Int)
fromMondayStartWeek :: Integer -> Int -> Int -> Day
fromSundayStartWeek :: Integer -> Int -> Int -> Day

module Data.Time.Calendar.WeekDate
toWeekDate :: Day -> (Integer, Int, Int)
fromWeekDate :: Integer -> Int -> Int -> Day
showWeekDate :: Day -> String

module Data.Time.Clock.POSIX
posixDayLength :: NominalDiffTime
type POSIXTime = NominalDiffTime
posixSecondsToUTCTime :: POSIXTime -> UTCTime
utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
getPOSIXTime :: IO POSIXTime

module Data.Time.Clock
newtype UniversalTime
ModJulianDate :: Rational -> UniversalTime
getModJulianDate :: UniversalTime -> Rational
instance Eq UniversalTime
instance Ord UniversalTime
data DiffTime
instance Enum DiffTime
instance Eq DiffTime
instance Fractional DiffTime
instance Num DiffTime
instance Ord DiffTime
instance Real DiffTime
instance Show DiffTime
secondsToDiffTime :: Integer -> DiffTime
picosecondsToDiffTime :: Integer -> DiffTime
data UTCTime
UTCTime :: Day -> DiffTime -> UTCTime
utctDay :: UTCTime -> Day
utctDayTime :: UTCTime -> DiffTime
instance Eq UTCTime
instance FormatTime UTCTime
instance Ord UTCTime
instance ParseTime UTCTime
instance Read UTCTime
instance Show UTCTime
data NominalDiffTime
instance Enum NominalDiffTime
instance Eq NominalDiffTime
instance Fractional NominalDiffTime
instance Num NominalDiffTime
instance Ord NominalDiffTime
instance Real NominalDiffTime
instance RealFrac NominalDiffTime
instance Show NominalDiffTime
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
getCurrentTime :: IO UTCTime

module Data.Time.Calendar
newtype Day
ModifiedJulianDay :: Integer -> Day
toModifiedJulianDay :: Day -> Integer
instance Enum Day
instance Eq Day
instance FormatTime Day
instance Ord Day
instance ParseTime Day
instance Read Day
instance Show Day
addDays :: Integer -> Day -> Day
diffDays :: Day -> Day -> Integer
toGregorian :: Day -> (Integer, Int, Int)
fromGregorian :: Integer -> Int -> Int -> Day
showGregorian :: Day -> String
gregorianMonthLength :: Integer -> Int -> Int
addGregorianMonthsClip :: Integer -> Day -> Day
addGregorianMonthsRollOver :: Integer -> Day -> Day
addGregorianYearsClip :: Integer -> Day -> Day
addGregorianYearsRollOver :: Integer -> Day -> Day
isLeapYear :: Integer -> Bool

module Data.Time.Calendar.Easter
sundayAfter :: Day -> Day
orthodoxPaschalMoon :: Integer -> Day
orthodoxEaster :: Integer -> Day
gregorianPaschalMoon :: Integer -> Day
gregorianEaster :: Integer -> Day

module Data.Time.LocalTime
data TimeZone
TimeZone :: Int -> Bool -> String -> TimeZone
timeZoneMinutes :: TimeZone -> Int
timeZoneSummerOnly :: TimeZone -> Bool
timeZoneName :: TimeZone -> String
instance Eq TimeZone
instance FormatTime TimeZone
instance Ord TimeZone
instance ParseTime TimeZone
instance Read TimeZone
instance Show TimeZone
timeZoneOffsetString :: TimeZone -> String
minutesToTimeZone :: Int -> TimeZone
hoursToTimeZone :: Int -> TimeZone
utc :: TimeZone
getTimeZone :: UTCTime -> IO TimeZone
getCurrentTimeZone :: IO TimeZone
data TimeOfDay
TimeOfDay :: Int -> Int -> Pico -> TimeOfDay
todHour :: TimeOfDay -> Int
todMin :: TimeOfDay -> Int
todSec :: TimeOfDay -> Pico
instance Eq TimeOfDay
instance FormatTime TimeOfDay
instance Ord TimeOfDay
instance ParseTime TimeOfDay
instance Read TimeOfDay
instance Show TimeOfDay
midnight :: TimeOfDay
midday :: TimeOfDay
utcToLocalTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)
localToUTCTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)
timeToTimeOfDay :: DiffTime -> TimeOfDay
timeOfDayToTime :: TimeOfDay -> DiffTime
dayFractionToTimeOfDay :: Rational -> TimeOfDay
timeOfDayToDayFraction :: TimeOfDay -> Rational
data LocalTime
LocalTime :: Day -> TimeOfDay -> LocalTime
localDay :: LocalTime -> Day
localTimeOfDay :: LocalTime -> TimeOfDay
instance Eq LocalTime
instance FormatTime LocalTime
instance Ord LocalTime
instance ParseTime LocalTime
instance Read LocalTime
instance Show LocalTime
utcToLocalTime :: TimeZone -> UTCTime -> LocalTime
localTimeToUTC :: TimeZone -> LocalTime -> UTCTime
ut1ToLocalTime :: Rational -> UniversalTime -> LocalTime
localTimeToUT1 :: Rational -> LocalTime -> UniversalTime
data ZonedTime
ZonedTime :: LocalTime -> TimeZone -> ZonedTime
zonedTimeToLocalTime :: ZonedTime -> LocalTime
zonedTimeZone :: ZonedTime -> TimeZone
instance FormatTime ZonedTime
instance ParseTime ZonedTime
instance Read ZonedTime
instance Show ZonedTime
utcToZonedTime :: TimeZone -> UTCTime -> ZonedTime
zonedTimeToUTC :: ZonedTime -> UTCTime
getZonedTime :: IO ZonedTime
utcToLocalZonedTime :: UTCTime -> IO ZonedTime

module Data.Time.Clock.TAI
data AbsoluteTime
instance Eq AbsoluteTime
instance Ord AbsoluteTime
instance Show AbsoluteTime
taiEpoch :: AbsoluteTime
addAbsoluteTime :: DiffTime -> AbsoluteTime -> AbsoluteTime
diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
type LeapSecondTable = Day -> Integer
utcDayLength :: LeapSecondTable -> Day -> DiffTime
utcToTAITime :: LeapSecondTable -> UTCTime -> AbsoluteTime
taiToUTCTime :: LeapSecondTable -> AbsoluteTime -> UTCTime
parseTAIUTCDATFile :: String -> LeapSecondTable

module Data.Time.Format
class FormatTime t
formatCharacter :: FormatTime t => Char -> Maybe (TimeLocale -> t -> String)
instance FormatTime Day
instance FormatTime LocalTime
instance FormatTime TimeOfDay
instance FormatTime TimeZone
instance FormatTime UTCTime
instance FormatTime ZonedTime
formatTime :: FormatTime t => TimeLocale -> String -> t -> String
parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
readTime :: ParseTime t => TimeLocale -> String -> String -> t
readsTime :: ParseTime t => TimeLocale -> String -> ReadS t
class ParseTime t
buildTime :: ParseTime t => TimeLocale -> [(Char, String)] -> t
instance ParseTime Day
instance ParseTime LocalTime
instance ParseTime TimeOfDay
instance ParseTime TimeZone
instance ParseTime UTCTime
instance ParseTime ZonedTime

module Data.Time
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

module Text.XHtml.Frameset
data Html
instance ADDATTRS Html
instance HTML Html
instance HTMLTABLE Html
instance Monoid Html
instance Show Html
data HtmlAttr
instance Show HtmlAttr
class HTML a
toHtml :: HTML a => a -> Html
toHtmlFromList :: HTML a => [a] -> Html
instance HTML Char
instance HTML HotLink
instance HTML Html
instance HTML HtmlTable
instance HTML HtmlTree
instance HTML a => HTML [a]
class ADDATTRS a
(!) :: ADDATTRS a => a -> [HtmlAttr] -> a
instance ADDATTRS Html
instance ADDATTRS b => ADDATTRS (a -> b)
(<<) :: HTML a => (Html -> b) -> a -> b
concatHtml :: HTML a => [a] -> Html
(+++) :: (HTML a, HTML b) => a -> b -> Html
noHtml :: Html
isNoHtml :: Html -> Bool
tag :: String -> Html -> Html
itag :: String -> Html
emptyAttr :: String -> HtmlAttr
intAttr :: String -> Int -> HtmlAttr
strAttr :: String -> String -> HtmlAttr
htmlAttr :: String -> Html -> HtmlAttr
primHtml :: String -> Html
showHtml :: HTML html => html -> String
renderHtml :: HTML html => html -> String
prettyHtml :: HTML html => html -> String
showHtmlFragment :: HTML html => html -> String
renderHtmlFragment :: HTML html => html -> String
prettyHtmlFragment :: HTML html => html -> String
abbr :: Html -> Html
acronym :: Html -> Html
address :: Html -> Html
anchor :: Html -> Html
area :: Html
bdo :: Html -> Html
big :: Html -> Html
blockquote :: Html -> Html
body :: Html -> Html
bold :: Html -> Html
br :: Html
button :: Html -> Html
caption :: Html -> Html
cite :: Html -> Html
col :: Html -> Html
colgroup :: Html -> Html
del :: Html -> Html
ddef :: Html -> Html
define :: Html -> Html
dlist :: Html -> Html
dterm :: Html -> Html
emphasize :: Html -> Html
fieldset :: Html -> Html
form :: Html -> Html
h1 :: Html -> Html
h2 :: Html -> Html
h3 :: Html -> Html
h4 :: Html -> Html
h5 :: Html -> Html
h6 :: Html -> Html
header :: Html -> Html
hr :: Html
image :: Html
input :: Html
ins :: Html -> Html
italics :: Html -> Html
keyboard :: Html -> Html
label :: Html -> Html
legend :: Html -> Html
li :: Html -> Html
meta :: Html
noscript :: Html -> Html
object :: Html -> Html
olist :: Html -> Html
optgroup :: Html -> Html
option :: Html -> Html
paragraph :: Html -> Html
param :: Html
pre :: Html -> Html
quote :: Html -> Html
sample :: Html -> Html
script :: Html -> Html
select :: Html -> Html
small :: Html -> Html
strong :: Html -> Html
style :: Html -> Html
sub :: Html -> Html
sup :: Html -> Html
table :: Html -> Html
tbody :: Html -> Html
td :: Html -> Html
textarea :: Html -> Html
tfoot :: Html -> Html
th :: Html -> Html
thead :: Html -> Html
thebase :: Html
thecode :: Html -> Html
thediv :: Html -> Html
thehtml :: Html -> Html
thelink :: Html -> Html
themap :: Html -> Html
thespan :: Html -> Html
thetitle :: Html -> Html
tr :: Html -> Html
tt :: Html -> Html
ulist :: Html -> Html
variable :: Html -> Html
frame :: Html -> Html
frameset :: Html -> Html
noframes :: Html -> Html
action :: String -> HtmlAttr
align :: String -> HtmlAttr
alt :: String -> HtmlAttr
altcode :: String -> HtmlAttr
archive :: String -> HtmlAttr
base :: String -> HtmlAttr
border :: Int -> HtmlAttr
bordercolor :: String -> HtmlAttr
cellpadding :: Int -> HtmlAttr
cellspacing :: Int -> HtmlAttr
checked :: HtmlAttr
codebase :: String -> HtmlAttr
cols :: String -> HtmlAttr
colspan :: Int -> HtmlAttr
content :: String -> HtmlAttr
coords :: String -> HtmlAttr
disabled :: HtmlAttr
enctype :: String -> HtmlAttr
height :: String -> HtmlAttr
href :: String -> HtmlAttr
httpequiv :: String -> HtmlAttr
identifier :: String -> HtmlAttr
ismap :: HtmlAttr
lang :: String -> HtmlAttr
maxlength :: Int -> HtmlAttr
method :: String -> HtmlAttr
multiple :: HtmlAttr
name :: String -> HtmlAttr
nohref :: HtmlAttr
rel :: String -> HtmlAttr
rev :: String -> HtmlAttr
rows :: String -> HtmlAttr
rowspan :: Int -> HtmlAttr
rules :: String -> HtmlAttr
selected :: HtmlAttr
shape :: String -> HtmlAttr
size :: String -> HtmlAttr
src :: String -> HtmlAttr
theclass :: String -> HtmlAttr
thefor :: String -> HtmlAttr
thestyle :: String -> HtmlAttr
thetype :: String -> HtmlAttr
title :: String -> HtmlAttr
usemap :: String -> HtmlAttr
valign :: String -> HtmlAttr
value :: String -> HtmlAttr
width :: String -> HtmlAttr
frameborder :: Int -> HtmlAttr
marginheight :: Int -> HtmlAttr
marginwidth :: Int -> HtmlAttr
noresize :: HtmlAttr
scrolling :: String -> HtmlAttr
stringToHtml :: String -> Html
lineToHtml :: String -> Html
linesToHtml :: [String] -> Html
primHtmlChar :: String -> Html
copyright :: Html
spaceHtml :: Html
bullet :: Html
p :: Html -> Html
type URL = String
data HotLink
HotLink :: URL -> Html -> [HtmlAttr] -> HotLink
hotLinkURL :: HotLink -> URL
hotLinkContents :: HotLink -> Html
hotLinkAttributes :: HotLink -> [HtmlAttr]
instance HTML HotLink
instance Show HotLink
hotlink :: URL -> Html -> HotLink
ordList :: HTML a => [a] -> Html
unordList :: HTML a => [a] -> Html
defList :: (HTML a, HTML b) => [(a, b)] -> Html
widget :: String -> String -> [HtmlAttr] -> Html
checkbox :: String -> String -> Html
hidden :: String -> String -> Html
radio :: String -> String -> Html
reset :: String -> String -> Html
submit :: String -> String -> Html
password :: String -> Html
textfield :: String -> Html
afile :: String -> Html
clickmap :: String -> Html
menu :: String -> [Html] -> Html
gui :: String -> Html -> Html

module Text.XHtml.Strict
data Html
instance ADDATTRS Html
instance HTML Html
instance HTMLTABLE Html
instance Monoid Html
instance Show Html
data HtmlAttr
instance Show HtmlAttr
class HTML a
toHtml :: HTML a => a -> Html
toHtmlFromList :: HTML a => [a] -> Html
instance HTML Char
instance HTML HotLink
instance HTML Html
instance HTML HtmlTable
instance HTML HtmlTree
instance HTML a => HTML [a]
class ADDATTRS a
(!) :: ADDATTRS a => a -> [HtmlAttr] -> a
instance ADDATTRS Html
instance ADDATTRS b => ADDATTRS (a -> b)
(<<) :: HTML a => (Html -> b) -> a -> b
concatHtml :: HTML a => [a] -> Html
(+++) :: (HTML a, HTML b) => a -> b -> Html
noHtml :: Html
isNoHtml :: Html -> Bool
tag :: String -> Html -> Html
itag :: String -> Html
emptyAttr :: String -> HtmlAttr
intAttr :: String -> Int -> HtmlAttr
strAttr :: String -> String -> HtmlAttr
htmlAttr :: String -> Html -> HtmlAttr
primHtml :: String -> Html
showHtml :: HTML html => html -> String
renderHtml :: HTML html => html -> String
prettyHtml :: HTML html => html -> String
showHtmlFragment :: HTML html => html -> String
renderHtmlFragment :: HTML html => html -> String
prettyHtmlFragment :: HTML html => html -> String
abbr :: Html -> Html
acronym :: Html -> Html
address :: Html -> Html
anchor :: Html -> Html
area :: Html
bdo :: Html -> Html
big :: Html -> Html
blockquote :: Html -> Html
body :: Html -> Html
bold :: Html -> Html
br :: Html
button :: Html -> Html
caption :: Html -> Html
cite :: Html -> Html
col :: Html -> Html
colgroup :: Html -> Html
del :: Html -> Html
ddef :: Html -> Html
define :: Html -> Html
dlist :: Html -> Html
dterm :: Html -> Html
emphasize :: Html -> Html
fieldset :: Html -> Html
form :: Html -> Html
h1 :: Html -> Html
h2 :: Html -> Html
h3 :: Html -> Html
h4 :: Html -> Html
h5 :: Html -> Html
h6 :: Html -> Html
header :: Html -> Html
hr :: Html
image :: Html
input :: Html
ins :: Html -> Html
italics :: Html -> Html
keyboard :: Html -> Html
label :: Html -> Html
legend :: Html -> Html
li :: Html -> Html
meta :: Html
noscript :: Html -> Html
object :: Html -> Html
olist :: Html -> Html
optgroup :: Html -> Html
option :: Html -> Html
paragraph :: Html -> Html
param :: Html
pre :: Html -> Html
quote :: Html -> Html
sample :: Html -> Html
script :: Html -> Html
select :: Html -> Html
small :: Html -> Html
strong :: Html -> Html
style :: Html -> Html
sub :: Html -> Html
sup :: Html -> Html
table :: Html -> Html
tbody :: Html -> Html
td :: Html -> Html
textarea :: Html -> Html
tfoot :: Html -> Html
th :: Html -> Html
thead :: Html -> Html
thebase :: Html
thecode :: Html -> Html
thediv :: Html -> Html
thehtml :: Html -> Html
thelink :: Html -> Html
themap :: Html -> Html
thespan :: Html -> Html
thetitle :: Html -> Html
tr :: Html -> Html
tt :: Html -> Html
ulist :: Html -> Html
variable :: Html -> Html
action :: String -> HtmlAttr
align :: String -> HtmlAttr
alt :: String -> HtmlAttr
altcode :: String -> HtmlAttr
archive :: String -> HtmlAttr
base :: String -> HtmlAttr
border :: Int -> HtmlAttr
bordercolor :: String -> HtmlAttr
cellpadding :: Int -> HtmlAttr
cellspacing :: Int -> HtmlAttr
checked :: HtmlAttr
codebase :: String -> HtmlAttr
cols :: String -> HtmlAttr
colspan :: Int -> HtmlAttr
content :: String -> HtmlAttr
coords :: String -> HtmlAttr
disabled :: HtmlAttr
enctype :: String -> HtmlAttr
height :: String -> HtmlAttr
href :: String -> HtmlAttr
httpequiv :: String -> HtmlAttr
identifier :: String -> HtmlAttr
ismap :: HtmlAttr
lang :: String -> HtmlAttr
maxlength :: Int -> HtmlAttr
method :: String -> HtmlAttr
multiple :: HtmlAttr
name :: String -> HtmlAttr
nohref :: HtmlAttr
rel :: String -> HtmlAttr
rev :: String -> HtmlAttr
rows :: String -> HtmlAttr
rowspan :: Int -> HtmlAttr
rules :: String -> HtmlAttr
selected :: HtmlAttr
shape :: String -> HtmlAttr
size :: String -> HtmlAttr
src :: String -> HtmlAttr
theclass :: String -> HtmlAttr
thefor :: String -> HtmlAttr
thestyle :: String -> HtmlAttr
thetype :: String -> HtmlAttr
title :: String -> HtmlAttr
usemap :: String -> HtmlAttr
valign :: String -> HtmlAttr
value :: String -> HtmlAttr
width :: String -> HtmlAttr
stringToHtml :: String -> Html
lineToHtml :: String -> Html
linesToHtml :: [String] -> Html
primHtmlChar :: String -> Html
copyright :: Html
spaceHtml :: Html
bullet :: Html
p :: Html -> Html
type URL = String
data HotLink
HotLink :: URL -> Html -> [HtmlAttr] -> HotLink
hotLinkURL :: HotLink -> URL
hotLinkContents :: HotLink -> Html
hotLinkAttributes :: HotLink -> [HtmlAttr]
instance HTML HotLink
instance Show HotLink
hotlink :: URL -> Html -> HotLink
ordList :: HTML a => [a] -> Html
unordList :: HTML a => [a] -> Html
defList :: (HTML a, HTML b) => [(a, b)] -> Html
widget :: String -> String -> [HtmlAttr] -> Html
checkbox :: String -> String -> Html
hidden :: String -> String -> Html
radio :: String -> String -> Html
reset :: String -> String -> Html
submit :: String -> String -> Html
password :: String -> Html
textfield :: String -> Html
afile :: String -> Html
clickmap :: String -> Html
menu :: String -> [Html] -> Html
gui :: String -> Html -> Html

module Text.XHtml.Transitional
data Html
instance ADDATTRS Html
instance HTML Html
instance HTMLTABLE Html
instance Monoid Html
instance Show Html
data HtmlAttr
instance Show HtmlAttr
class HTML a
toHtml :: HTML a => a -> Html
toHtmlFromList :: HTML a => [a] -> Html
instance HTML Char
instance HTML HotLink
instance HTML Html
instance HTML HtmlTable
instance HTML HtmlTree
instance HTML a => HTML [a]
class ADDATTRS a
(!) :: ADDATTRS a => a -> [HtmlAttr] -> a
instance ADDATTRS Html
instance ADDATTRS b => ADDATTRS (a -> b)
(<<) :: HTML a => (Html -> b) -> a -> b
concatHtml :: HTML a => [a] -> Html
(+++) :: (HTML a, HTML b) => a -> b -> Html
noHtml :: Html
isNoHtml :: Html -> Bool
tag :: String -> Html -> Html
itag :: String -> Html
emptyAttr :: String -> HtmlAttr
intAttr :: String -> Int -> HtmlAttr
strAttr :: String -> String -> HtmlAttr
htmlAttr :: String -> Html -> HtmlAttr
primHtml :: String -> Html
showHtml :: HTML html => html -> String
renderHtml :: HTML html => html -> String
prettyHtml :: HTML html => html -> String
showHtmlFragment :: HTML html => html -> String
renderHtmlFragment :: HTML html => html -> String
prettyHtmlFragment :: HTML html => html -> String
abbr :: Html -> Html
acronym :: Html -> Html
address :: Html -> Html
anchor :: Html -> Html
area :: Html
bdo :: Html -> Html
big :: Html -> Html
blockquote :: Html -> Html
body :: Html -> Html
bold :: Html -> Html
br :: Html
button :: Html -> Html
caption :: Html -> Html
cite :: Html -> Html
col :: Html -> Html
colgroup :: Html -> Html
del :: Html -> Html
ddef :: Html -> Html
define :: Html -> Html
dlist :: Html -> Html
dterm :: Html -> Html
emphasize :: Html -> Html
fieldset :: Html -> Html
form :: Html -> Html
h1 :: Html -> Html
h2 :: Html -> Html
h3 :: Html -> Html
h4 :: Html -> Html
h5 :: Html -> Html
h6 :: Html -> Html
header :: Html -> Html
hr :: Html
image :: Html
input :: Html
ins :: Html -> Html
italics :: Html -> Html
keyboard :: Html -> Html
label :: Html -> Html
legend :: Html -> Html
li :: Html -> Html
meta :: Html
noscript :: Html -> Html
object :: Html -> Html
olist :: Html -> Html
optgroup :: Html -> Html
option :: Html -> Html
paragraph :: Html -> Html
param :: Html
pre :: Html -> Html
quote :: Html -> Html
sample :: Html -> Html
script :: Html -> Html
select :: Html -> Html
small :: Html -> Html
strong :: Html -> Html
style :: Html -> Html
sub :: Html -> Html
sup :: Html -> Html
table :: Html -> Html
tbody :: Html -> Html
td :: Html -> Html
textarea :: Html -> Html
tfoot :: Html -> Html
th :: Html -> Html
thead :: Html -> Html
thebase :: Html
thecode :: Html -> Html
thediv :: Html -> Html
thehtml :: Html -> Html
thelink :: Html -> Html
themap :: Html -> Html
thespan :: Html -> Html
thetitle :: Html -> Html
tr :: Html -> Html
tt :: Html -> Html
ulist :: Html -> Html
variable :: Html -> Html
frame :: Html -> Html
frameset :: Html -> Html
noframes :: Html -> Html
applet :: Html -> Html
basefont :: Html
center :: Html -> Html
dir :: Html -> Html
font :: Html -> Html
iframe :: Html -> Html
isindex :: Html
themenu :: Html -> Html
strike :: Html -> Html
underline :: Html -> Html
action :: String -> HtmlAttr
align :: String -> HtmlAttr
alt :: String -> HtmlAttr
altcode :: String -> HtmlAttr
archive :: String -> HtmlAttr
base :: String -> HtmlAttr
border :: Int -> HtmlAttr
bordercolor :: String -> HtmlAttr
cellpadding :: Int -> HtmlAttr
cellspacing :: Int -> HtmlAttr
checked :: HtmlAttr
codebase :: String -> HtmlAttr
cols :: String -> HtmlAttr
colspan :: Int -> HtmlAttr
content :: String -> HtmlAttr
coords :: String -> HtmlAttr
disabled :: HtmlAttr
enctype :: String -> HtmlAttr
height :: String -> HtmlAttr
href :: String -> HtmlAttr
httpequiv :: String -> HtmlAttr
identifier :: String -> HtmlAttr
ismap :: HtmlAttr
lang :: String -> HtmlAttr
maxlength :: Int -> HtmlAttr
method :: String -> HtmlAttr
multiple :: HtmlAttr
name :: String -> HtmlAttr
nohref :: HtmlAttr
rel :: String -> HtmlAttr
rev :: String -> HtmlAttr
rows :: String -> HtmlAttr
rowspan :: Int -> HtmlAttr
rules :: String -> HtmlAttr
selected :: HtmlAttr
shape :: String -> HtmlAttr
size :: String -> HtmlAttr
src :: String -> HtmlAttr
theclass :: String -> HtmlAttr
thefor :: String -> HtmlAttr
thestyle :: String -> HtmlAttr
thetype :: String -> HtmlAttr
title :: String -> HtmlAttr
usemap :: String -> HtmlAttr
valign :: String -> HtmlAttr
value :: String -> HtmlAttr
width :: String -> HtmlAttr
frameborder :: Int -> HtmlAttr
marginheight :: Int -> HtmlAttr
marginwidth :: Int -> HtmlAttr
noresize :: HtmlAttr
scrolling :: String -> HtmlAttr
alink :: String -> HtmlAttr
background :: String -> HtmlAttr
bgcolor :: String -> HtmlAttr
clear :: String -> HtmlAttr
code :: String -> HtmlAttr
color :: String -> HtmlAttr
compact :: HtmlAttr
face :: String -> HtmlAttr
hspace :: Int -> HtmlAttr
link :: String -> HtmlAttr
noshade :: HtmlAttr
nowrap :: HtmlAttr
start :: Int -> HtmlAttr
target :: String -> HtmlAttr
text :: String -> HtmlAttr
version :: String -> HtmlAttr
vlink :: String -> HtmlAttr
vspace :: Int -> HtmlAttr
aqua :: String
black :: String
blue :: String
fuchsia :: String
gray :: String
green :: String
lime :: String
maroon :: String
navy :: String
olive :: String
purple :: String
red :: String
silver :: String
teal :: String
yellow :: String
white :: String
stringToHtml :: String -> Html
lineToHtml :: String -> Html
linesToHtml :: [String] -> Html
primHtmlChar :: String -> Html
copyright :: Html
spaceHtml :: Html
bullet :: Html
p :: Html -> Html
type URL = String
data HotLink
HotLink :: URL -> Html -> [HtmlAttr] -> HotLink
hotLinkURL :: HotLink -> URL
hotLinkContents :: HotLink -> Html
hotLinkAttributes :: HotLink -> [HtmlAttr]
instance HTML HotLink
instance Show HotLink
hotlink :: URL -> Html -> HotLink
ordList :: HTML a => [a] -> Html
unordList :: HTML a => [a] -> Html
defList :: (HTML a, HTML b) => [(a, b)] -> Html
widget :: String -> String -> [HtmlAttr] -> Html
checkbox :: String -> String -> Html
hidden :: String -> String -> Html
radio :: String -> String -> Html
reset :: String -> String -> Html
submit :: String -> String -> Html
password :: String -> Html
textfield :: String -> Html
afile :: String -> Html
clickmap :: String -> Html
menu :: String -> [Html] -> Html
gui :: String -> Html -> Html

module Text.XHtml.Table
data HtmlTable
instance HTML HtmlTable
instance HTMLTABLE HtmlTable
instance Show HtmlTable
class HTMLTABLE ht
cell :: HTMLTABLE ht => ht -> HtmlTable
instance HTMLTABLE Html
instance HTMLTABLE HtmlTable
(</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
above :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
(<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
beside :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
aboves :: HTMLTABLE ht => [ht] -> HtmlTable
besides :: HTMLTABLE ht => [ht] -> HtmlTable
simpleTable :: [HtmlAttr] -> [HtmlAttr] -> [[Html]] -> Html

module Text.XHtml.Debug
data HtmlTree
HtmlLeaf :: Html -> HtmlTree
HtmlNode :: Html -> [HtmlTree] -> Html -> HtmlTree
instance HTML HtmlTree
treeHtml :: [String] -> HtmlTree -> Html
treeColors :: [String]
debugHtml :: HTML a => a -> Html

module Text.XHtml
