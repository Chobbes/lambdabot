100000
("Arrow"," \\t1 t2 v a q.a t1 t2")
("B"," \\f g x. f (g x)")
("Branch"," \\l k r lk bk.bk l k r")
("C"," \\f x y.f y x")
("Cons"," \\a l n c.c a l")
("False"," \\x y. y")
("Forall"," \\vs t v a q.q vs t")
("I"," \\x.x")
("Just"," \\x n j.j x")
("K"," \\x y.x")
("Leaf"," \\x l b.l x")
("Left"," \\x l r.l x")
("MonadError"," [flip (either Left),Right,Left,\\m h.either h Right m]")
("MonadLP"," [\\m f k.m (\\a.f a k),\\a k.k a]")
("MonadParser"," [\\m f s.either Left (pair (\\a s.f a s)) (m s),\\a s.Right (Pair a s),\\s.Right (Pair s s),\\s x.Right (Pair x s),\\e s.Left e,\\m1 m2 s.either (const (m2 s)) Right (m1 s)]")
("MonadReader"," [\\m f r.f (m r) r,\\a r.a,\\r.r,\\f e r.e (f r)]")
("MonadState"," [\\m f s.pair (\\a s.f a s) (m s),\\a s.Pair a s,\\s.Pair s s,\\x s.Pair s x]")
("MonadWriter"," MonadWriter_ [] (\\x y.x++y)")
("MonadWriter_"," \\mempty mappend.[\\m f.pair (\\a w.pair (\\b w2.Pair b (mappend w w2)) (f a)) m,\\a.Pair a mempty,\\w.Pair w w,\\m.pair (\\a w.Pair (Pair a w) w) m,\\m.pair (\\p w.pair (\\a f.Pair a (f w)) p) m]")
("Nil"," const")
("Nothing"," const")
("Pair"," \\x y k.k x y")
("Right"," \\x l r.r x")
("S"," \\f g x.f x (g x)")
("StateT"," \\m.[\\e f s.runMonad m (bind (e s) (pair (\\a s.f a s))),\\a s.runMonad m (return (Pair a s)),\\s.runMonad m (return (Pair s s)),\\s x.runMonad m (return (Pair x s))]")
("Succ"," \\n z s.s n")
("TVar"," \\s v a q.v s")
("Term"," \\a ts var term.term a ts")
("True"," \\x y. x")
("U"," \\f. f f")
("Var"," \\v var term.var v")
("X"," \\x.x K S K")
("Y"," \\f.U(\\g.f(U g))")
("Zero"," \\z s.z")
("a"," map (either bad fst . runMonad MonadParser parseRule) [\"lookup(cons(pair(K,V),T),K,V).\",\"lookup(cons(P,T),K,V) :- lookup(T,K,V).\"]")
("all"," \\p.and . map p")
("alt"," \\m1 m2 m.nth 5 m (m1 m) (m2 m)")
("ana"," unfoldr")
("and"," foldr (\\x y.x&&y) True")
("any"," \\p.or . map p")
("apo"," \\g n.maybe [] (\\p.fst p:either id (apo g) (snd p)) (g n)")
("app"," flip (foldr (\\x xs.x:xs))")
("append"," flip (fold Cons)")
("ask"," nth 2")
("between"," \\l r p.bind_ l $ bind_ spaces $ bind p $ \\res.bind_ r $ bind_ spaces (return res)")
("bind"," \\m1 f m.bind_internal m (m1 m) (\\a.f a m)")
("bind_"," \\m1 m2.bind m1 (const m2)")
("bind_internal"," nth 0")
("brp"," \\l.if null (tail l) then l else cat $ unzip $ brp $ group' l id")
("car"," list undefined const")
("cat"," pair (\\x y.x++y)")
("cata"," foldr")
("catchError"," \\e h m.nth 3 m (e m) (\\a.h a m)")
("cdr"," list undefined (K I)")
("chAnd"," \\x y . x y chFalse")
("chFalse"," \\x y. y")
("chIf"," I")
("chNot"," \\x y z . x z y")
("chOr"," \\x y . x chTrue y")
("chTrue"," \\x y. x")
("char"," \\c.sat (\\x.x==c)")
("charToDigit"," \\c.if c == '0' then 0 else if c == '1' then 1 else if c == '2' then 2 else if c == '3' then 3 else if c == '4' then 4 else if c == '5' then 5 else if c == '6' then 6 else if c == '7' then 7 else if c == '8' then 8 else if c == '9' then 9 else undefined")
("choice"," foldl alt (parseError \"parse error - choice\")")
("comma"," symbol \",\"")
("concat"," foldr (\\x y.x++y) []")
("concatMap"," \\f.concat . map f")
("cons"," \\h t n c. c h t")
("const"," \\x y.x")
("curry"," \\f x y.f (Pair x y)")
("cycle"," \\l.fix (\\x.l++x)")
("decay"," \\n.sum (factors n) - n")
("decaySequence"," \\n.n : unfoldr (\\n.if n == 0 then Nothing else (\\m.Just (Pair m m)) (decay n)) n")
("delete"," deleteBy (\\x y.x==y)")
("deleteBy"," \\eq x l.if null l then [] else if x `eq` head l then tail l else head l : deleteBy eq x (tail l)")
("deleteFirstsBy"," \\eq.foldl (flip (deleteBy eq))")
("diff"," foldl (flip delete)")
("digitToChar"," \\n.if n==0 then '0' else if n==1 then '1' else if n==2 then '2' else if n==3 then '3' else if n==4 then '4' else if n==5 then '5' else if n==6 then '6' else if n==7 then '7' else if n==8 then '8' else if n==9 then '9' else undefined")
("divides"," \\d.\\n.n `mod` d == 0")
("dot"," symbol \".\"")
("drop"," \\n l.if null l || n <= 0 then l else drop (n-1) (tail l)")
("dropWhile"," \\p l.if null l then [] else if p (head l) then dropWhile p (tail l) else l")
("either"," \\f g e. e f g")
("elem"," \\x.any (\\y.x==y)")
("enumFrom"," iterate (\\x.x+1)")
("enumFromThen"," \\m n.iterate (\\x.(n-m)+x) m")
("enumFromThenTo"," \\l r h.takeWhile (if r>=l then (\\x.x<=h) else (\\x.x>=h)) $ enumFromThen l r")
("enumFromTo"," \\l h.take (h-l+1) $ iterate (\\x.x+1) l")
("even"," \\x.x `mod` 2 == 0")
("fac"," product . fromTo 1")
("fact"," Y (\\fact. (\\n. if (n == 1) then 1 else (n * (fact (n - 1)))))")
("factors"," \\n.if n == 0 then from 0 else filter (\\d.d `divides` n) (fromTo 1 n)")
("factorsOLD"," \\n.if n == 0 then from 0 else filter (\\d.d `divides` n) (fromTo 1 n)")
("failed"," \\dict k.id")
("fibs"," 1:1:zipWith (\\x y.x+y) fibs (tail fibs)")
("filter"," \\p.foldr (\\x y.if p x then x:y else y) []")
("first"," head")
("fix"," \\f.f (fix f)")
("flip"," \\f x y.f y x")
("foldTerm"," \\var term.termCase var (\\a ts.term a (map (foldTerm var term) ts))")
("foldl"," \\c n l.if null l then n else foldl c (c n (head l)) (tail l)")
("foldl1"," \\f l.foldl f (head l) (tail l)")
("foldr"," \\c n l.if null l then n else c (head l) (foldr c n (tail l))")
("foldr1"," \\f l.if null (tail l) then head l else f (head l) (foldr1 f (tail l))")
("followLinks"," foldTerm (\\v.readLPRef v `bind` maybe (return (Var v)) followLinks) (\\a ts.sequence ts `bind` \\ts'.return (Term a ts'))")
("foo"," \"Idag har jag cyklat enhjuling!\"")
("free"," newLPRef Nothing `bind` \\ref. return (Var ref)")
("freevars"," type (\\x.[x]) (\\t1 t2.freevars t1 `union` freevars t2) (\\vs t.freevars t `diff` vs)")
("from"," enumFrom")
("fromList"," foldr Cons Nil")
("fromThen"," enumFromThen")
("fromThenTo"," enumFromThenTo")
("fromTo"," enumFromTo")
("fst"," \\p.p const")
("genCase"," \\n l d.if null l then d n else if fst (head l) == n then snd (head l) n else genCase n (tail l) d")
("get"," nth 2")
("getConstructor"," termCase error_getConstructor (\\a _.a)")
("group"," groupBy (\\x y.x==y)")
("group'"," \\l k.if null l then k [] else group' (tail (tail l)) (k . (\\x.Pair (head l) (head (tail l)) : x))")
("groupBy"," \\eq l.if null l then [] else pair (\\ys zs.(head l : ys) : groupBy eq zs) (span (eq (head l)) (tail l))")
("id"," \\x.x")
("identifier"," bind get $ \\s.bind (sat (\\c.isIdentifierLetter c && not (isDigit c) && (c/='-' || null (tail s) || not (isDigit (head (tail s)))))) $ \\c.bind (many (sat isIdentifierLetter)) $ \\cs.bind_ spaces $ return (c:cs)")
("init"," \\l.if null (tail l) then [] else head l : init (tail l)")
("internalListCase"," \\n c l.if null l then n else c (head l) (tail l)")
("interpretTerm"," foldTerm (\\v env.maybe (free `bind` \\v'.return (Pair v' (Pair v v':env))) (\\a.return (Pair a env)) (lookup v env)) (\\a ts env.foldl (\\m f.m `bind` \\p.f (snd p) `bind` pair (\\t env'.return (Pair (t:fst p) env'))) (return (Pair [] env)) ts `bind` pair (\\ts' env'.return (Pair (Term a (reverse ts')) env')))")
("intersperse"," \\sep l.if null l then [] else if null (tail l) then l else head l : sep : intersperse sep (tail l)")
("isDigit"," \\c.c >= '0' && c <= '9'")
("isIdentifierLetter"," \\c.notElem c \" []\\\"{}';(),\"")
("isPrime"," (\\n. all (\\x. x /= 0) (map (mod n) (enumFromTo 2 (sqrt n + 1))))")
("isSpace"," \\c.c==' '")
("isUpper"," \\c.elem c \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"")
("isVar"," termCase Just (\\_ _.Nothing)")
("iterate"," \\f x.x:iterate f (f x)")
("joy"," either id (flip joyEval [] . fst) . joyParse")
("joyBinOp"," \\op s.op (second s) (first s) : tail (tail s)")
("joyDefs"," [Pair \"+\" (joyBinOp (\\x y.x+y)),Pair \"-\" (joyBinOp (\\x y.x-y)),Pair \"/\" (joyBinOp (\\x y.x/y)),Pair \"*\" (joyBinOp (\\x y.x*y)),Pair \"=\" (joyBinOp (\\x y.x==y)),Pair \"dup\" \\s.first s : s,Pair \"i\" \\s.joyEval (first s) (tail s),Pair \"true\" \\s.True:s,Pair \"false\" \\s.False:s,Pair \"ifte\" joyIFTE,Pair \"x\" \\s.joyEval (first s) s,Pair \"pop\" tail,Pair \"dip\" \\s.second s:joyEval (first s) (tail (tail s))]")
("joyEval"," \\l.foldr (flip B) id (map (lookupDef joyDefs) l)")
("joyExpr"," many $ choice [bind (squares joyExpr) (return . Left),bind identifier (return . Right),bind_ (sat (\\c.c=='\\'')) $ bind next $ \\c.bind_ spaces $ return (Left c),bind parseNum $ \\n.bind_ spaces $ return (Left n)]")
("joyIFTE"," \\s.if head (joyEval (nth 2 s) (drop 3 s)) then joyEval (second s) (drop 3 s) else joyEval (first s) (drop 3 s)")
("joyParse"," runMonad MonadParser joyExpr")
("last"," \\l.if null (tail l) then (head l) else last (tail l)")
("lcFalse"," (C K)")
("lcIf"," I")
("lcTrue"," K")
("length"," foldl (\\x y.x+1) 0")
("lexeme"," \\p.p `bind` \\r.spaces `bind` \\_.return r")
("liftLP"," \\m dict k f s.pair (\\a s'.k a f s') (m s)")
("liftS"," \\e x s m.runMonad m (bind e (\\a.return (Pair a s)))")
("list"," \\c n l.l c n")
("listen"," \\e m.nth 3 m (e m)")
("local"," \\f e m.nth 3 m f (e m)")
("lookup"," \\k l.if null l then Nothing else if fst (head l) == k then Just (snd (head l)) else lookup k (tail l)")
("lookupDef"," \\d.either (\\a s.a:s) (\\k.maybe unbound_variable_error id (lookup k d))")
("lookupRef"," \\k l.if fst (head l) == k then snd (head l) else lookupRef k (tail l)")
("lookupTree"," \\i.tree id (\\l k r.if i < k then lookupTree i l else lookupTree i r)")
("makePerfect"," \\x.(\\y.y * (y + 1) / 2) (pow 2 x - 1)")
("many"," \\p.alt (many1 p) (return [])")
("many1"," \\p.bind p $ \\h.bind (many p) $ \\t.return (h:t)")
("map"," \\f.foldr (\\x y.f x:y) []")
("mapAccumL"," \\f s l.if null l then Pair s [] else pair (\\s' y.pair (\\s'' ys.Pair s'' (y:ys)) (mapAccumL f s' xs)) (f s (head l))")
("mapAccumR"," \\f s l.if null l then Pair s [] else pair (\\s' ys.pair (\\s'' y.Pair s'' (y:ys)) (f s' x)) (mapAccumR f s xs)")
("maybe"," \\f g m.m f g")
("mersenneExponents"," filter (\\x. isPrime (pow 2 x - 1)) (from 1)")
("mersennePrimes"," (filter isPrime (map (\\x. pow 2 x - 1) (enumFrom 1)))")
("mod"," \\n d.n-(n/d)*d")
("modifyTree"," \\i f.tree (\\x.Leaf (f x)) (\\l k r.if i < k then Branch (modifyTree i f l) k r else Branch l k (modifyTree i f r))")
("nat"," \\z s n.n z s")
("natuals"," \\x . (x : (naturals (x+1)))")
("naturals"," \\x . (x : (naturals (x+1)))")
("ndivby"," \\a b. (mod b a) /= 0")
("newLPRef"," \\x.liftLP (\\s.if null s then Pair 0 [Pair 0 x] else (\\r.Pair r ((Pair r x):s)) (fst (head s) + 1))")
("next"," bind get $ \\s.if null s then parseError \"end of input\" else bind_ (put (tail s)) $ return (head s)")
("nil"," \\n c. n")
("not"," \\x.if x then False else True")
("notElem"," \\c s.not (elem c s)")
("nth"," \\n l.if n == 0 then head l else nth (n-1) (tail l)")
("nub"," nubBy (\\x y.x==y)")
("nubBy"," \\eq l.if null l then [] else head l : nubBy eq (filter (\\x.not (x `eq` head l)) (tail l))")
("nullL"," list True (K (K False))")
("or"," foldr (\\x y.x||y) False")
("orLP"," \\m n dict k.m dict k . n dict k")
("pair"," \\k p.p k")
("para"," \\c n l.if null l then n else c (head l) (tail l) (para c n (tail l))")
("paraNat"," \\s z n.if n == 0 then z else s n $ paraNat s z (n-1)")
("parens"," between (char '(') (char ')')")
("parseError"," \\e m.nth 4 m e")
("parseNum"," bind (alt (bind_ (sat (\\c.c=='-')) $ return (\\x.0-x)) (return id)) $ \\op.bind (many1 (sat isDigit)) $ \\ns.return (op (foldl (\\x y.10*x+y) 0 (map charToDigit ns)))")
("parseRule"," parseTerm `bind` \\h.(symbol \":-\" `bind_` (parseTerm `sepBy1` comma) `bind` \\b.return (Pair h b)) `alt` (return (Pair h [])) `bind` \\r.dot `bind_` return r")
("parseTerm"," identifier `bind` \\h.parens ((parseTerm `sepBy1` comma) `bind` \\ts.if isUpper (head h) then parseError \"variable for constructor\" else return (Term h ts)) `alt` if isUpper (head h) then return (Var h) else return (Term h [])")
("pass"," \\e m.nth 4 m (e m)")
("piDigits"," piGen 1 0 1 1")
("piGen"," \\q r t k. (\\n.if (4*q+r)/t == n then n : piGen (10*q) (10*(r-n*t)) t k else piGen (q*k) (q*(4*k+2)+r*(2*k+1)) (t*(2*k+1)) (k+1)) ((3*q+r)/t)")
("pow"," \\b. \\n. if n == 0 then 1 else (if even n then (square (pow b (n / 2))) else (b * (pow b (n - 1))))")
("primes"," (sieve (naturals 2))")
("product"," foldl (\\x y.x*y) 1")
("prologFreevars"," nub . foldTerm (\\v.[v]) (\\_.concat)")
("prologMatch"," \\t db.(\\c.foldr orLP failed $ map (pair (\\h b.interpretTerm h [] `bind` pair (\\h' env.unify t h' `bind_` foldr (\\t' rest env'.interpretTerm t' env' `bind` pair (\\t'' env''.prologMatch t'' db `bind_` rest env'')) (const success) b env))) $ filter (\\r.getConstructor (fst r) == c) db) (getConstructor t)")
("put"," \\x m.nth 3 m x")
("rando"," \\s.(25173*s + 13849) `mod` 65536")
("random-list"," \\n. \\s. tail (take (n + 1) (iterate rando s))")
("randomList"," \\n. \\s. tail (take (n + 1) (iterate rando s))")
("readLPRef"," \\ref.liftLP (\\s.Pair (lookupRef ref s) s)")
("repeat"," iterate id")
("replicate"," \\n x.take n (iterate id x)")
("return"," \\a m.return_internal m a")
("return_internal"," nth 1")
("reverse"," foldl (\\x y.y:x) []")
("runLP"," \\m.runMonad MonadLP m (\\a f s.a:f s) (\\_.[]) []")
("runMonad"," \\m e.e m")
("sat"," \\p.bind next $ \\a.if p a then return a else get `bind` \\s.parseError (\"parse error at: \\\"\"++s++\"\\\"\")")
("scanl"," \\c n.reverse . foldl (\\x y.c (head x) y:x) [n]")
("scanr"," \\c n.foldr (\\x y.c x (head y):y) [n]")
("second"," head . tail")
("sepBy"," \\p sep.sepBy1 p sep `alt` return []")
("sepBy1"," \\p sep.p `bind` \\a.(sep `bind` \\_.sepBy p sep `bind` \\as.return (a:as)) `alt` return [a]")
("sequence"," \\l.if null l then return [] else head l `bind` (\\x.sequence (tail l) `bind` (\\xs.return (x:xs)))")
("sequence_"," foldr bind_ (return [])")
("showList"," \\se.(\\x.'[':(x++\"]\")) . concat . intersperse \", \" . map se")
("showMaybe"," \\showA.maybe \"Nothing\" (\\a.\"Just \"++showA a)")
("showNum"," \\n.(\\showNum.if n < 0 then '-':(reverse $ showNum (0-n)) else reverse $ showNum n) $ fix (\\showNum n.if n < 10 then [digitToChar n] else digitToChar (mod n 10) : showNum (n/10))")
("showPair"," \\sa sb.pair (\\a b.'(':sa a ++ ',':sb b++\")\")")
("showTerm"," showTerm' id (\\n.'_':showNum n)")
("showTerm'"," \\showAtom showVar.termCase showVar (\\a ts.if null ts then showAtom a else showAtom a++'(':concat (intersperse \",\" (map (showTerm' showAtom showVar) ts))++\")\")")
("showType"," type id (\\t1 t2.type id (\\t1 t2.'(':showType (Arrow t1 t2)++\")\") (\\vs t.'(':showType (Forall vs t)++\")\") t1 ++ \" -> \" ++ showType t2) (\\vs t.\"forall \"++concat (intersperse \" \" vs)++'.':showType t)")
("sieve"," \\l . (head l) : sieve (filter (ndivby (head l)) (tail l))")
("snd"," \\p.p (\\x y.y)")
("someMersennePrimeExponents"," [2,3,5,7,13,17,19,31,67,127,257]")
("somePerfectNumbers"," map makePerfect someMersennePrimeExponents")
("spaces"," get `bind` \\s.put (dropWhile isSpace s)")
("span"," \\p l.if null l then Pair [] [] else pair (\\ys zs.if p (head l) then Pair (head l : ys) zs else Pair [] l) (span p (tail l))")
("sqrt"," (\\x.fix (\\sqrt.\\a.if square a <= x && square (a+1) > x then a else sqrt ((a + x / a) / 2)) x)")
("square"," \\x.x*x")
("squares"," between (char '[') (char ']')")
("string"," \\s.sequence (map char s)")
("success"," return []")
("sum"," foldl (\\x y.x+y) 0")
("symbol"," lexeme . string")
("tails"," \\l.if null l then [[]] else l:tails (tail l)")
("take"," \\n l.if null l || n <= 0 then [] else head l : take (n-1) (tail l)")
("takeWhile"," \\p.unfoldr (\\s.if p (head s) then Just (Pair (head s) (tail s)) else Nothing)")
("tell"," \\w m.nth 2 m w")
("termCase"," \\var term t.t var term")
("test"," \"hello\"")
("throwError"," \\e m.nth 2 m e")
("toList"," \\l.if nullL l then [] else car l : toList (cdr l)")
("tree"," \\l b t.t l b")
("type"," \\v a q t.t v a q")
("uncurry"," \\f.pair (\\x y.f x y)")
("undefined"," undefined")
("unfoldr"," \\g n.maybe [] (pair (\\a s.a:unfoldr g s)) (g n)")
("unify"," \\a b.maybe (maybe (unifyTerm a b) (\\vb.unifyVar vb a) (isVar b)) (\\va.maybe (unifyVar va b) (\\vb.if va == vb then success else unifyVar va b) (isVar b)) (isVar a)")
("unifyTerm"," \\a b.termCase (\\_.failed) (\\aa ats.termCase (\\_.failed) (\\ba bts.if aa == ba then zipWithM_ unify ats bts else failed) b) a")
("unifyVar"," \\ref a.readLPRef ref `bind` maybe (writeLPRef ref (Just a)) (\\b.a `unify` b)")
("union"," unionBy (\\x y.x==y)")
("unionBy"," \\eq xs ys.xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs")
("unzip"," foldr (\\p ps.pair (\\l r.Pair (l:fst ps) (r:snd ps)) p) (Pair [] [])")
("updateRef"," \\k a l.if fst (head l) == k then Pair k a:tail l else head l:updateRef k a (tail l)")
("writeLPRef"," \\ref a dict k f s.k [] (f . updateRef ref (lookupRef ref s)) (updateRef ref a s)")
("zip"," zipWith Pair")
("zipWith"," \\f l r.if null l || null r then [] else f (head l) (head r) : zipWith f (tail l) (tail r)")
("zipWithM"," \\f xs ys.sequence (zipWith f xs ys)")
("zipWithM_"," \\f xs ys.sequence_ (zipWith f xs ys)")
