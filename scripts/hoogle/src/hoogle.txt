-- Generated by Hoogle, from Haddock HTML
-- (C) Neil Mitchell 2005


module Array
(!) :: Ix a => Array a b -> a -> b
(//) :: Ix a => Array a b -> [(a,b)] -> Array a b
accum :: Ix a => (b -> c -> b) -> Array a b -> [(a,c)] -> Array a b
accumArray :: Ix a => (b -> c -> b) -> b -> (a,a) -> [(a,c)] -> Array a b
array :: Ix a => (a,a) -> [(a,b)] -> Array a b
assocs :: Ix a => Array a b -> [(a,b)]
bounds :: Ix a => Array a b -> (a,a)
elems :: Ix a => Array a b -> [b]
indices :: Ix a => Array a b -> [a]
ixmap :: (Ix a, Ix b) => (a,a) -> (a -> b) -> Array b c -> Array a c
listArray :: Ix a => (a,a) -> [b] -> Array a b

module CPUTime
cpuTimePrecision :: Integer
getCPUTime :: IO Integer

module Char
chr :: Int -> Char
digitToInt :: Char -> Int
intToDigit :: Int -> Char
isAlpha :: Char -> Bool
isAlphaNum :: Char -> Bool
isAscii :: Char -> Bool
isControl :: Char -> Bool
isDigit :: Char -> Bool
isHexDigit :: Char -> Bool
isLatin1 :: a -> Bool
isLower :: Char -> Bool
isOctDigit :: Char -> Bool
isPrint :: Char -> Bool
isSpace :: Char -> Bool
isUpper :: Char -> Bool
lexLitChar :: ReadS String
ord :: Char -> Int
readLitChar :: ReadS Char
showLitChar :: Char -> ShowS
toLower :: Char -> Char
toUpper :: Char -> Char

module Complex
(:+) :: RealFloat a => a -> a -> Complex a
cis :: RealFloat a => a -> Complex a
conjugate :: RealFloat a => Complex a -> Complex a
imagPart :: RealFloat a => Complex a -> a
magnitude :: RealFloat a => Complex a -> a
mkPolar :: RealFloat a => a -> a -> Complex a
phase :: RealFloat a => Complex a -> a
polar :: RealFloat a => Complex a -> (a,a)
realPart :: RealFloat a => Complex a -> a

module Control.Arrow
(&&&) :: Arrow a => a b c -> a b c' -> a b (c,c')
(***) :: Arrow a => a b c -> a b' c' -> a (b,b') (c,c')
(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
(<<<) :: Arrow a => a c d -> a b c -> a b d
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
(>>>) :: Arrow a => a b c -> a c d -> a b d
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
ArrowMonad :: (a () b) -> ArrowMonad a b
Kleisli :: a -> m b -> Kleisli m a b
app :: ArrowApply a => a (a b c,b) c
arr :: Arrow a => (b -> c) -> a b c
class Arrow a
class Arrow a => ArrowApply a
class Arrow a => ArrowChoice a
class Arrow a => ArrowLoop a
class Arrow a => ArrowZero a
class ArrowZero a => ArrowPlus a
first :: Arrow a => a b c -> a (b,d) (c,d)
instance ArrowApply a => Monad (ArrowMonad a)
instance Monad m => Arrow (Kleisli m)
instance Monad m => ArrowApply (Kleisli m)
instance Monad m => ArrowChoice (Kleisli m)
instance MonadFix m => ArrowLoop (Kleisli m)
instance MonadPlus m => ArrowPlus (Kleisli m)
instance MonadPlus m => ArrowZero (Kleisli m)
left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
loop :: ArrowLoop a => a (b,d) (c,d) -> a b c
newtype ArrowMonad a b
newtype Kleisli m a b
pure :: Arrow a => (b -> c) -> a b c
returnA :: Arrow a => a b b
right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
runKleisli :: Kleisli m a b -> a -> m b
second :: Arrow a => a b c -> a (d,b) (d,c)
zeroArrow :: ArrowZero a => a b c

module Control.Concurrent
data ThreadId
forkIO :: IO () -> IO ThreadId
forkOS :: IO () -> IO ThreadId
instance Data ThreadId
instance Eq ThreadId
instance Ord ThreadId
instance Show ThreadId
instance Typeable ThreadId
isCurrentThreadBound :: IO Bool
killThread :: ThreadId -> IO ()
mergeIO :: [a] -> [a] -> IO [a]
myThreadId :: IO ThreadId
nmergeIO :: [[a]] -> IO [a]
rtsSupportsBoundThreads :: Bool
runInBoundThread :: IO a -> IO a
runInUnboundThread :: IO a -> IO a
threadDelay :: Int -> IO ()
threadWaitRead :: Fd -> IO ()
threadWaitWrite :: Fd -> IO ()
throwTo :: ThreadId -> Exception -> IO ()
yield :: IO ()

module Control.Concurrent.Chan
data Chan a
dupChan :: Chan a -> IO (Chan a)
getChanContents :: Chan a -> IO [a]
instance Typeable1 Chan
isEmptyChan :: Chan a -> IO Bool
newChan :: IO (Chan a)
readChan :: Chan a -> IO a
unGetChan :: Chan a -> a -> IO ()
writeChan :: Chan a -> a -> IO ()
writeList2Chan :: Chan a -> [a] -> IO ()

module Control.Concurrent.MVar
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
readMVar :: MVar a -> IO a
swapMVar :: MVar a -> a -> IO a
withMVar :: MVar a -> (a -> IO b) -> IO b

module Control.Concurrent.QSem
data QSem
instance Typeable QSem
newQSem :: Int -> IO QSem
signalQSem :: QSem -> IO ()
waitQSem :: QSem -> IO ()

module Control.Concurrent.QSemN
data QSemN
instance Typeable QSemN
newQSemN :: Int -> IO QSemN
signalQSemN :: QSemN -> Int -> IO ()
waitQSemN :: QSemN -> Int -> IO ()

module Control.Concurrent.STM
STM
atomically
catchSTM
check :: Bool -> STM a
orElse
retry

module Control.Concurrent.STM.TChan
data TChan a
dupTChan :: TChan a -> STM (TChan a)
isEmptyTChan :: TChan a -> STM Bool
newTChan :: STM (TChan a)
readTChan :: TChan a -> STM a
unGetTChan :: TChan a -> a -> STM ()
writeTChan :: TChan a -> a -> STM ()

module Control.Concurrent.STM.TMVar
data TMVar a
isEmptyTMVar :: TMVar a -> STM Bool
newEmptyTMVar :: STM (TMVar a)
newTMVar :: a -> STM (TMVar a)
putTMVar :: TMVar a -> a -> STM ()
readTMVar :: TMVar a -> STM a
swapTMVar :: TMVar a -> a -> STM a
takeTMVar :: TMVar a -> STM a
tryPutTMVar :: TMVar a -> a -> STM Bool
tryTakeTMVar :: TMVar a -> STM (Maybe a)

module Control.Concurrent.STM.TVar
TVar
newTVar
readTVar
writeTVar

module Control.Concurrent.SampleVar
emptySampleVar :: SampleVar a -> IO ()
isEmptySampleVar :: SampleVar a -> IO Bool
newEmptySampleVar :: IO (SampleVar a)
newSampleVar :: a -> IO (SampleVar a)
readSampleVar :: SampleVar a -> IO a
type SampleVar a = MVar (Int, MVar a)
writeSampleVar :: SampleVar a -> a -> IO ()

module Control.Exception
ArithException :: ArithException -> Exception
ArrayException :: ArrayException -> Exception
AssertionFailed :: String -> Exception
AsyncException :: AsyncException -> Exception
BlockedIndefinitely :: Exception
BlockedOnDeadMVar :: Exception
Deadlock :: Exception
Denormal :: ArithException
DivideByZero :: ArithException
DynException :: Dynamic -> Exception
ErrorCall :: String -> Exception
ExitException :: ExitCode -> Exception
HeapOverflow :: AsyncException
IOException :: IOException -> Exception
IndexOutOfBounds :: String -> ArrayException
LossOfPrecision :: ArithException
NoMethodError :: String -> Exception
NonTermination :: Exception
Overflow :: ArithException
PatternMatchFail :: String -> Exception
RecConError :: String -> Exception
RecSelError :: String -> Exception
RecUpdError :: String -> Exception
StackOverflow :: AsyncException
ThreadKilled :: AsyncException
UndefinedElement :: String -> ArrayException
Underflow :: ArithException
arithExceptions :: Exception -> Maybe ArithException
assert :: Bool -> a -> a
assertions :: Exception -> Maybe String
asyncExceptions :: Exception -> Maybe AsyncException
block :: IO a -> IO a
bracket_ :: IO a -> IO b -> IO c -> IO c
catch :: IO a -> (Exception -> IO a) -> IO a
catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
data ArithException
data ArrayException
data AsyncException
data Exception
data IOException
dynExceptions :: Exception -> Maybe Dynamic
errorCalls :: Exception -> Maybe String
evaluate :: a -> IO a
finally :: IO a -> IO b -> IO a
getUncaughtExceptionHandler :: IO (Exception -> IO ())
handle :: (Exception -> IO a) -> IO a -> IO a
handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
instance Eq ArithException
instance Eq ArrayException
instance Eq AsyncException
instance Eq Exception
instance Eq IOException
instance Ord ArithException
instance Ord ArrayException
instance Ord AsyncException
instance Show ArithException
instance Show ArrayException
instance Show AsyncException
instance Show Exception
instance Show IOException
instance Typeable ArithException
instance Typeable ArrayException
instance Typeable AsyncException
instance Typeable Exception
instance Typeable IOException
ioErrors :: Exception -> Maybe IOError
mapException :: (Exception -> Exception) -> a -> a
setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
throw :: Exception -> a
throwDyn :: Typeable exception => exception -> b
throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
throwIO :: Exception -> IO a
try :: IO a -> IO (Either Exception a)
tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
unblock :: IO a -> IO a
userErrors :: Exception -> Maybe String

module Control.Monad
ap :: Monad m => m (a -> b) -> m a -> m b
class Monad m => MonadPlus m
filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
guard :: MonadPlus m => Bool -> m ()
join :: Monad m => m (m a) -> m a
liftM :: Monad m => (a1 -> r) -> m a1 -> m r
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
mplus :: MonadPlus m => m a -> m a -> m a
msum :: MonadPlus m => [m a] -> m a
mzero :: MonadPlus m => m a
replicateM :: Monad m => Int -> m a -> m [a]
replicateM_ :: Monad m => Int -> m a -> m ()
unless :: Monad m => Bool -> m () -> m ()
when :: Monad m => Bool -> m () -> m ()
zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()

module Control.Monad.Cont
Cont :: ((a -> r) -> r) -> Cont r a
ContT :: ((a -> m r) -> m r) -> ContT r m a
callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
class Monad m => MonadCont m
instance Functor (Cont r)
instance Monad (Cont r)
instance Monad m => Functor (ContT r m)
instance Monad m => Monad (ContT r m)
instance Monad m => MonadCont (ContT r m)
instance MonadCont (Cont r)
instance MonadIO m => MonadIO (ContT r m)
instance MonadReader r' m => MonadReader r' (ContT r m)
instance MonadState s m => MonadState s (ContT r m)
instance MonadTrans (ContT r)
mapCont :: (r -> r) -> Cont r a -> Cont r a
mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
newtype Cont r a
newtype ContT r m a
runCont :: Cont r a -> ((a -> r) -> r)
runContT :: ContT r m a -> ((a -> m r) -> m r)
withCont :: ((b -> r) -> a -> r) -> Cont r a -> Cont r b
withContT :: ((b -> m r) -> a -> m r) -> ContT r m a -> ContT r m b

module Control.Monad.Error
ErrorT :: (m (Either e a)) -> ErrorT e m a
catchError :: MonadError e m => m a -> (e -> m a) -> m a
class Error a
class Monad m => MonadError e m 
instance (Error e, MonadCont m) => MonadCont (ErrorT e m)
instance (Error e, MonadIO m) => MonadIO (ErrorT e m)
instance (Error e, MonadReader r m) => MonadReader r (ErrorT e m)
instance (Error e, MonadState s m) => MonadState s (ErrorT e m)
instance (Error e, MonadWriter w m) => MonadWriter w (ErrorT e m)
instance (Monad m, Error e) => Monad (ErrorT e m)
instance (Monad m, Error e) => MonadError e (ErrorT e m)
instance (Monad m, Error e) => MonadPlus (ErrorT e m)
instance (MonadFix m, Error e) => MonadFix (ErrorT e m)
instance Error e => MonadTrans (ErrorT e)
instance Monad m => Functor (ErrorT e m)
mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
newtype ErrorT e m a
noMsg :: Error a => a
runErrorT :: ErrorT e m a -> (m (Either e a))
strMsg :: Error a => String -> a
throwError :: MonadError e m => e -> m a

module Control.Monad.Fix
class Monad m => MonadFix m
fix :: (a -> a) -> a
mfix :: MonadFix m => (a -> m a) -> m a

module Control.Monad.Identity
Identity :: a -> Identity a
instance Functor Identity
instance Monad Identity
instance MonadFix Identity
newtype Identity a
runIdentity :: Identity a -> a

module Control.Monad.List
ListT :: m [a] -> ListT m a
instance Monad m => Functor (ListT m)
instance Monad m => Monad (ListT m)
instance Monad m => MonadPlus (ListT m)
instance MonadCont m => MonadCont (ListT m)
instance MonadError e m => MonadError e (ListT m)
instance MonadIO m => MonadIO (ListT m)
instance MonadReader s m => MonadReader s (ListT m)
instance MonadState s m => MonadState s (ListT m)
instance MonadTrans ListT
mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b
newtype ListT m a
runListT :: ListT m a -> m [a]

module Control.Monad.RWS
RWS :: (r -> s -> (a,s,w)) -> RWS r w s a
RWST :: (r -> s -> m (a,s,w)) -> RWST r w s m a
evalRWS :: RWS r w s a -> r -> s -> (a, w)
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
execRWS :: RWS r w s a -> r -> s -> (s, w)
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
instance (Monoid w, Monad m) => Monad (RWST r w s m)
instance (Monoid w, Monad m) => MonadReader r (RWST r w s m)
instance (Monoid w, Monad m) => MonadState s (RWST r w s m)
instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m)
instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m)
instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m)
instance (Monoid w, MonadFix m) => MonadFix (RWST r w s m)
instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m)
instance (Monoid w, MonadPlus m) => MonadPlus (RWST r w s m)
instance Functor (RWS r w s)
instance Monad m => Functor (RWST r w s m)
instance Monoid w => Monad (RWS r w s)
instance Monoid w => MonadFix (RWS r w s)
instance Monoid w => MonadReader r (RWS r w s)
instance Monoid w => MonadState s (RWS r w s)
instance Monoid w => MonadTrans (RWST r w s)
instance Monoid w => MonadWriter w (RWS r w s)
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
newtype RWS r w s a
newtype RWST r w s m a
runRWS :: RWS r w s a -> (r -> s -> (a,s,w))
runRWST :: RWST r w s m a -> (r -> s -> m (a,s,w))
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

module Control.Monad.Reader
Reader :: r -> a -> Reader r a
ReaderT :: r -> m a -> ReaderT r m a
ask :: MonadReader r m => m r
asks :: MonadReader r m => (r -> a) -> m a
class Monad m => MonadReader r m 
instance Functor (Reader r)
instance Monad (Reader r)
instance Monad m => Functor (ReaderT r m)
instance Monad m => Monad (ReaderT r m)
instance Monad m => MonadReader r (ReaderT r m)
instance MonadCont m => MonadCont (ReaderT r m)
instance MonadError e m => MonadError e (ReaderT r m)
instance MonadFix (Reader r)
instance MonadFix m => MonadFix (ReaderT r m)
instance MonadIO m => MonadIO (ReaderT r m)
instance MonadPlus m => MonadPlus (ReaderT r m)
instance MonadReader r (Reader r)
instance MonadState s m => MonadState s (ReaderT r m)
instance MonadTrans (ReaderT r)
instance MonadWriter w m => MonadWriter w (ReaderT r m)
local :: MonadReader r m => (r -> r) -> m a -> m a
mapReader :: (a -> b) -> Reader r a -> Reader r b
mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
newtype Reader r a
newtype ReaderT r m a
runReader :: Reader r a -> r -> a
runReaderT :: ReaderT r m a -> r -> m a
withReader :: (r' -> r) -> Reader r a -> Reader r' a
withReaderT :: (r' -> r) -> ReaderT r m a -> ReaderT r' m a

module Control.Monad.ST
data RealWorld
data ST s a
fixST :: (a -> ST s a) -> ST s a
instance (Typeable s, Typeable a) => Data (ST s a)
instance Functor (ST s)
instance MArray (STArray s) e (ST s)
instance Monad (ST s)
instance MonadFix (ST s)
instance Show (ST s a)
instance Typeable RealWorld
instance Typeable2 ST
runST :: (ST s a) -> a
stToIO :: ST RealWorld a -> IO a
unsafeIOToST :: IO a -> ST s a
unsafeInterleaveST :: ST s a -> ST s a

module Control.Monad.ST.Lazy
lazyToStrictST :: ST s a -> ST s a
strictToLazyST :: ST s a -> ST s a

module Control.Monad.State
State :: (s -> (a,s)) -> State s a
StateT :: (s -> m (a,s)) -> StateT s m a
class Monad m => MonadState s m 
evalState :: State s a -> s -> a
evalStateT :: Monad m => StateT s m a -> s -> m a
execState :: State s a -> s -> s
execStateT :: Monad m => StateT s m a -> s -> m s
get :: MonadState s m => m s
gets :: MonadState s m => (s -> a) -> m a
instance Functor (State s)
instance Monad (State s)
instance Monad m => Functor (StateT s m)
instance Monad m => Monad (StateT s m)
instance Monad m => MonadState s (StateT s m)
instance MonadCont m => MonadCont (StateT s m)
instance MonadError e m => MonadError e (StateT s m)
instance MonadFix (State s)
instance MonadFix m => MonadFix (StateT s m)
instance MonadIO m => MonadIO (StateT s m)
instance MonadPlus m => MonadPlus (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance MonadState s (State s)
instance MonadTrans (StateT s)
instance MonadWriter w m => MonadWriter w (StateT s m)
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
modify :: MonadState s m => (s -> s) -> m ()
newtype State s a
newtype StateT s m a
put :: MonadState s m => s -> m ()
runState :: State s a -> (s -> (a,s))
runStateT :: StateT s m a -> (s -> m (a,s))
withState :: (s -> s) -> State s a -> State s a
withStateT :: (s -> s) -> StateT s m a -> StateT s m a

module Control.Monad.Trans
class Monad m => MonadIO m
class MonadTrans t
lift :: (MonadTrans t, Monad m) => m a -> t m a
liftIO :: MonadIO m => IO a -> m a

module Control.Monad.Writer
Writer :: a,w -> Writer w a
WriterT :: (m (a,w)) -> WriterT w m a
censor :: MonadWriter w m => (w -> w) -> m a -> m a
class (Monoid w, Monad m) => MonadWriter w m 
execWriter :: Writer w a -> w
execWriterT :: Monad m => WriterT w m a -> m w
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance (Monoid w, Monad m) => MonadWriter w (WriterT w m)
instance (Monoid w, MonadCont m) => MonadCont (WriterT w m)
instance (Monoid w, MonadError e m) => MonadError e (WriterT w m)
instance (Monoid w, MonadFix m) => MonadFix (WriterT w m)
instance (Monoid w, MonadIO m) => MonadIO (WriterT w m)
instance (Monoid w, MonadPlus m) => MonadPlus (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monoid w, MonadState s m) => MonadState s (WriterT w m)
instance Functor (Writer w)
instance Monad m => Functor (WriterT w m)
instance Monoid w => Monad (Writer w)
instance Monoid w => MonadFix (Writer w)
instance Monoid w => MonadTrans (WriterT w)
instance Monoid w => MonadWriter w (Writer w)
listen :: MonadWriter w m => m a -> m (a,w)
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
newtype Writer w a
newtype WriterT w m a
pass :: MonadWriter w m => m (a,w -> w) -> m a
runWriter :: Writer w a -> a,w
runWriterT :: WriterT w m a -> (m (a,w))
tell :: MonadWriter w m => w -> m ()

module Control.Parallel
par :: a -> b -> b

module Control.Parallel.Strategies
($|) :: (a -> b) -> Strategy a -> a -> b
($||) :: (a -> b) -> Strategy a -> a -> b
(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
(-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
(.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
(.||) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
(:=) :: a -> b -> Assoc a b
(>|) :: Done -> Done -> Done
(>||) :: Done -> Done -> Done
class (NFData a, Integral a) => NFDataInt
class (NFData a, Ord a) => NFDa
class NFData a
data Assoc a b
demanding :: a -> Done -> a
force :: NFData a => a -> a
fstPairFstList :: NFData a => Strategy [(a, b)]
instance (NFData a, NFData b) => NFData (Assoc a b)
parArr :: Ix b => Strategy a -> Strategy (Array b a)
parBuffer :: Int -> Strategy a -> [a] -> [a]
parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
parList :: Strategy a -> Strategy [a]
parListChunk :: Int -> Strategy a -> Strategy [a]
parListN :: Integral b => b -> Strategy a -> Strategy [a]
parListNth :: Int -> Strategy a -> Strategy [a]
parMap :: Strategy b -> (a -> b) -> [a] -> [b]
parPair :: Strategy a -> Strategy b -> Strategy (a, b)
parTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
r0 :: Strategy a
rnf :: NFData a => Strategy a
rwhnf :: Strategy a
sPar :: a -> Strategy b
sSeq :: a -> Strategy b
seqArr :: Ix b => Strategy a -> Strategy (Array b a)
seqList :: Strategy a -> Strategy [a]
seqListN :: Integral a => a -> Strategy b -> Strategy [b]
seqListNth :: Int -> Strategy b -> Strategy [b]
seqPair :: Strategy a -> Strategy b -> Strategy (a, b)
seqTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
sforce :: NFData a => a -> b -> b
sparking :: a -> Done -> a
type Done = ()
type Strategy a = a -> Done
using :: a -> Strategy a -> a

module Data.Array
(!) :: Ix i => Array i e -> i -> e
(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
array :: Ix i => (i, i) -> [(i, e)] -> Array i e
assocs :: Ix i => Array i e -> [(i, e)]
bounds :: Ix i => Array i e -> (i, i)
data Array i e
elems :: Ix i => Array i e -> [e]
indices :: Ix i => Array i e -> [i]
instance (Ix a, NFData a, NFData b) => NFData (Array a b)
instance (Ix a, Read a, Read b) => Read (Array a b)
instance (Ix a, Show a, Show b) => Show (Array a b)
instance (Ix i, Eq e) => Eq (Array i e)
instance (Ix i, Ord e) => Ord (Array i e)
instance (Typeable a, Data b, Ix a) => Data (Array a b)
instance HasBounds Array
instance IArray Array e
instance Ix i => Functor (Array i)
instance Ix i => FunctorM (Array i)
instance Typeable2 Array
ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
listArray :: Ix i => (i, i) -> [e] -> Array i e

module Data.Array.Diff
data IOToDiffArray a i e
instance HasBounds a => HasBounds (IOToDiffArray a)
instance IArray (IOToDiffArray IOArray) e
newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
readDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> Int -> IO e
replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
type DiffArray = IOToDiffArray IOArray
type DiffUArray = IOToDiffArray IOUArray

module Data.Array.IArray
(!) :: (IArray a e, Ix i) => a i e -> i -> e
(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
bounds :: (HasBounds a, Ix i) => a i e -> (i,i)
class HasBounds a
class HasBounds a => IAr
elems :: (IArray a e, Ix i) => a i e -> [e]
indices :: (HasBounds a, Ix i) => a i e -> [i]
ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e

module Data.Array.IO
castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
data IOArray i e
data IOUArray i e
hGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int
hPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()
instance Eq (IOArray i e)
instance HasBounds IOArray
instance HasBounds IOUArray
instance Typeable2 IOArray
instance Typeable2 IOUArray

module Data.Array.MArray
class (HasBounds a, Monad m) => MArray a e m
freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
getAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]
getElems :: (MArray a e m, Ix i) => a i e -> m [e]
mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
newArray :: (MArray a e m, Ix i) => (i,i) -> e -> m (a i e)
newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
newArray_ :: (MArray a e m, Ix i) => (i,i) -> m (a i e)
newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()

module Data.Array.ST
castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
data STArray s i e
data STUArray s i a
instance Eq (STArray s i e)
instance HasBounds (STArray s)
instance HasBounds (STUArray s)
instance Typeable3 STArray
instance Typeable3 STUArray
runSTArray :: Ix i => (ST s (STArray s i e)) -> Array i e
runSTUArray :: Ix i => (ST s (STUArray s i e)) -> UArray i e

module Data.Array.Storable
data StorableArray i e
instance HasBounds StorableArray
touchStorableArray :: StorableArray i e -> IO ()
withStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a

module Data.Array.Unboxed
data UArray i e
instance HasBounds UArray
instance Typeable2 UArray

module Data.Bits
(.&.) :: Bits a => a -> a -> a
(.|.) :: Bits a => a -> a -> a
bit :: Bits a => Int -> a
bitSize :: Bits a => a -> Int
class Num a => Bits a
clearBit :: Bits a => a -> Int -> a
complement :: Bits a => a -> a
complementBit :: Bits a => a -> Int -> a
isSigned :: Bits a => a -> Bool
rotate :: Bits a => a -> Int -> a
rotateL :: Bits a => a -> Int -> a
rotateR :: Bits a => a -> Int -> a
setBit :: Bits a => a -> Int -> a
shift :: Bits a => a -> Int -> a
shiftL :: Bits a => a -> Int -> a
shiftR :: Bits a => a -> Int -> a
testBit :: Bits a => a -> Int -> Bool
xor :: Bits a => a -> a -> a

module Data.Char
isLatin1 :: Char -> Bool

module Data.Complex
(:+) :: !a -> !a -> Complex a
data Complex a
instance (RealFloat a, Eq a) => Eq (Complex a)
instance (RealFloat a, NFData a) => NFData (Complex a)
instance (RealFloat a, Read a) => Read (Complex a)
instance (RealFloat a, Show a) => Show (Complex a)
instance RealFloat a => Floating (Complex a)
instance RealFloat a => Fractional (Complex a)
instance RealFloat a => Num (Complex a)
instance Typeable1 Complex
polar :: RealFloat a => Complex a -> (a, a)

module Data.Dynamic
data Dynamic
dynApp :: Dynamic -> Dynamic -> Dynamic
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
fromDyn :: Typeable a => Dynamic -> a -> a
fromDynamic :: Typeable a => Dynamic -> Maybe a
instance Show Dynamic
instance Typeable Dynamic
toDyn :: Typeable a => a -> Dynamic

module Data.FiniteMap
addListToFM :: Ord key => FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
addListToFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
addToFM :: Ord key => FiniteMap key elt -> key -> elt -> FiniteMap key elt
addToFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> key -> elt -> FiniteMap key elt
data FiniteMap key elt
delFromFM :: Ord key => FiniteMap key elt -> key -> FiniteMap key elt
delListFromFM :: Ord key => FiniteMap key elt -> [key] -> FiniteMap key elt
elemFM :: Ord key => key -> FiniteMap key elt -> Bool
eltsFM :: FiniteMap key elt -> [elt]
eltsFM_GE :: Ord key => FiniteMap key elt -> key -> [elt]
eltsFM_LE :: Ord key => FiniteMap key elt -> key -> [elt]
emptyFM :: FiniteMap key elt
filterFM :: Ord key => (key -> elt -> Bool) -> FiniteMap key elt -> FiniteMap key elt
fmToList :: FiniteMap key elt -> [(key, elt)]
fmToList_GE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
fmToList_LE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
foldFM :: (key -> elt -> a -> a) -> a -> FiniteMap key elt -> a
foldFM_GE :: Ord key => (key -> elt -> a -> a) -> a -> key -> FiniteMap key elt -> a
foldFM_LE :: Ord key => (key -> elt -> a -> a) -> a -> key -> FiniteMap key elt -> a
instance (Data a, Data b, Ord a) => Data (FiniteMap a b)
instance (Eq key, Eq elt) => Eq (FiniteMap key elt)
instance (Show k, Show e) => Show (FiniteMap k e)
instance Functor (FiniteMap k)
instance Typeable2 FiniteMap
intersectFM :: Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
intersectFM_C :: Ord key => (elt1 -> elt2 -> elt3) -> FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt3
isEmptyFM :: FiniteMap key elt -> Bool
keysFM :: FiniteMap key elt -> [key]
keysFM_GE :: Ord key => FiniteMap key elt -> key -> [key]
keysFM_LE :: Ord key => FiniteMap key elt -> key -> [key]
listToFM :: Ord key => [(key, elt)] -> FiniteMap key elt
lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
lookupWithDefaultFM :: Ord key => FiniteMap key elt -> elt -> key -> elt
mapFM :: (key -> elt1 -> elt2) -> FiniteMap key elt1 -> FiniteMap key elt2
maxFM :: Ord key => FiniteMap key elt -> Maybe key
minFM :: Ord key => FiniteMap key elt -> Maybe key
minusFM :: Ord key => FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt1
plusFM :: Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
plusFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
sizeFM :: FiniteMap key elt -> Int
unitFM :: key -> elt -> FiniteMap key elt

module Data.FunctorM
class FunctorM f
fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()

module Data.Generics.Aliases
GM :: Data a => a -> m a -> GenericM' m
GQ :: GenericQ r -> GenericQ' r
GT :: Data a => a -> a -> GenericT'
Generic' :: Generic c -> Generic' c
choiceMp :: MonadPlus m => GenericM m -> GenericM m -> GenericM m
choiceQ :: MonadPlus m => GenericQ (m r) -> GenericQ (m r) -> GenericQ (m r)
data Generic' c
ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
ext1M :: (Monad m, Data d, Typeable1 t) => (d -> m d) -> (t d -> m (t d)) -> d -> m d
ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t d -> q) -> d -> q
ext1R :: (Monad m, Data d, Typeable1 t) => m d -> (m (t d)) -> m d
ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
extB :: (Typeable a, Typeable b) => a -> b -> a
extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
extR :: (Monad m, Typeable a, Typeable b) => m a -> m b -> m a
extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
mkM :: (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
mkMp :: (MonadPlus m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
mkR :: (MonadPlus m, Typeable a, Typeable b) => m b -> m a
mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
newtype GenericM' m
newtype GenericQ' r
newtype GenericT'
orElse :: Maybe a -> Maybe a -> Maybe a
recoverMp :: MonadPlus m => GenericM m -> GenericM m
recoverQ :: MonadPlus m => r -> GenericQ (m r) -> GenericQ (m r)
type Generic c = a -> c a
type GenericB = a
type GenericM m = a -> m a
type GenericQ r = a -> r
type GenericR m = m a
type GenericT = a -> a
unGM :: Data a => GenericM' m -> a -> m a
unGQ :: GenericQ' r -> GenericQ r
unGT :: Data a => GenericT' -> a -> a
unGeneric' :: Generic' c -> Generic c

module Data.Generics.Basics
AlgConstr :: ConIndex -> ConstrRep
AlgRep :: [Constr] -> DataRep
FloatConstr :: Double -> ConstrRep
FloatRep :: DataRep
Infix :: Fixity
IntConstr :: Integer -> ConstrRep
IntRep :: DataRep
NoRep :: DataRep
Prefix :: Fixity
StringConstr :: String -> ConstrRep
StringRep :: DataRep
class Typeable a => Data a
constrFields :: Constr -> [String]
constrFixity :: Constr -> Fixity
constrIndex :: Constr -> ConIndex
constrRep :: Constr -> ConstrRep
constrType :: Constr -> DataType
data Constr
data ConstrRep
data DataRep
data DataType
data Fixity
dataCast1 :: (Data a, Typeable1 t) => (c (t a)) -> Maybe (c a)
dataCast2 :: (Data a, Typeable2 t) => (c (t a b)) -> Maybe (c a)
dataTypeConstrs :: DataType -> [Constr]
dataTypeName :: DataType -> String
dataTypeOf :: Data a => a -> DataType
dataTypeRep :: DataType -> DataRep
fromConstr :: Data a => Constr -> a
fromConstrB :: Data a => (a) -> Constr -> a
fromConstrM :: (Monad m, Data a) => (m a) -> Constr -> m a
gfoldl :: Data a => (c (a -> b) -> a -> c b) -> (g -> c g) -> a -> c a
gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
gmapQ :: Data a => (a -> u) -> a -> [u]
gmapQi :: Data a => Int -> (a -> u) -> a -> u
gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
gmapT :: Data a => (b -> b) -> a -> a
gunfold :: Data a => (c (b -> r) -> c r) -> (r -> c r) -> Constr -> c a
indexConstr :: DataType -> ConIndex -> Constr
instance Data DataType
instance Eq Constr
instance Eq ConstrRep
instance Eq DataRep
instance Eq Fixity
instance Show Constr
instance Show ConstrRep
instance Show DataRep
instance Show DataType
instance Show Fixity
instance Typeable DataType
isAlgType :: DataType -> Bool
isNorepType :: DataType -> Bool
maxConstrIndex :: DataType -> ConIndex
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr
mkDataType :: String -> [Constr] -> DataType
mkFloatConstr :: DataType -> Double -> Constr
mkFloatType :: String -> DataType
mkIntConstr :: DataType -> Integer -> Constr
mkIntType :: String -> DataType
mkNorepType :: String -> DataType
mkStringConstr :: DataType -> String -> Constr
mkStringType :: String -> DataType
readConstr :: DataType -> String -> Maybe Constr
repConstr :: DataType -> ConstrRep -> Constr
showConstr :: Constr -> String
toConstr :: Data a => a -> Constr
tyconModule :: String -> String
tyconUQname :: String -> String
type ConIndex = Int

module Data.Generics.Schemes
everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
everywhere :: (a -> a) -> a -> a
everywhere' :: (a -> a) -> a -> a
everywhereBut :: GenericQ Bool -> GenericT -> GenericT
everywhereM :: Monad m => GenericM m -> GenericM m
gcount :: GenericQ Bool -> GenericQ Int
gdepth :: GenericQ Int
gfindtype :: (Data x, Typeable y) => x -> Maybe y
glength :: GenericQ Int
gnodecount :: GenericQ Int
gsize :: Data a => a -> Int
gtypecount :: Typeable a => a -> GenericQ Int
listify :: Typeable r => (r -> Bool) -> GenericQ [r]
something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
somewhere :: MonadPlus m => GenericM m -> GenericM m
synthesize :: s -> (s -> s -> s) -> GenericQ (s -> s) -> GenericQ s

module Data.Generics.Text
gread :: Data a => ReadS a
gshow :: Data a => a -> String

module Data.Generics.Twins
geq :: Data a => a -> a -> Bool
gfoldlAccum :: Data d => (a -> c (d -> r) -> d -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
gmapAccumM :: (Data d, Monad m) => (a -> d -> (a, m d)) -> a -> d -> (a, m d)
gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)
gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)
gmapAccumT :: Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)
gzip :: (a -> b -> Maybe b) -> a -> b -> Maybe b
gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
gzipWithQ :: GenericQ (GenericQ r) -> GenericQ (GenericQ [r])
gzipWithT :: GenericQ GenericT -> GenericQ GenericT

module Data.Graph
AcyclicSCC :: vertex -> SCC vertex
CyclicSCC :: [vertex] -> SCC vertex
bcc :: Graph -> Forest [Vertex]
buildG :: Bounds -> [Edge] -> Graph
components :: Graph -> Forest Vertex
data SCC vertex
dff :: Graph -> Forest Vertex
dfs :: Graph -> [Vertex] -> Forest Vertex
edges :: Graph -> [Edge]
flattenSCC :: SCC vertex -> [vertex]
flattenSCCs :: [SCC a] -> [a]
graphFromEdges :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)
graphFromEdges' :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]))
indegree :: Graph -> Table Int
outdegree :: Graph -> Table Int
path :: Graph -> Vertex -> Vertex -> Bool
reachable :: Graph -> Vertex -> [Vertex]
scc :: Graph -> Forest Vertex
stronglyConnComp :: Ord key => [(node, key, [key])] -> [SCC node]
stronglyConnCompR :: Ord key => [(node, key, [key])] -> [SCC (node, key, [key])]
topSort :: Graph -> [Vertex]
transposeG :: Graph -> Graph
type Bounds = (Vertex, Vertex)
type Edge = (Vertex, Vertex)
type Graph = Table [Vertex]
type Table a = Array Vertex a
type Vertex = Int
vertices :: Graph -> [Vertex]

module Data.Graph.Inductive
version :: IO ()

module Data.Graph.Inductive.Basic
efilter :: DynGraph gr => (LEdge b -> Bool) -> gr a b -> gr a b
elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
gfold :: Graph gr => (Context a b -> [Node]) -> (Context a b -> c -> d) -> (Maybe d -> c -> c, c) -> [Node] -> gr a b -> c
grev :: DynGraph gr => gr a b -> gr a b
gsel :: Graph gr => (Context a b -> Bool) -> gr a b -> [Context a b]
hasLoop :: Graph gr => gr a b -> Bool
isSimple :: Graph gr => gr a b -> Bool
postorder :: Tree a -> [a]
postorderF :: [Tree a] -> [a]
preorder :: Tree a -> [a]
preorderF :: [Tree a] -> [a]
undir :: (Eq b, DynGraph gr) => gr a b -> gr a b
unlab :: DynGraph gr => gr a b -> gr () ()

module Data.Graph.Inductive.Example
a :: Gr Char ()
a' :: IO (SGr Char ())
ab :: Gr Char ()
ab' :: IO (SGr Char ())
abb :: Gr Char ()
abb' :: IO (SGr Char ())
b :: Gr Char ()
b' :: IO (SGr Char ())
c :: Gr Char ()
c' :: IO (SGr Char ())
clr479 :: Gr Char ()
clr479' :: IO (SGr Char ())
clr486 :: Gr String ()
clr486' :: IO (SGr String ())
clr489 :: Gr Char ()
clr489' :: IO (SGr Char ())
clr508 :: Gr Char Int
clr508' :: IO (SGr Char Int)
clr528 :: Gr Char Int
clr528' :: IO (SGr Char Int)
clr595 :: Gr Int Int
cyc3 :: Gr Char String
d1 :: Gr Int Int
d1' :: IO (SGr Int Int)
d3 :: Gr Int Int
d3' :: IO (SGr Int Int)
dag3 :: Gr Char ()
dag3' :: IO (SGr Char ())
dag4 :: Gr Int ()
dag4' :: IO (SGr Int ())
e :: Gr Char ()
e' :: IO (SGr Char ())
e3 :: Gr () String
e3' :: IO (SGr () String)
g3 :: Gr Char String
g3b :: Gr Char String
genLNodes :: Enum a => a -> Int -> [LNode a]
genUNodes :: Int -> [UNode]
gr1 :: Gr Int Int
kin248 :: Gr Int ()
kin248' :: IO (SGr Int ())
labUEdges :: [Edge] -> [UEdge]
loop :: Gr Char ()
loop' :: IO (SGr Char ())
noEdges :: [UEdge]
star :: Graph gr => Int -> gr () ()
starM :: GraphM m gr => Int -> m (gr () ())
ucycle :: Graph gr => Int -> gr () ()
ucycleM :: GraphM m gr => Int -> m (gr () ())
vor :: Gr String Int
vor' :: IO (SGr String Int)

module Data.Graph.Inductive.Graph
(&) :: DynGraph gr => Context a b -> gr a b -> gr a b
LP :: [LNode a] -> LPath a
buildGr :: DynGraph gr => [Context a b] -> gr a b
class Graph gr
class Graph gr => DynGraph gr
context :: Graph gr => gr a b -> Node -> Context a b
deg :: Graph gr => gr a b -> Node -> Int
deg' :: Context a b -> Int
delEdge :: DynGraph gr => Edge -> gr a b -> gr a b
delEdges :: DynGraph gr => [Edge] -> gr a b -> gr a b
delNode :: Graph gr => Node -> gr a b -> gr a b
delNodes :: Graph gr => [Node] -> gr a b -> gr a b
edges :: Graph gr => gr a b -> [Edge]
emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
empty :: Graph gr => gr a b
equal :: (Eq a, Eq b, Graph gr) => gr a b -> gr a b -> Bool
gelem :: Graph gr => Node -> gr a b -> Bool
gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
indeg :: Graph gr => gr a b -> Node -> Int
indeg' :: Context a b -> Int
inn :: Graph gr => gr a b -> Node -> [LEdge b]
inn' :: Context a b -> [LEdge b]
insEdge :: DynGraph gr => LEdge b -> gr a b -> gr a b
insEdges :: DynGraph gr => [LEdge b] -> gr a b -> gr a b
insNode :: DynGraph gr => LNode a -> gr a b -> gr a b
insNodes :: DynGraph gr => [LNode a] -> gr a b -> gr a b
instance Eq a => Eq (LPath a)
instance Ord a => Ord (LPath a)
instance Show a => Show (LPath a)
isEmpty :: Graph gr => gr a b -> Bool
lab :: Graph gr => gr a b -> Node -> Maybe a
lab' :: Context a b -> a
labEdges :: Graph gr => gr a b -> [LEdge b]
labNode' :: Context a b -> LNode a
labNodes :: Graph gr => gr a b -> [LNode a]
lpre :: Graph gr => gr a b -> Node -> [(Node, b)]
lpre' :: Context a b -> [(Node, b)]
lsuc :: Graph gr => gr a b -> Node -> [(Node, b)]
lsuc' :: Context a b -> [(Node, b)]
match :: Graph gr => Node -> gr a b -> Decomp gr a b
matchAny :: Graph gr => gr a b -> GDecomp gr a b
mkGraph :: Graph gr => [LNode a] -> [LEdge b] -> gr a b
mkUGraph :: Graph gr => [Node] -> [Edge] -> gr () ()
neighbors :: Graph gr => gr a b -> Node -> [Node]
neighbors' :: Context a b -> [Node]
newNodes :: Graph gr => Int -> gr a b -> [Node]
newtype LPath a
nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
noNodes :: Graph gr => gr a b -> Int
node' :: Context a b -> Node
nodeRange :: Graph gr => gr a b -> (Node,Node)
nodes :: Graph gr => gr a b -> [Node]
out :: Graph gr => gr a b -> Node -> [LEdge b]
out' :: Context a b -> [LEdge b]
outdeg :: Graph gr => gr a b -> Node -> Int
outdeg' :: Context a b -> Int
pre :: Graph gr => gr a b -> Node -> [Node]
pre' :: Context a b -> [Node]
suc :: Graph gr => gr a b -> Node -> [Node]
suc' :: Context a b -> [Node]
type Adj b = [(b, Node)]
type Context a b = (Adj b, Node, a, Adj b)
type Decomp g a b = (MContext a b, g a b)
type Edge = (Node, Node)
type GDecomp g a b = (Context a b, g a b)
type LEdge b = (Node, Node, b)
type LNode a = (Node, a)
type MContext a b = Maybe (Context a b)
type Node = Int
type UContext = ([Node], Node, [Node])
type UDecomp g = (Maybe UContext, g)
type UEdge = LEdge ()
type UNode = LNode ()
type UPath = [UNode]
ufold :: Graph gr => (Context a b -> c -> c) -> c -> gr a b -> c

module Data.Graph.Inductive.Graphviz
Landscape :: Orient
Portrait :: Orient
data Orient
graphviz :: (Graph g, Show a, Show b) => g a b -> String -> (Double, Double) -> (Int, Int) -> Orient -> String
graphviz' :: (Graph g, Show a, Show b) => g a b -> String
instance Eq Orient
instance Show Orient

module Data.Graph.Inductive.Internal.FiniteMap
Empty :: FiniteMap a b
Node :: Int -> (FiniteMap a b) -> (a,b) -> (FiniteMap a b) -> FiniteMap a b
accumFM :: Ord a => FiniteMap a b -> a -> (b -> b -> b) -> b -> FiniteMap a b
addToFM :: Ord a => FiniteMap a b -> a -> b -> FiniteMap a b
data FiniteMap a b
delFromFM :: Ord a => FiniteMap a b -> a -> FiniteMap a b
elemFM :: Ord a => FiniteMap a b -> a -> Bool
emptyFM :: Ord a => FiniteMap a b
fmToList :: Ord a => FiniteMap a b -> [(a, b)]
instance (Ord a, ??? a b) => Eq (FiniteMap a b)
instance (Show a, Show b, Ord a) => Show (FiniteMap a b)
isEmptyFM :: FiniteMap a b -> Bool
lookupFM :: Ord a => FiniteMap a b -> a -> Maybe b
maxFM :: Ord a => FiniteMap a b -> Maybe (a, b)
minFM :: Ord a => FiniteMap a b -> Maybe (a, b)
predFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
rangeFM :: Ord a => FiniteMap a b -> a -> a -> [b]
sizeFM :: Ord a => FiniteMap a b -> Int
splitFM :: Ord a => FiniteMap a b -> a -> Maybe (FiniteMap a b, (a, b))
splitMinFM :: Ord a => FiniteMap a b -> Maybe (FiniteMap a b, (a, b))
succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
updFM :: Ord a => FiniteMap a b -> a -> (b -> b) -> FiniteMap a b

module Data.Graph.Inductive.Internal.Heap
Empty :: Heap a b
Node :: a -> b -> [Heap a b] -> Heap a b
build :: Ord a => [(a, b)] -> Heap a b
data Heap a b
deleteMin :: Ord a => Heap a b -> Heap a b
empty :: Ord a => Heap a b
findMin :: Ord a => Heap a b -> (a, b)
heapsort :: Ord a => [a] -> [a]
insert :: Ord a => (a, b) -> Heap a b -> Heap a b
instance (Ord a, Eq a, Eq b, ??? a b) => Eq (Heap a b)
instance (Show a, Ord a, Show b) => Show (Heap a b)
isEmpty :: Ord a => Heap a b -> Bool
merge :: Ord a => Heap a b -> Heap a b -> Heap a b
mergeAll :: Ord a => [Heap a b] -> Heap a b
splitMin :: Ord a => Heap a b -> (a, b, Heap a b)
toList :: Ord a => Heap a b -> [(a, b)]
unit :: Ord a => a -> b -> Heap a b

module Data.Graph.Inductive.Internal.Queue
MkQueue :: [a] -> [a] -> Queue a
mkQueue :: Queue a
queueEmpty :: Queue a -> Bool
queueGet :: Queue a -> (a, Queue a)
queuePut :: a -> Queue a -> Queue a
queuePutList :: [a] -> Queue a -> Queue a

module Data.Graph.Inductive.Internal.RootPath
getDistance :: Node -> LRTree a -> a
getLPath :: Node -> LRTree a -> LPath a
getLPathNodes :: Node -> LRTree a -> Path
getPath :: Node -> RTree -> Path
type LRTree a = [LPath a]
type RTree = [Path]

module Data.Graph.Inductive.Internal.Thread
splitPar :: Split t i r -> Split u j s -> Split (t, u) (i, j) (r, s)
splitParM :: SplitM t i r -> Split u j s -> SplitM (t, u) (i, j) (r, s)
threadList :: Collect r c -> Split t i r -> [i] -> t -> (c, t)
threadList' :: Collect r c -> Split t i r -> [i] -> t -> (c, t)
threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
type Collect r c = (r -> c -> c, c)
type Split t i r = i -> t -> (r, t)
type SplitM t i r = Split t i (Maybe r)
type Thread t i r = (t, Split t i r)

module Data.Graph.Inductive.Monad
class Monad m => GraphM m gr
contextM :: GraphM m gr => m (gr a b) -> Node -> m (Context a b)
delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
delNodesM :: GraphM m gr => [Node] -> m (gr a b) -> m (gr a b)
edgesM :: GraphM m gr => m (gr a b) -> m [Edge]
emptyM :: GraphM m gr => m (gr a b)
isEmptyM :: GraphM m gr => m (gr a b) -> m Bool
labEdgesM :: GraphM m gr => m (gr a b) -> m [LEdge b]
labM :: GraphM m gr => m (gr a b) -> Node -> m (Maybe a)
labNodesM :: GraphM m gr => m (gr a b) -> m [LNode a]
matchAnyM :: GraphM m gr => m (gr a b) -> m (GDecomp gr a b)
matchM :: GraphM m gr => Node -> m (gr a b) -> m (Decomp gr a b)
mkGraphM :: GraphM m gr => [LNode a] -> [LEdge b] -> m (gr a b)
mkUGraphM :: GraphM m gr => [Node] -> [Edge] -> m (gr () ())
newNodesM :: GraphM m gr => Int -> m (gr a b) -> m [Node]
noNodesM :: GraphM m gr => m (gr a b) -> m Int
nodeRangeM :: GraphM m gr => m (gr a b) -> m (Node,Node)
nodesM :: GraphM m gr => m (gr a b) -> m [Node]
ufoldM :: GraphM m gr => (Context a b -> c -> c) -> c -> m (gr a b) -> m c

module Data.Graph.Inductive.Monad.IOArray
SGr :: (GraphRep a b) -> SGr a b
data SGr a b
defaultGraphSize :: Int
emptyN :: Int -> IO (SGr a b)
instance (Show a, Show b) => Show (IO (SGr a b))
instance (Show a, Show b) => Show (SGr a b)
instance GraphM IO SGr
removeDel :: IOArray Node Bool -> Adj b -> IO (Adj b)
type Context' a b = Maybe (Adj b, a, Adj b)
type GraphRep a b = (Int, Array Node (Context' a b), IOArray Node Bool)
type USGr = SGr () ()

module Data.Graph.Inductive.NodeMap
data NodeMap a
delMapEdge :: (Ord a, DynGraph g) => NodeMap a -> (a, a) -> g a b -> g a b
delMapEdgeM :: (Ord a, DynGraph g) => (a, a) -> NodeMapM a b g ()
delMapEdges :: (Ord a, DynGraph g) => NodeMap a -> [(a, a)] -> g a b -> g a b
delMapEdgesM :: (Ord a, DynGraph g) => [(a, a)] -> NodeMapM a b g ()
delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
delMapNodeM :: (Ord a, DynGraph g) => a -> NodeMapM a b g ()
delMapNodes :: (Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> g a b
delMapNodesM :: (Ord a, DynGraph g) => [a] -> NodeMapM a b g ()
fromGraph :: (Ord a, Graph g) => g a b -> NodeMap a
insMapEdge :: (Ord a, DynGraph g) => NodeMap a -> (a, a, b) -> g a b -> g a b
insMapEdgeM :: (Ord a, DynGraph g) => (a, a, b) -> NodeMapM a b g ()
insMapEdges :: (Ord a, DynGraph g) => NodeMap a -> [(a, a, b)] -> g a b -> g a b
insMapEdgesM :: (Ord a, DynGraph g) => [(a, a, b)] -> NodeMapM a b g ()
insMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> (g a b, NodeMap a, LNode a)
insMapNodeM :: (Ord a, DynGraph g) => a -> NodeMapM a b g (LNode a)
insMapNode_ :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
insMapNodes :: (Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> (g a b, NodeMap a, [LNode a])
insMapNodesM :: (Ord a, DynGraph g) => [a] -> NodeMapM a b g [LNode a]
insMapNodes_ :: (Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> g a b
instance (Ord a, ??? a) => Show (NodeMap a)
mkEdge :: Ord a => NodeMap a -> (a, a, b) -> Maybe (LEdge b)
mkEdgeM :: (Ord a, DynGraph g) => (a, a, b) -> NodeMapM a b g (Maybe (LEdge b))
mkEdges :: Ord a => NodeMap a -> [(a, a, b)] -> Maybe [LEdge b]
mkEdgesM :: (Ord a, DynGraph g) => [(a, a, b)] -> NodeMapM a b g (Maybe [LEdge b])
mkMapGraph :: (Ord a, DynGraph g) => [a] -> [(a, a, b)] -> (g a b, NodeMap a)
mkNode :: Ord a => NodeMap a -> a -> (LNode a, NodeMap a)
mkNodeM :: (Ord a, DynGraph g) => a -> NodeMapM a b g (LNode a)
mkNode_ :: Ord a => NodeMap a -> a -> LNode a
mkNodes :: Ord a => NodeMap a -> [a] -> ([LNode a], NodeMap a)
mkNodesM :: (Ord a, DynGraph g) => [a] -> NodeMapM a b g [LNode a]
mkNodes_ :: Ord a => NodeMap a -> [a] -> [LNode a]
new :: Ord a => NodeMap a
run :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> (r, (NodeMap a, g a b))
run_ :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> g a b
type NodeMapM a b g r = State (NodeMap a, g a b) r

module Data.Graph.Inductive.Query.ArtPoint
ap :: Graph gr => gr a b -> [Node]

module Data.Graph.Inductive.Query.BCC
bcc :: DynGraph gr => gr a b -> [gr a b]

module Data.Graph.Inductive.Query.BFS
bfe :: Graph gr => Node -> gr a b -> [Edge]
bfen :: Graph gr => [Edge] -> gr a b -> [Edge]
bfs :: Graph gr => Node -> gr a b -> [Node]
bfsWith :: Graph gr => (Context a b -> c) -> Node -> gr a b -> [c]
bfsn :: Graph gr => [Node] -> gr a b -> [Node]
bfsnWith :: Graph gr => (Context a b -> c) -> [Node] -> gr a b -> [c]
bft :: Graph gr => Node -> gr a b -> RTree
esp :: Graph gr => Node -> Node -> gr a b -> Path
lbft :: Graph gr => Node -> gr a b -> LRTree b
lesp :: Graph gr => Node -> Node -> gr a b -> LPath b
level :: Graph gr => Node -> gr a b -> [(Node, Int)]
leveln :: Graph gr => [(Node, Int)] -> gr a b -> [(Node, Int)]

module Data.Graph.Inductive.Query.DFS
components :: Graph gr => gr a b -> [[Node]]
dff :: Graph gr => [Node] -> gr a b -> [Tree Node]
dff' :: Graph gr => gr a b -> [Tree Node]
dffWith :: Graph gr => CFun a b c -> [Node] -> gr a b -> [Tree c]
dffWith' :: Graph gr => CFun a b c -> gr a b -> [Tree c]
dfs :: Graph gr => [Node] -> gr a b -> [Node]
dfs' :: Graph gr => gr a b -> [Node]
dfsWith :: Graph gr => CFun a b c -> [Node] -> gr a b -> [c]
dfsWith' :: Graph gr => CFun a b c -> gr a b -> [c]
isConnected :: Graph gr => gr a b -> Bool
noComponents :: Graph gr => gr a b -> Int
rdff :: Graph gr => [Node] -> gr a b -> [Tree Node]
rdff' :: Graph gr => gr a b -> [Tree Node]
rdfs :: Graph gr => [Node] -> gr a b -> [Node]
rdfs' :: Graph gr => gr a b -> [Node]
reachable :: Graph gr => Node -> gr a b -> [Node]
scc :: Graph gr => gr a b -> [[Node]]
topsort :: Graph gr => gr a b -> [Node]
topsort' :: Graph gr => gr a b -> [a]
type CFun a b c = Context a b -> c
udff :: Graph gr => [Node] -> gr a b -> [Tree Node]
udff' :: Graph gr => gr a b -> [Tree Node]
udfs :: Graph gr => [Node] -> gr a b -> [Node]
udfs' :: Graph gr => gr a b -> [Node]

module Data.Graph.Inductive.Query.Dominators
dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]

module Data.Graph.Inductive.Query.GVD
gvdIn :: (DynGraph gr, Real b) => [Node] -> gr a b -> Voronoi b
gvdOut :: (Graph gr, Real b) => [Node] -> gr a b -> Voronoi b
nearestDist :: Real b => Node -> Voronoi b -> Maybe b
nearestNode :: Real b => Node -> Voronoi b -> Maybe Node
nearestPath :: Real b => Node -> Voronoi b -> Maybe Path
type Voronoi a = LRTree a
voronoiSet :: Real b => Node -> Voronoi b -> [Node]

module Data.Graph.Inductive.Query.Indep
indep :: DynGraph gr => gr a b -> [Node]

module Data.Graph.Inductive.Query.MST
msPath :: Real b => LRTree b -> Node -> Node -> Path
msTree :: (Graph gr, Real b) => gr a b -> LRTree b
msTreeAt :: (Graph gr, Real b) => Node -> gr a b -> LRTree b

module Data.Graph.Inductive.Query.MaxFlow
augmentGraph :: (DynGraph gr, Num b, Ord b) => gr a b -> gr a (b, b, b)
getRevEdges :: (Num b, Ord b) => [(Node, Node)] -> [(Node, Node, b)]
maxFlow :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> b
maxFlowgraph :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> gr a (b, b)
mf :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> gr a (b, b, b)
mfmg :: (DynGraph gr, Num b, Ord b) => gr a (b, b, b) -> Node -> Node -> gr a (b, b, b)
updAdjList :: (Num b, Ord b) => [((b, b, b), Node)] -> Node -> b -> Bool -> [((b, b, b), Node)]
updateFlow :: (DynGraph gr, Num b, Ord b) => Path -> b -> gr a (b, b, b) -> gr a (b, b, b)

module Data.Graph.Inductive.Query.MaxFlow2
ekFused :: Network -> Node -> Node -> (Network, Double)
ekList :: Network -> Node -> Node -> (Network, Double)
ekSimple :: Network -> Node -> Node -> (Network, Double)
type Network = Gr () (Double, Double)

module Data.Graph.Inductive.Query.Monad
(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
MGT :: (m g -> m (a,g)) -> GT m g a
apply :: GT m g a -> m g -> m (a, g)
apply' :: Monad m => GT m g a -> g -> m (a, g)
applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
applyWith' :: Monad m => (a -> b) -> GT m g a -> g -> m (b, g)
condMGT :: Monad m => (m s -> m Bool) -> GT m s a -> GT m s a -> GT m s a
condMGT' :: Monad m => (s -> Bool) -> GT m s a -> GT m s a -> GT m s a
data GT m g a
dffM :: GraphM m gr => [Node] -> GT m (gr a b) [Tree Node]
dfsGT :: GraphM m gr => [Node] -> GT m (gr a b) [Node]
dfsM :: GraphM m gr => [Node] -> m (gr a b) -> m [Node]
dfsM' :: GraphM m gr => m (gr a b) -> m [Node]
getContext :: GraphM m gr => GT m (gr a b) (Context a b)
getNode :: GraphM m gr => GT m (gr a b) Node
getNodes :: GraphM m gr => GT m (gr a b) [Node]
getNodes' :: (Graph gr, GraphM m gr) => GT m (gr a b) [Node]
graphDff :: GraphM m gr => [Node] -> m (gr a b) -> m [Tree Node]
graphDff' :: GraphM m gr => m (gr a b) -> m [Tree Node]
graphFilter :: GraphM m gr => (Context a b -> Bool) -> m (gr a b) -> m [Context a b]
graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
graphNodes :: GraphM m gr => m (gr a b) -> m [Node]
graphNodesM :: GraphM m gr => GT m (gr a b) [Node]
graphNodesM0 :: GraphM m gr => GT m (gr a b) [Node]
graphRec :: GraphM m gr => GT m (gr a b) c -> (c -> d -> d) -> d -> GT m (gr a b) d
graphRec' :: (Graph gr, GraphM m gr) => GT m (gr a b) c -> (c -> d -> d) -> d -> GT m (gr a b) d
graphUFold :: GraphM m gr => (Context a b -> c -> c) -> c -> GT m (gr a b) c
instance Monad m => Monad (GT m g)
mapFst :: (a -> b) -> (a, c) -> (b, c)
mapSnd :: (a -> b) -> (c, a) -> (c, b)
orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
recMGT :: Monad m => (m s -> m Bool) -> GT m s a -> (a -> b -> b) -> b -> GT m s b
recMGT' :: Monad m => (s -> Bool) -> GT m s a -> (a -> b -> b) -> b -> GT m s b
runGT :: Monad m => GT m g a -> m g -> m a
sucGT :: GraphM m gr => Node -> GT m (gr a b) (Maybe [Node])
sucM :: GraphM m gr => Node -> m (gr a b) -> m (Maybe [Node])

module Data.Graph.Inductive.Query.SP
dijkstra :: (Graph gr, Real b) => Heap b (LPath b) -> gr a b -> LRTree b
sp :: (Graph gr, Real b) => Node -> Node -> gr a b -> Path
spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
spTree :: (Graph gr, Real b) => Node -> gr a b -> LRTree b

module Data.Graph.Inductive.Query.TransClos
trc :: DynGraph gr => gr a b -> gr a ()

module Data.Graph.Inductive.Tree
data Gr a b
instance (Show a, Show b) => Show (Gr a b)
instance DynGraph Gr
instance Graph Gr
type UGr = Gr () ()

module Data.HashTable
data HashTable key val
delete :: HashTable key val -> key -> IO ()
fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
hashInt :: Int -> Int32
hashString :: String -> Int32
insert :: HashTable key val -> key -> val -> IO ()
longestChain :: HashTable key val -> IO [(key, val)]
lookup :: HashTable key val -> key -> IO (Maybe val)
new :: (key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)
prime :: Int32
toList :: HashTable key val -> IO [(key, val)]
update :: HashTable key val -> key -> val -> IO Bool

module Data.IORef
atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
data IORef a
instance Eq (IORef a)
instance Typeable a => Data (IORef a)
instance Typeable1 IORef
mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))
modifyIORef :: IORef a -> (a -> a) -> IO ()
newIORef :: a -> IO (IORef a)
readIORef :: IORef a -> IO a
writeIORef :: IORef a -> a -> IO ()

module Data.Int
data Int16
data Int32
data Int64
data Int8
instance (Ix ix, Show ix) => Show (DiffUArray ix Int16)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int32)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int64)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int8)
instance (Ix ix, Show ix) => Show (UArray ix Int16)
instance (Ix ix, Show ix) => Show (UArray ix Int32)
instance (Ix ix, Show ix) => Show (UArray ix Int64)
instance (Ix ix, Show ix) => Show (UArray ix Int8)
instance Bits Int16
instance Bits Int32
instance Bits Int64
instance Bits Int8
instance Bounded Int16
instance Bounded Int32
instance Bounded Int64
instance Bounded Int8
instance Data Int16
instance Data Int32
instance Data Int64
instance Data Int8
instance Enum Int16
instance Enum Int32
instance Enum Int64
instance Enum Int8
instance Eq Int16
instance Eq Int32
instance Eq Int64
instance Eq Int8
instance IArray (IOToDiffArray IOUArray) Int16
instance IArray (IOToDiffArray IOUArray) Int32
instance IArray (IOToDiffArray IOUArray) Int64
instance IArray (IOToDiffArray IOUArray) Int8
instance IArray UArray Int16
instance IArray UArray Int32
instance IArray UArray Int64
instance IArray UArray Int8
instance Integral Int16
instance Integral Int32
instance Integral Int64
instance Integral Int8
instance Ix Int16
instance Ix Int32
instance Ix Int64
instance Ix Int8
instance Ix ix => Eq (UArray ix Int16)
instance Ix ix => Eq (UArray ix Int32)
instance Ix ix => Eq (UArray ix Int64)
instance Ix ix => Eq (UArray ix Int8)
instance Ix ix => Ord (UArray ix Int16)
instance Ix ix => Ord (UArray ix Int32)
instance Ix ix => Ord (UArray ix Int64)
instance Ix ix => Ord (UArray ix Int8)
instance MArray (STUArray s) Int16 (ST s)
instance MArray (STUArray s) Int32 (ST s)
instance MArray (STUArray s) Int64 (ST s)
instance MArray (STUArray s) Int8 (ST s)
instance Num Int16
instance Num Int32
instance Num Int64
instance Num Int8
instance Ord Int16
instance Ord Int32
instance Ord Int64
instance Ord Int8
instance Read Int16
instance Read Int32
instance Read Int64
instance Read Int8
instance Real Int16
instance Real Int32
instance Real Int64
instance Real Int8
instance Show Int16
instance Show Int32
instance Show Int64
instance Show Int8
instance Storable Int16
instance Storable Int32
instance Storable Int64
instance Storable Int8
instance Typeable Int16
instance Typeable Int32
instance Typeable Int64
instance Typeable Int8

module Data.IntMap
(!) :: IntMap a -> Key -> a
(\\) :: IntMap a -> IntMap b -> IntMap a
adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
adjustWithKey :: (Key -> a -> a) -> Key -> IntMap a -> IntMap a
assocs :: IntMap a -> [(Key, a)]
data IntMap a
delete :: Key -> IntMap a -> IntMap a
difference :: IntMap a -> IntMap b -> IntMap a
differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
differenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
elems :: IntMap a -> [a]
empty :: IntMap a
filter :: (a -> Bool) -> IntMap a -> IntMap a
filterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a
findWithDefault :: a -> Key -> IntMap a -> a
fold :: (a -> b -> b) -> b -> IntMap a -> b
foldWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
fromAscList :: [(Key, a)] -> IntMap a
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
fromDistinctAscList :: [(Key, a)] -> IntMap a
fromList :: [(Key, a)] -> IntMap a
fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
insert :: Key -> a -> IntMap a -> IntMap a
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
instance Data a => Data (IntMap a)
instance Eq a => Eq (IntMap a)
instance Functor IntMap
instance Ord a => Monoid (IntMap a)
instance Ord a => Ord (IntMap a)
instance Show a => Show (IntMap a)
instance Typeable1 IntMap
intersection :: IntMap a -> IntMap b -> IntMap a
intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
isSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
keys :: IntMap a -> [Key]
keysSet :: IntMap a -> IntSet
lookup :: Key -> IntMap a -> Maybe a
map :: (a -> b) -> IntMap a -> IntMap b
mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
member :: Key -> IntMap a -> Bool
null :: IntMap a -> Bool
partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
partitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
showTree :: Show a => IntMap a -> String
showTreeWith :: Show a => Bool -> Bool -> IntMap a -> String
singleton :: Key -> a -> IntMap a
size :: IntMap a -> Int
split :: Key -> IntMap a -> (IntMap a, IntMap a)
splitLookup :: Key -> IntMap a -> (IntMap a, Maybe a, IntMap a)
toAscList :: IntMap a -> [(Key, a)]
toList :: IntMap a -> [(Key, a)]
type Key = Int
union :: IntMap a -> IntMap a -> IntMap a
unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unions :: [IntMap a] -> IntMap a
unionsWith :: (a -> a -> a) -> [IntMap a] -> IntMap a
update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
updateWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a

module Data.IntSet
(\\) :: IntSet -> IntSet -> IntSet
data IntSet
delete :: Int -> IntSet -> IntSet
difference :: IntSet -> IntSet -> IntSet
elems :: IntSet -> [Int]
empty :: IntSet
filter :: (Int -> Bool) -> IntSet -> IntSet
fold :: (Int -> b -> b) -> b -> IntSet -> b
fromAscList :: [Int] -> IntSet
fromDistinctAscList :: [Int] -> IntSet
fromList :: [Int] -> IntSet
insert :: Int -> IntSet -> IntSet
instance Data IntSet
instance Eq IntSet
instance Monoid IntSet
instance Ord IntSet
instance Show IntSet
instance Typeable IntSet
intersection :: IntSet -> IntSet -> IntSet
isProperSubsetOf :: IntSet -> IntSet -> Bool
isSubsetOf :: IntSet -> IntSet -> Bool
map :: (Int -> Int) -> IntSet -> IntSet
member :: Int -> IntSet -> Bool
null :: IntSet -> Bool
partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
showTree :: IntSet -> String
showTreeWith :: Bool -> Bool -> IntSet -> String
singleton :: Int -> IntSet
size :: IntSet -> Int
split :: Int -> IntSet -> (IntSet, IntSet)
splitMember :: Int -> IntSet -> (IntSet, Bool, IntSet)
toAscList :: IntSet -> [Int]
toList :: IntSet -> [Int]
union :: IntSet -> IntSet -> IntSet
unions :: [IntSet] -> IntSet

module Data.Ix
class Ord a => Ix a

module Data.List
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
elemIndex :: Eq a => a -> [a] -> Maybe Int
foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl1' :: (a -> a -> a) -> [a] -> a
genericDrop :: Integral i => i -> [a] -> [a]
genericLength :: Num i => [b] -> i
genericReplicate :: Integral i => i -> a -> [a]
genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
genericTake :: Integral i => i -> [a] -> [a]
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
maximumBy :: (a -> a -> Ordering) -> [a] -> a
minimumBy :: (a -> a -> Ordering) -> [a] -> a
partition :: (a -> Bool) -> [a] -> ([a], [a])
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

module Data.Map
(!) :: Ord k => Map k a -> k -> a
(\\) :: Ord k => Map k a -> Map k b -> Map k a
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
assocs :: Map k a -> [(k, a)]
data Map k a
delete :: Ord k => k -> Map k a -> Map k a
deleteAt :: Int -> Map k a -> Map k a
deleteFindMax :: Map k a -> ((k, a), Map k a)
deleteFindMin :: Map k a -> ((k, a), Map k a)
deleteMax :: Map k a -> Map k a
deleteMin :: Map k a -> Map k a
difference :: Ord k => Map k a -> Map k b -> Map k a
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
elemAt :: Int -> Map k a -> (k, a)
elems :: Map k a -> [a]
empty :: Map k a
filter :: Ord k => (a -> Bool) -> Map k a -> Map k a
filterWithKey :: Ord k => (k -> a -> Bool) -> Map k a -> Map k a
findIndex :: Ord k => k -> Map k a -> Int
findMax :: Map k a -> (k, a)
findMin :: Map k a -> (k, a)
findWithDefault :: Ord k => a -> k -> Map k a -> a
fold :: (a -> b -> b) -> b -> Map k a -> b
foldWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
fromAscList :: Eq k => [(k, a)] -> Map k a
fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctAscList :: [(k, a)] -> Map k a
fromList :: Ord k => [(k, a)] -> Map k a
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
insert :: Ord k => k -> a -> Map k a -> Map k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
instance (Data k, Data a, Ord k) => Data (Map k a)
instance (Eq k, Eq a) => Eq (Map k a)
instance (Ord k, Ord v) => Ord (Map k v)
instance (Show k, Show a) => Show (Map k a)
instance Functor (Map k)
instance Ord k => Monoid (Map k v)
instance Typeable2 Map
intersection :: Ord k => Map k a -> Map k b -> Map k a
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
isProperSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
keys :: Map k a -> [k]
keysSet :: Map k a -> Set k
lookup :: (Monad m, Ord k) => k -> Map k a -> m a
lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
map :: (a -> b) -> Map k a -> Map k b
mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
member :: Ord k => k -> Map k a -> Bool
null :: Map k a -> Bool
partition :: Ord k => (a -> Bool) -> Map k a -> (Map k a, Map k a)
partitionWithKey :: Ord k => (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
showTree :: (Show k, Show a) => Map k a -> String
showTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String
singleton :: k -> a -> Map k a
size :: Map k a -> Int
split :: Ord k => k -> Map k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
toAscList :: Map k a -> [(k, a)]
toList :: Map k a -> [(k, a)]
union :: Ord k => Map k a -> Map k a -> Map k a
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
unions :: Ord k => [Map k a] -> Map k a
unionsWith :: Ord k => (a -> a -> a) -> [Map k a] -> Map k a
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
updateMax :: (a -> Maybe a) -> Map k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMin :: (a -> Maybe a) -> Map k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
valid :: Ord k => Map k a -> Bool

module Data.Monoid
class Monoid a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
mempty :: Monoid a => a

module Data.PackedString
appendPS :: PackedString -> PackedString -> PackedString
breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
concatPS :: [PackedString] -> PackedString
consPS :: Char -> PackedString -> PackedString
data PackedString
dropPS :: Int -> PackedString -> PackedString
dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
elemPS :: Char -> PackedString -> Bool
filterPS :: (Char -> Bool) -> PackedString -> PackedString
foldlPS :: (a -> Char -> a) -> a -> PackedString -> a
foldrPS :: (Char -> a -> a) -> a -> PackedString -> a
hGetPS :: Handle -> Int -> IO PackedString
hPutPS :: Handle -> PackedString -> IO ()
headPS :: PackedString -> Char
indexPS :: PackedString -> Int -> Char
instance Eq PackedString
instance Ord PackedString
instance Show PackedString
instance Typeable PackedString
joinPS :: PackedString -> [PackedString] -> PackedString
lengthPS :: PackedString -> Int
linesPS :: PackedString -> [PackedString]
mapPS :: (Char -> Char) -> PackedString -> PackedString
nilPS :: PackedString
nullPS :: PackedString -> Bool
packString :: String -> PackedString
reversePS :: PackedString -> PackedString
spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
splitPS :: Char -> PackedString -> [PackedString]
splitWithPS :: (Char -> Bool) -> PackedString -> [PackedString]
substrPS :: PackedString -> Int -> Int -> PackedString
tailPS :: PackedString -> PackedString
takePS :: Int -> PackedString -> PackedString
takeWhilePS :: (Char -> Bool) -> PackedString -> PackedString
unlinesPS :: [PackedString] -> PackedString
unpackPS :: PackedString -> String
unwordsPS :: [PackedString] -> PackedString
wordsPS :: PackedString -> [PackedString]

module Data.Queue
addToQueue :: Queue a -> a -> Queue a
data Queue a
deQueue :: Queue a -> Maybe (a, Queue a)
emptyQueue :: Queue a
instance Functor Queue
instance Typeable1 Queue
listToQueue :: [a] -> Queue a
queueToList :: Queue a -> [a]

module Data.Ratio
data Ratio a
instance (Data a, Integral a) => Data (Ratio a)
instance (Integral a, Eq a) => Eq (Ratio a)
instance (Integral a, NFData a) => NFData (Ratio a)
instance (Integral a, Read a) => Read (Ratio a)
instance Integral a => Enum (Ratio a)
instance Integral a => Fractional (Ratio a)
instance Integral a => Num (Ratio a)
instance Integral a => Ord (Ratio a)
instance Integral a => Real (Ratio a)
instance Integral a => RealFrac (Ratio a)
instance Integral a => Show (Ratio a)
instance Typeable1 Ratio

module Data.STRef
data STRef s a
instance Eq (STRef s a)
instance Typeable2 STRef
modifySTRef :: STRef s a -> (a -> a) -> ST s ()
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()

module Data.Set
(\\) :: Ord a => Set a -> Set a -> Set a
addToSet :: Ord a => Set a -> a -> Set a
cardinality :: Set a -> Int
data Set a
delFromSet :: Ord a => Set a -> a -> Set a
delete :: Ord a => a -> Set a -> Set a
deleteFindMax :: Set a -> (a, Set a)
deleteFindMin :: Set a -> (a, Set a)
deleteMax :: Set a -> Set a
deleteMin :: Set a -> Set a
difference :: Ord a => Set a -> Set a -> Set a
elementOf :: Ord a => a -> Set a -> Bool
elems :: Set a -> [a]
empty :: Set a
emptySet :: Set a
filter :: Ord a => (a -> Bool) -> Set a -> Set a
findMax :: Set a -> a
findMin :: Set a -> a
fold :: (a -> b -> b) -> b -> Set a -> b
fromAscList :: Eq a => [a] -> Set a
fromDistinctAscList :: [a] -> Set a
fromList :: Ord a => [a] -> Set a
insert :: Ord a => a -> Set a -> Set a
instance (Data a, Ord a) => Data (Set a)
instance Eq a => Eq (Set a)
instance Ord a => Monoid (Set a)
instance Ord a => Ord (Set a)
instance Show a => Show (Set a)
instance Typeable1 Set
intersect :: Ord a => Set a -> Set a -> Set a
intersection :: Ord a => Set a -> Set a -> Set a
isEmptySet :: Set a -> Bool
isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
isSubsetOf :: Ord a => Set a -> Set a -> Bool
map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
mapMonotonic :: (a -> b) -> Set a -> Set b
mapSet :: (Ord a, Ord b) => (b -> a) -> Set b -> Set a
member :: Ord a => a -> Set a -> Bool
minusSet :: Ord a => Set a -> Set a -> Set a
mkSet :: Ord a => [a] -> Set a
null :: Set a -> Bool
partition :: Ord a => (a -> Bool) -> Set a -> (Set a, Set a)
setToList :: Set a -> [a]
showTree :: Show a => Set a -> String
showTreeWith :: Show a => Bool -> Bool -> Set a -> String
singleton :: a -> Set a
size :: Set a -> Int
split :: Ord a => a -> Set a -> (Set a, Set a)
splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)
toAscList :: Set a -> [a]
toList :: Set a -> [a]
union :: Ord a => Set a -> Set a -> Set a
unionManySets :: Ord a => [Set a] -> Set a
unions :: Ord a => [Set a] -> Set a
unitSet :: a -> Set a
valid :: Ord a => Set a -> Bool

module Data.Tree
Node :: a -> Forest a -> Tree a
data Tree a
drawForest :: Forest String -> String
drawTree :: Tree String -> String
flatten :: Tree a -> [a]
instance Eq a => Eq (Tree a)
instance Functor Tree
instance Read a => Read (Tree a)
instance Show a => Show (Tree a)
levels :: Tree a -> [[a]]
rootLabel :: Tree a -> a
subForest :: Tree a -> Forest a
type Forest a = [Tree a]
unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
unfoldTree :: (b -> (a, [b])) -> b -> Tree a
unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)

module Data.Typeable
cast :: (Typeable a, Typeable b) => a -> Maybe b
class Typeable a
class Typeable1 t
class Typeable2 t
class Typeable3 t
class Typeable4 t
class Typeable5 t
class Typeable6 t
class Typeable7 t
data TyCon
data TypeRep
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))
instance Data TyCon
instance Data TypeRep
instance Eq TyCon
instance Eq TypeRep
instance Show TyCon
instance Show TypeRep
instance Typeable TyCon
instance Typeable TypeRep
mkAppTy :: TypeRep -> TypeRep -> TypeRep
mkFunTy :: TypeRep -> TypeRep -> TypeRep
mkTyCon :: String -> TyCon
mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
tyConString :: TyCon -> String
typeOf :: Typeable a => a -> TypeRep
typeOf1 :: Typeable1 t => t a -> TypeRep
typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
typeOf2 :: Typeable2 t => t a b -> TypeRep
typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
typeOf3 :: Typeable3 t => t a b c -> TypeRep
typeOf3Default :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
typeOf4 :: Typeable4 t => t a b c d -> TypeRep
typeOf4Default :: (Typeable5 t, Typeable a) => t a b c d e -> TypeRep
typeOf5 :: Typeable5 t => t a b c d e -> TypeRep
typeOf5Default :: (Typeable6 t, Typeable a) => t a b c d e f -> TypeRep
typeOf6 :: Typeable6 t => t a b c d e f -> TypeRep
typeOf6Default :: (Typeable7 t, Typeable a) => t a b c d e f g -> TypeRep
typeOf7 :: Typeable7 t => t a b c d e f g -> TypeRep
typeOfDefault :: (Typeable1 t, Typeable a) => t a -> TypeRep
typeRepArgs :: TypeRep -> [TypeRep]
typeRepTyCon :: TypeRep -> TyCon

module Data.Unique
data Unique
hashUnique :: Unique -> Int
instance Eq Unique
instance Ord Unique
newUnique :: IO Unique

module Data.Version
Version :: [Int] -> [String] -> Version
data Version
instance Eq Version
instance Ord Version
instance Read Version
instance Show Version
instance Typeable Version
parseVersion :: ReadP Version
showVersion :: Version -> String
versionBranch :: Version -> [Int]
versionTags :: Version -> [String]

module Data.Word
data Word
data Word16
data Word32
data Word64
data Word8
instance (Ix ix, Show ix) => Show (DiffUArray ix Word)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word16)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word32)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word64)
instance (Ix ix, Show ix) => Show (DiffUArray ix Word8)
instance (Ix ix, Show ix) => Show (UArray ix Word)
instance (Ix ix, Show ix) => Show (UArray ix Word16)
instance (Ix ix, Show ix) => Show (UArray ix Word32)
instance (Ix ix, Show ix) => Show (UArray ix Word64)
instance (Ix ix, Show ix) => Show (UArray ix Word8)
instance Bits Word
instance Bits Word16
instance Bits Word32
instance Bits Word64
instance Bits Word8
instance Bounded Word
instance Bounded Word16
instance Bounded Word32
instance Bounded Word64
instance Bounded Word8
instance Data Word
instance Data Word16
instance Data Word32
instance Data Word64
instance Data Word8
instance Enum Word
instance Enum Word16
instance Enum Word32
instance Enum Word64
instance Enum Word8
instance Eq Word
instance Eq Word16
instance Eq Word32
instance Eq Word64
instance Eq Word8
instance IArray (IOToDiffArray IOUArray) Word
instance IArray (IOToDiffArray IOUArray) Word16
instance IArray (IOToDiffArray IOUArray) Word32
instance IArray (IOToDiffArray IOUArray) Word64
instance IArray (IOToDiffArray IOUArray) Word8
instance IArray UArray Word
instance IArray UArray Word16
instance IArray UArray Word32
instance IArray UArray Word64
instance IArray UArray Word8
instance Integral Word
instance Integral Word16
instance Integral Word32
instance Integral Word64
instance Integral Word8
instance Ix Word
instance Ix Word16
instance Ix Word32
instance Ix Word64
instance Ix Word8
instance Ix ix => Eq (UArray ix Word)
instance Ix ix => Eq (UArray ix Word16)
instance Ix ix => Eq (UArray ix Word32)
instance Ix ix => Eq (UArray ix Word64)
instance Ix ix => Eq (UArray ix Word8)
instance Ix ix => Ord (UArray ix Word)
instance Ix ix => Ord (UArray ix Word16)
instance Ix ix => Ord (UArray ix Word32)
instance Ix ix => Ord (UArray ix Word64)
instance Ix ix => Ord (UArray ix Word8)
instance MArray (STUArray s) Word (ST s)
instance MArray (STUArray s) Word16 (ST s)
instance MArray (STUArray s) Word32 (ST s)
instance MArray (STUArray s) Word64 (ST s)
instance MArray (STUArray s) Word8 (ST s)
instance Num Word
instance Num Word16
instance Num Word32
instance Num Word64
instance Num Word8
instance Ord Word
instance Ord Word16
instance Ord Word32
instance Ord Word64
instance Ord Word8
instance Read Word
instance Read Word16
instance Read Word32
instance Read Word64
instance Read Word8
instance Real Word
instance Real Word16
instance Real Word32
instance Real Word64
instance Real Word8
instance Show Word
instance Show Word16
instance Show Word32
instance Show Word64
instance Show Word8
instance Storable Word
instance Storable Word16
instance Storable Word32
instance Storable Word64
instance Storable Word8
instance Typeable Word
instance Typeable Word16
instance Typeable Word32
instance Typeable Word64
instance Typeable Word8

module Debug.Trace
putTraceMsg :: String -> IO ()
trace :: String -> a -> a

module Directory
createDirectory :: FilePath -> IO ()
doesDirectoryExist :: FilePath -> IO Bool
doesFileExist :: FilePath -> IO Bool
executable :: Permissions -> Bool
getCurrentDirectory :: IO FilePath
getDirectoryContents :: FilePath -> IO [FilePath]
getModificationTime :: FilePath -> IO ClockTime
getPermissions :: FilePath -> IO Permissions
readable :: Permissions -> Bool
removeDirectory :: FilePath -> IO ()
removeFile :: FilePath -> IO ()
renameDirectory :: FilePath -> FilePath -> IO ()
renameFile :: FilePath -> FilePath -> IO ()
searchable :: Permissions -> Bool
setCurrentDirectory :: FilePath -> IO ()
setPermissions :: FilePath -> Permissions -> IO ()
writable :: Permissions -> Bool

module Distribution.Compat.Directory
copyFile
createDirectoryIfMissing
findExecutable
getHomeDirectory
removeDirectoryRecursive

module Distribution.Compat.Exception
bracket
finally

module Distribution.Compat.FilePath
FilePath
breakFilePath :: FilePath -> [String]
changeFileExt :: FilePath -> String -> FilePath
commonParent :: [FilePath] -> Maybe FilePath
dllExtension :: String
dropAbsolutePrefix :: FilePath -> FilePath
dropPrefix :: FilePath -> FilePath -> FilePath
exeExtension :: String
isAbsolutePath :: FilePath -> Bool
isPathSeparator :: Char -> Bool
isRootedPath :: FilePath -> Bool
joinFileExt :: String -> String -> FilePath
joinFileName :: String -> String -> FilePath
joinPaths :: FilePath -> FilePath -> FilePath
mkSearchPath :: [FilePath] -> String
objExtension :: String
parseSearchPath :: String -> [FilePath]
pathParents :: FilePath -> [FilePath]
pathSeparator :: Char
searchPathSeparator :: Char
splitFileExt :: FilePath -> (String, String)
splitFileName :: FilePath -> (String, String)
splitFilePath :: FilePath -> (String, String, String)

module Distribution.Extension
AllowIncoherentInstances :: Extension
AllowOverlappingInstances :: Extension
AllowUndecidableInstances :: Extension
Arrows :: Extension
CPP :: Extension
ContextStack :: Extension
EmptyDataDecls :: Extension
ExistentialQuantification :: Extension
ExtensibleRecords :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ForeignFunctionInterface :: Extension
FunctionalDependencies :: Extension
Generics :: Extension
HereDocuments :: Extension
ImplicitParams :: Extension
InlinePhase :: Extension
MultiParamTypeClasses :: Extension
NamedFieldPuns :: Extension
NoImplicitPrelude :: Extension
NoMonomorphismRestriction :: Extension
OverlappingInstances :: Extension
ParallelListComp :: Extension
PolymorphicComponents :: Extension
RankNTypes :: Extension
RecursiveDo :: Extension
RestrictedTypeSynonyms :: Extension
ScopedTypeVariables :: Extension
TemplateHaskell :: Extension
TypeSynonymInstances :: Extension
UnsafeOverlappingInstances :: Extension
data Extension
extensionsToGHCFlag :: [Extension] -> ([Extension], [Opt])
extensionsToHugsFlag :: [Extension] -> ([Extension], [Opt])
extensionsToNHCFlag :: [Extension] -> ([Extension], [Opt])
instance Eq Extension
instance Read Extension
instance Show Extension
type Opt = String

module Distribution.GetOpt
NoArg :: a -> ArgDescr a
OptArg :: (Maybe String -> a) -> String -> ArgDescr a
Option :: [Char] -> [String] -> (ArgDescr a) -> String -> OptDescr a
Permute :: ArgOrder a
ReqArg :: (String -> a) -> String -> ArgDescr a
RequireOrder :: ArgOrder a
ReturnInOrder :: (String -> a) -> ArgOrder a
data ArgDescr a
data ArgOrder a
data OptDescr a
getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
usageInfo :: String -> [OptDescr a] -> String

module Distribution.InstalledPackageInfo
InstalledPackageInfo :: PackageIdentifier -> License -> String -> String -> String -> String -> String -> String -> String -> String -> Bool -> [String] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [String] -> [FilePath] -> [String] -> [PackageIdentifier] -> [Opt] -> [Opt] -> [Opt] -> [FilePath] -> [String] -> [FilePath] -> [FilePath] -> InstalledPackageInfo
ParseFailed :: PError -> ParseResult a
ParseOk :: a -> ParseResult a
author :: InstalledPackageInfo -> String
category :: InstalledPackageInfo -> String
ccOptions :: InstalledPackageInfo -> [Opt]
copyright :: InstalledPackageInfo -> String
data InstalledPackageInfo
data ParseResult a
depends :: InstalledPackageInfo -> [PackageIdentifier]
description :: InstalledPackageInfo -> String
emptyInstalledPackageInfo :: InstalledPackageInfo
exposed :: InstalledPackageInfo -> Bool
exposedModules :: InstalledPackageInfo -> [String]
extraLibraries :: InstalledPackageInfo -> [String]
frameworkDirs :: InstalledPackageInfo -> [FilePath]
frameworks :: InstalledPackageInfo -> [String]
haddockHTMLs :: InstalledPackageInfo -> [FilePath]
haddockInterfaces :: InstalledPackageInfo -> [FilePath]
hiddenModules :: InstalledPackageInfo -> [String]
homepage :: InstalledPackageInfo -> String
hsLibraries :: InstalledPackageInfo -> [String]
hugsOptions :: InstalledPackageInfo -> [Opt]
importDirs :: InstalledPackageInfo -> [FilePath]
includeDirs :: InstalledPackageInfo -> [FilePath]
includes :: InstalledPackageInfo -> [String]
instance Monad ParseResult
instance Read InstalledPackageInfo
instance Show InstalledPackageInfo
instance Show a => Show (ParseResult a)
ldOptions :: InstalledPackageInfo -> [Opt]
libraryDirs :: InstalledPackageInfo -> [FilePath]
license :: InstalledPackageInfo -> License
maintainer :: InstalledPackageInfo -> String
package :: InstalledPackageInfo -> PackageIdentifier
parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
pkgUrl :: InstalledPackageInfo -> String
showInstalledPackageInfo :: InstalledPackageInfo -> String
showInstalledPackageInfoField :: String -> Maybe (InstalledPackageInfo -> String)
stability :: InstalledPackageInfo -> String

module Distribution.License
AllRightsReserved :: License
BSD3 :: License
BSD4 :: License
GPL :: License
LGPL :: License
OtherLicense :: License
PublicDomain :: License
data License
instance Eq License
instance Read License
instance Show License

module Distribution.Package
PackageIdentifier :: String -> Version -> PackageIdentifier
data PackageIdentifier
instance Eq PackageIdentifier
instance Read PackageIdentifier
instance Show PackageIdentifier
parsePackageId :: ReadP r PackageIdentifier
parsePackageName :: ReadP r String
pkgName :: PackageIdentifier -> String
pkgVersion :: PackageIdentifier -> Version
showPackageId :: PackageIdentifier -> String

module Distribution.PackageDescription
BuildInfo :: Bool -> [String] -> [String] -> [String] -> [FilePath] -> FilePath -> [String] -> [Extension] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [(CompilerFlavor,[String])] -> BuildInfo
Executable :: String -> FilePath -> BuildInfo -> Executable
Library :: [String] -> BuildInfo -> Library
PackageDescription :: PackageIdentifier -> License -> FilePath -> String -> String -> String -> String -> [(CompilerFlavor,VersionRange)] -> String -> String -> String -> String -> String -> [Dependency] -> Maybe Library -> [Executable] -> PackageDescription
StanzaField :: String -> a -> Doc -> LineNo -> String -> a -> ParseResult a -> StanzaField a
author :: PackageDescription -> String
basicStanzaFields :: [StanzaField PackageDescription]
buildDepends :: PackageDescription -> [Dependency]
buildInfo :: Executable -> BuildInfo
buildable :: BuildInfo -> Bool
cSources :: BuildInfo -> [FilePath]
category :: PackageDescription -> String
ccOptions :: BuildInfo -> [String]
copyright :: PackageDescription -> String
data BuildInfo
data Executable
data Library
data PError
data PackageDescription
data StanzaField a
description :: PackageDescription -> String
emptyBuildInfo :: BuildInfo
emptyHookedBuildInfo :: HookedBuildInfo
emptyPackageDescription :: PackageDescription
errorOut :: [String] -> [String] -> IO ()
exeModules :: PackageDescription -> [String]
exeName :: Executable -> String
executables :: PackageDescription -> [Executable]
exposedModules :: Library -> [String]
extensions :: BuildInfo -> [Extension]
extraLibDirs :: BuildInfo -> [String]
extraLibs :: BuildInfo -> [String]
fieldGet :: StanzaField a -> a -> Doc
fieldName :: StanzaField a -> String
fieldSet :: StanzaField a -> LineNo -> String -> a -> ParseResult a
frameworks :: BuildInfo -> [String]
hasLibs :: PackageDescription -> Bool
hcOptions :: CompilerFlavor -> [(CompilerFlavor, [String])] -> [String]
homepage :: PackageDescription -> String
hsSourceDir :: BuildInfo -> FilePath
includeDirs :: BuildInfo -> [FilePath]
includes :: BuildInfo -> [FilePath]
instance Eq BuildInfo
instance Eq Executable
instance Eq Library
instance Eq PackageDescription
instance Read BuildInfo
instance Read Executable
instance Read Library
instance Read PackageDescription
instance Show BuildInfo
instance Show Executable
instance Show Library
instance Show PError
instance Show PackageDescription
ldOptions :: BuildInfo -> [String]
libBuildInfo :: Library -> BuildInfo
libModules :: PackageDescription -> [String]
library :: PackageDescription -> Maybe Library
license :: PackageDescription -> License
licenseFile :: PackageDescription -> FilePath
maintainer :: PackageDescription -> String
modulePath :: Executable -> FilePath
options :: BuildInfo -> [(CompilerFlavor,[String])]
otherModules :: BuildInfo -> [String]
package :: PackageDescription -> PackageIdentifier
parseDescription :: String -> ParseResult PackageDescription
parseHookedBuildInfo :: String -> ParseResult HookedBuildInfo
pkgUrl :: PackageDescription -> String
readHookedBuildInfo :: FilePath -> IO HookedBuildInfo
readPackageDescription :: FilePath -> IO PackageDescription
sanityCheckPackage :: PackageDescription -> IO ([String], [String])
setupMessage :: String -> PackageDescription -> IO ()
showError :: PError -> String
showHookedBuildInfo :: HookedBuildInfo -> String
showPackageDescription :: PackageDescription -> String
stability :: PackageDescription -> String
synopsis :: PackageDescription -> String
testedWith :: PackageDescription -> [(CompilerFlavor,VersionRange)]
type HookedBuildInfo = (Maybe BuildInfo, [(String, BuildInfo)])
type LineNo = Int
updatePackageDescription :: HookedBuildInfo -> PackageDescription -> PackageDescription
withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
withLib :: PackageDescription -> a -> (Library -> IO a) -> IO a
writeHookedBuildInfo :: FilePath -> HookedBuildInfo -> IO ()
writePackageDescription :: FilePath -> PackageDescription -> IO ()

module Distribution.PreProcess
knownSuffixHandlers :: [PPSuffixHandler]
ppAlex :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppC2hs :: PreProcessor
ppCpp :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppCpp' :: [String] -> BuildInfo -> LocalBuildInfo -> PreProcessor
ppGreenCard :: PreProcessor
ppHappy :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppHsc2hs :: BuildInfo -> LocalBuildInfo -> PreProcessor
ppSuffixes :: [PPSuffixHandler] -> [String]
ppUnlit :: PreProcessor
preprocessSources :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()
removePreprocessed :: FilePath -> [String] -> [String] -> IO ()
removePreprocessedPackage :: PackageDescription -> FilePath -> [String] -> IO ()
type PPSuffixHandler = (String, BuildInfo -> LocalBuildInfo -> PreProcessor)
type PreProcessor = FilePath -> FilePath -> Int -> IO ExitCode

module Distribution.PreProcess.Unlit
plain :: String -> String -> String
unlit :: String -> String -> String

module Distribution.Setup
BuildCmd :: Action
CleanCmd :: Action
Compiler :: CompilerFlavor -> Version -> FilePath -> FilePath -> Compiler
ConfigCmd :: ConfigFlags -> Action
ConfigFlags :: Maybe CompilerFlavor -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Int -> Bool -> ConfigFlags
CopyCmd :: (Maybe FilePath) -> Action
GHC :: CompilerFlavor
HBC :: CompilerFlavor
HaddockCmd :: Action
Helium :: CompilerFlavor
HelpCmd :: Action
Hugs :: CompilerFlavor
InstallCmd :: Bool -> Action
NHC :: CompilerFlavor
OtherCompiler :: String -> CompilerFlavor
ProgramaticaCmd :: Action
RegisterCmd :: Bool -> Bool -> Action
SDistCmd :: Action
UnregisterCmd :: Bool -> Bool -> Action
compilerFlavor :: Compiler -> CompilerFlavor
compilerPath :: Compiler -> FilePath
compilerPkgTool :: Compiler -> FilePath
compilerVersion :: Compiler -> Version
configAlex :: ConfigFlags -> Maybe FilePath
configCpphs :: ConfigFlags -> Maybe FilePath
configHaddock :: ConfigFlags -> Maybe FilePath
configHappy :: ConfigFlags -> Maybe FilePath
configHcFlavor :: ConfigFlags -> Maybe CompilerFlavor
configHcPath :: ConfigFlags -> Maybe FilePath
configHcPkg :: ConfigFlags -> Maybe FilePath
configHsc2hs :: ConfigFlags -> Maybe FilePath
configPrefix :: ConfigFlags -> Maybe FilePath
configUser :: ConfigFlags -> Bool
configVerbose :: ConfigFlags -> Int
data Action
data Compiler
data CompilerFlavor
data ConfigFlags
instance Eq Action
instance Eq Compiler
instance Eq CompilerFlavor
instance Eq ConfigFlags
instance Read Compiler
instance Read CompilerFlavor
instance Show Action
instance Show Compiler
instance Show CompilerFlavor
instance Show ConfigFlags
parseBuildArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
parseConfigureArgs :: ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
parseCopyArgs :: CopyFlags -> [String] -> [OptDescr a] -> IO (CopyFlags, [a], [String])
parseGlobalArgs :: [String] -> IO (Action, [String])
parseHaddockArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
parseInstallArgs :: InstallFlags -> [String] -> [OptDescr a] -> IO (InstallFlags, [a], [String])
parseProgramaticaArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
parseRegisterArgs :: RegisterFlags -> [String] -> [OptDescr a] -> IO (RegisterFlags, [a], [String])
parseSDistArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
parseUnregisterArgs :: RegisterFlags -> [String] -> [OptDescr a] -> IO (RegisterFlags, [a], [String])
type CopyFlags = (Maybe FilePath, Int)
type InstallFlags = (Bool, Int)
type RegisterFlags = (Bool, Bool, Int)

module Distribution.Simple
UserHooks :: Args -> Bool -> LocalBuildInfo -> IO ExitCode -> (IO (Maybe PackageDescription)) -> [PPSuffixHandler] -> Args -> ConfigFlags -> IO HookedBuildInfo -> Args -> ConfigFlags -> LocalBuildInfo -> IO ExitCode -> Args -> Int -> IO HookedBuildInfo -> Args -> Int -> LocalBuildInfo -> IO ExitCode -> Args -> Int -> IO HookedBuildInfo -> Args -> Int -> LocalBuildInfo -> IO ExitCode -> Args -> CopyFlags -> IO HookedBuildInfo -> Args -> CopyFlags -> LocalBuildInfo -> IO ExitCode -> Args -> InstallFlags -> IO HookedBuildInfo -> Args -> InstallFlags -> LocalBuildInfo -> IO ExitCode -> Args -> Int -> IO HookedBuildInfo -> Args -> Int -> LocalBuildInfo -> IO ExitCode -> Args -> RegisterFlags -> IO HookedBuildInfo -> Args -> RegisterFlags -> LocalBuildInfo -> IO ExitCode -> Args -> RegisterFlags -> IO HookedBuildInfo -> Args -> RegisterFlags -> LocalBuildInfo -> IO ExitCode -> Args -> Int -> IO HookedBuildInfo -> Args -> Int -> LocalBuildInfo -> IO ExitCode -> Args -> Int -> IO HookedBuildInfo -> Args -> Int -> LocalBuildInfo -> IO ExitCode -> UserHooks
data UserHooks
defaultHookedPackageDesc :: IO (Maybe FilePath)
defaultMain :: IO ()
defaultMainNoRead :: PackageDescription -> IO ()
defaultMainWithHooks :: UserHooks -> IO ()
defaultUserHooks :: UserHooks
emptyUserHooks :: UserHooks
hookedPreProcessors :: UserHooks -> [PPSuffixHandler]
postBuild :: UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode
postClean :: UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode
postConf :: UserHooks -> Args -> ConfigFlags -> LocalBuildInfo -> IO ExitCode
postCopy :: UserHooks -> Args -> CopyFlags -> LocalBuildInfo -> IO ExitCode
postHaddock :: UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode
postInst :: UserHooks -> Args -> InstallFlags -> LocalBuildInfo -> IO ExitCode
postPFE :: UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode
postReg :: UserHooks -> Args -> RegisterFlags -> LocalBuildInfo -> IO ExitCode
postSDist :: UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode
postUnreg :: UserHooks -> Args -> RegisterFlags -> LocalBuildInfo -> IO ExitCode
preBuild :: UserHooks -> Args -> Int -> IO HookedBuildInfo
preClean :: UserHooks -> Args -> Int -> IO HookedBuildInfo
preConf :: UserHooks -> Args -> ConfigFlags -> IO HookedBuildInfo
preCopy :: UserHooks -> Args -> CopyFlags -> IO HookedBuildInfo
preHaddock :: UserHooks -> Args -> Int -> IO HookedBuildInfo
preInst :: UserHooks -> Args -> InstallFlags -> IO HookedBuildInfo
prePFE :: UserHooks -> Args -> Int -> IO HookedBuildInfo
preReg :: UserHooks -> Args -> RegisterFlags -> IO HookedBuildInfo
preSDist :: UserHooks -> Args -> Int -> IO HookedBuildInfo
preUnreg :: UserHooks -> Args -> RegisterFlags -> IO HookedBuildInfo
readDesc :: UserHooks -> (IO (Maybe PackageDescription))
runTests :: UserHooks -> Args -> Bool -> LocalBuildInfo -> IO ExitCode
type Args = [String]

module Distribution.Simple.Build
build :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()

module Distribution.Simple.Configure
LocalBuildInfo :: FilePath -> Compiler -> FilePath -> [PackageIdentifier] -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> LocalBuildInfo
buildDir :: LocalBuildInfo -> FilePath
compiler :: LocalBuildInfo -> Compiler
configure :: PackageDescription -> ConfigFlags -> IO LocalBuildInfo
data LocalBuildInfo
findProgram :: String -> Maybe FilePath -> IO (Maybe FilePath)
getPersistBuildConfig :: IO LocalBuildInfo
instance Eq LocalBuildInfo
instance Read LocalBuildInfo
instance Show LocalBuildInfo
localBuildInfoFile :: FilePath
packageDeps :: LocalBuildInfo -> [PackageIdentifier]
prefix :: LocalBuildInfo -> FilePath
withAlex :: LocalBuildInfo -> Maybe FilePath
withCpphs :: LocalBuildInfo -> Maybe FilePath
withHaddock :: LocalBuildInfo -> Maybe FilePath
withHappy :: LocalBuildInfo -> Maybe FilePath
withHsc2hs :: LocalBuildInfo -> Maybe FilePath
writePersistBuildConfig :: LocalBuildInfo -> IO ()

module Distribution.Simple.GHCPackageConfig
GHCPackage :: String -> Bool -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> GHCPackageConfig
auto :: GHCPackageConfig -> Bool
c_includes :: GHCPackageConfig -> [String]
canReadLocalPackageConfig :: IO Bool
canWriteLocalPackageConfig :: IO Bool
data GHCPackageConfig
defaultGHCPackageConfig :: GHCPackageConfig
extra_cc_opts :: GHCPackageConfig -> [String]
extra_frameworks :: GHCPackageConfig -> [String]
extra_ghc_opts :: GHCPackageConfig -> [String]
extra_ld_opts :: GHCPackageConfig -> [String]
extra_libraries :: GHCPackageConfig -> [String]
framework_dirs :: GHCPackageConfig -> [String]
hs_libraries :: GHCPackageConfig -> [String]
import_dirs :: GHCPackageConfig -> [String]
include_dirs :: GHCPackageConfig -> [String]
library_dirs :: GHCPackageConfig -> [String]
localPackageConfig :: IO FilePath
maybeCreateLocalPackageConfig :: IO Bool
mkGHCPackageConfig :: PackageDescription -> LocalBuildInfo -> GHCPackageConfig
name :: GHCPackageConfig -> String
package_deps :: GHCPackageConfig -> [String]
showGHCPackageConfig :: GHCPackageConfig -> String
source_dirs :: GHCPackageConfig -> [String]

module Distribution.Simple.Install
hugsMainFilename :: Executable -> FilePath
hugsPackageDir :: PackageDescription -> LocalBuildInfo -> FilePath
hugsProgramsDirs :: PackageDescription -> LocalBuildInfo -> [FilePath]
install :: PackageDescription -> LocalBuildInfo -> (Maybe FilePath, Int) -> IO ()
mkBinDir :: PackageDescription -> LocalBuildInfo -> Maybe FilePath -> FilePath
mkLibDir :: PackageDescription -> LocalBuildInfo -> Maybe FilePath -> FilePath

module Distribution.Simple.Register
installedPkgConfigFile :: String
regScriptLocation :: FilePath
register :: PackageDescription -> LocalBuildInfo -> RegisterFlags -> IO ()
removeInstalledConfig :: IO ()
unregScriptLocation :: FilePath
unregister :: PackageDescription -> LocalBuildInfo -> RegisterFlags -> IO ()
writeInstalledConfig :: PackageDescription -> LocalBuildInfo -> IO ()

module Distribution.Simple.SrcDist
sdist :: FilePath -> FilePath -> Int -> [PPSuffixHandler] -> PackageDescription -> IO ()

module Foreign
unsafePerformIO :: IO a -> a

module Foreign.C.Error
Errno :: CInt -> Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOK :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError
getErrno :: IO Errno
instance Eq Errno
isValidErrno :: Errno -> Bool
newtype Errno
resetErrno :: IO ()
throwErrno :: String -> IO a
throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
throwErrnoIfMinus1RetryMayBlock :: Num a => String -> IO a -> IO b -> IO a
throwErrnoIfMinus1RetryMayBlock_ :: Num a => String -> IO a -> IO b -> IO ()
throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()
throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)
throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a
throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()

module Foreign.C.String
castCCharToChar :: CChar -> Char
castCharToCChar :: Char -> CChar
charIsRepresentable :: Char -> IO Bool
newCAString :: String -> IO CString
newCAStringLen :: String -> IO CStringLen
newCString :: String -> IO CString
newCStringLen :: String -> IO CStringLen
newCWString :: String -> IO CWString
newCWStringLen :: String -> IO CWStringLen
peekCAString :: CString -> IO String
peekCAStringLen :: CStringLen -> IO String
peekCString :: CString -> IO String
peekCStringLen :: CStringLen -> IO String
peekCWString :: CWString -> IO String
peekCWStringLen :: CWStringLen -> IO String
type CString = Ptr CChar
type CStringLen = (Ptr CChar, Int)
type CWString = Ptr CWchar
type CWStringLen = (Ptr CWchar, Int)
withCAString :: String -> (CString -> IO a) -> IO a
withCAStringLen :: String -> (CStringLen -> IO a) -> IO a
withCString :: String -> (CString -> IO a) -> IO a
withCStringLen :: String -> (CStringLen -> IO a) -> IO a
withCWString :: String -> (CWString -> IO a) -> IO a
withCWStringLen :: String -> (CWStringLen -> IO a) -> IO a

module Foreign.C.Types
data CChar
data CClock
data CDouble
data CFile
data CFloat
data CFpos
data CInt
data CJmpBuf
data CLDouble
data CLLong
data CLong
data CPtrdiff
data CSChar
data CShort
data CSigAtomic
data CSize
data CTime
data CUChar
data CUInt
data CULLong
data CULong
data CUShort
data CWchar
instance Bits CChar
instance Bits CInt
instance Bits CLLong
instance Bits CLong
instance Bits CPtrdiff
instance Bits CSChar
instance Bits CShort
instance Bits CSigAtomic
instance Bits CSize
instance Bits CUChar
instance Bits CUInt
instance Bits CULLong
instance Bits CULong
instance Bits CUShort
instance Bits CWchar
instance Bounded CChar
instance Bounded CInt
instance Bounded CLLong
instance Bounded CLong
instance Bounded CPtrdiff
instance Bounded CSChar
instance Bounded CShort
instance Bounded CSigAtomic
instance Bounded CSize
instance Bounded CUChar
instance Bounded CUInt
instance Bounded CULLong
instance Bounded CULong
instance Bounded CUShort
instance Bounded CWchar
instance Enum CChar
instance Enum CClock
instance Enum CDouble
instance Enum CFloat
instance Enum CInt
instance Enum CLDouble
instance Enum CLLong
instance Enum CLong
instance Enum CPtrdiff
instance Enum CSChar
instance Enum CShort
instance Enum CSigAtomic
instance Enum CSize
instance Enum CTime
instance Enum CUChar
instance Enum CUInt
instance Enum CULLong
instance Enum CULong
instance Enum CUShort
instance Enum CWchar
instance Eq CChar
instance Eq CClock
instance Eq CDouble
instance Eq CFloat
instance Eq CInt
instance Eq CLDouble
instance Eq CLLong
instance Eq CLong
instance Eq CPtrdiff
instance Eq CSChar
instance Eq CShort
instance Eq CSigAtomic
instance Eq CSize
instance Eq CTime
instance Eq CUChar
instance Eq CUInt
instance Eq CULLong
instance Eq CULong
instance Eq CUShort
instance Eq CWchar
instance Floating CDouble
instance Floating CFloat
instance Floating CLDouble
instance Fractional CDouble
instance Fractional CFloat
instance Fractional CLDouble
instance Integral CChar
instance Integral CInt
instance Integral CLLong
instance Integral CLong
instance Integral CPtrdiff
instance Integral CSChar
instance Integral CShort
instance Integral CSigAtomic
instance Integral CSize
instance Integral CUChar
instance Integral CUInt
instance Integral CULLong
instance Integral CULong
instance Integral CUShort
instance Integral CWchar
instance Num CChar
instance Num CClock
instance Num CDouble
instance Num CFloat
instance Num CInt
instance Num CLDouble
instance Num CLLong
instance Num CLong
instance Num CPtrdiff
instance Num CSChar
instance Num CShort
instance Num CSigAtomic
instance Num CSize
instance Num CTime
instance Num CUChar
instance Num CUInt
instance Num CULLong
instance Num CULong
instance Num CUShort
instance Num CWchar
instance Ord CChar
instance Ord CClock
instance Ord CDouble
instance Ord CFloat
instance Ord CInt
instance Ord CLDouble
instance Ord CLLong
instance Ord CLong
instance Ord CPtrdiff
instance Ord CSChar
instance Ord CShort
instance Ord CSigAtomic
instance Ord CSize
instance Ord CTime
instance Ord CUChar
instance Ord CUInt
instance Ord CULLong
instance Ord CULong
instance Ord CUShort
instance Ord CWchar
instance Read CChar
instance Read CClock
instance Read CDouble
instance Read CFloat
instance Read CInt
instance Read CLDouble
instance Read CLLong
instance Read CLong
instance Read CPtrdiff
instance Read CSChar
instance Read CShort
instance Read CSigAtomic
instance Read CSize
instance Read CTime
instance Read CUChar
instance Read CUInt
instance Read CULLong
instance Read CULong
instance Read CUShort
instance Read CWchar
instance Real CChar
instance Real CClock
instance Real CDouble
instance Real CFloat
instance Real CInt
instance Real CLDouble
instance Real CLLong
instance Real CLong
instance Real CPtrdiff
instance Real CSChar
instance Real CShort
instance Real CSigAtomic
instance Real CSize
instance Real CTime
instance Real CUChar
instance Real CUInt
instance Real CULLong
instance Real CULong
instance Real CUShort
instance Real CWchar
instance RealFloat CDouble
instance RealFloat CFloat
instance RealFloat CLDouble
instance RealFrac CDouble
instance RealFrac CFloat
instance RealFrac CLDouble
instance Show CChar
instance Show CClock
instance Show CDouble
instance Show CFloat
instance Show CInt
instance Show CLDouble
instance Show CLLong
instance Show CLong
instance Show CPtrdiff
instance Show CSChar
instance Show CShort
instance Show CSigAtomic
instance Show CSize
instance Show CTime
instance Show CUChar
instance Show CUInt
instance Show CULLong
instance Show CULong
instance Show CUShort
instance Show CWchar
instance Storable CChar
instance Storable CClock
instance Storable CDouble
instance Storable CFloat
instance Storable CInt
instance Storable CLDouble
instance Storable CLLong
instance Storable CLong
instance Storable CPtrdiff
instance Storable CSChar
instance Storable CShort
instance Storable CSigAtomic
instance Storable CSize
instance Storable CTime
instance Storable CUChar
instance Storable CUInt
instance Storable CULLong
instance Storable CULong
instance Storable CUShort
instance Storable CWchar
instance Typeable CChar
instance Typeable CClock
instance Typeable CDouble
instance Typeable CFloat
instance Typeable CInt
instance Typeable CLDouble
instance Typeable CLLong
instance Typeable CLong
instance Typeable CPtrdiff
instance Typeable CSChar
instance Typeable CShort
instance Typeable CSigAtomic
instance Typeable CSize
instance Typeable CTime
instance Typeable CUChar
instance Typeable CUInt
instance Typeable CULLong
instance Typeable CULong
instance Typeable CUShort
instance Typeable CWchar

module Foreign.Concurrent
addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)

module Foreign.ForeignPtr
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
castForeignPtr :: ForeignPtr a -> ForeignPtr b
data ForeignPtr a
finalizeForeignPtr :: ForeignPtr a -> IO ()
instance Eq (ForeignPtr a)
instance Ord (ForeignPtr a)
instance Show (ForeignPtr a)
instance Typeable a => Data (ForeignPtr a)
instance Typeable1 ForeignPtr
mallocForeignPtr :: Storable a => IO (ForeignPtr a)
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
touchForeignPtr :: ForeignPtr a -> IO ()
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

module Foreign.Marshal.Alloc
alloca :: Storable a => (Ptr a -> IO b) -> IO b
allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
finalizerFree :: FinalizerPtr a
free :: Ptr a -> IO ()
malloc :: Storable a => IO (Ptr a)
mallocBytes :: Int -> IO (Ptr a)
realloc :: Storable b => Ptr a -> IO (Ptr b)
reallocBytes :: Ptr a -> Int -> IO (Ptr a)

module Foreign.Marshal.Array
advancePtr :: Storable a => Ptr a -> Int -> Ptr a
allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
mallocArray :: Storable a => Int -> IO (Ptr a)
mallocArray0 :: Storable a => Int -> IO (Ptr a)
moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
newArray :: Storable a => [a] -> IO (Ptr a)
newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
peekArray :: Storable a => Int -> Ptr a -> IO [a]
peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
pokeArray :: Storable a => Ptr a -> [a] -> IO ()
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)
reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b

module Foreign.Marshal.Error
throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
void :: IO a -> IO ()

module Foreign.Marshal.Pool
data Pool
freePool :: Pool -> IO ()
newPool :: IO Pool
pooledMalloc :: Storable a => Pool -> IO (Ptr a)
pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)
pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
pooledNew :: Storable a => Pool -> a -> IO (Ptr a)
pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)
pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)
pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)
pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)
withPool :: (Pool -> IO b) -> IO b

module Foreign.Marshal.Utils
copyBytes :: Ptr a -> Ptr a -> Int -> IO ()
fromBool :: Num a => Bool -> a
maybeNew :: (a -> IO (Ptr a)) -> Maybe a -> IO (Ptr a)
maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)
maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c
moveBytes :: Ptr a -> Ptr a -> Int -> IO ()
new :: Storable a => a -> IO (Ptr a)
toBool :: Num a => a -> Bool
with :: Storable a => a -> (Ptr a -> IO b) -> IO b
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
withObject :: Storable a => a -> (Ptr a -> IO b) -> IO b

module Foreign.Ptr
alignPtr :: Ptr a -> Int -> Ptr a
castFunPtr :: FunPtr a -> FunPtr b
castFunPtrToPtr :: FunPtr a -> Ptr b
castPtr :: Ptr a -> Ptr b
castPtrToFunPtr :: Ptr a -> FunPtr b
data FunPtr a
data Ptr a
freeHaskellFunPtr :: FunPtr a -> IO ()
instance Eq (FunPtr a)
instance Eq (Ptr a)
instance IArray (IOToDiffArray IOUArray) (FunPtr a)
instance IArray (IOToDiffArray IOUArray) (Ptr a)
instance IArray UArray (FunPtr a)
instance IArray UArray (Ptr a)
instance Ix ix => Eq (UArray ix (FunPtr a))
instance Ix ix => Eq (UArray ix (Ptr a))
instance Ix ix => Ord (UArray ix (FunPtr a))
instance Ix ix => Ord (UArray ix (Ptr a))
instance MArray (STUArray s) (FunPtr a) (ST s)
instance MArray (STUArray s) (Ptr a) (ST s)
instance Ord (FunPtr a)
instance Ord (Ptr a)
instance Show (FunPtr a)
instance Show (Ptr a)
instance Storable (FunPtr a)
instance Storable (Ptr a)
instance Typeable a => Data (Ptr a)
instance Typeable1 FunPtr
instance Typeable1 Ptr
minusPtr :: Ptr a -> Ptr b -> Int
nullFunPtr :: FunPtr a
nullPtr :: Ptr a
plusPtr :: Ptr a -> Int -> Ptr b

module Foreign.StablePtr
castPtrToStablePtr :: Ptr () -> StablePtr a
castStablePtrToPtr :: StablePtr a -> Ptr ()
data StablePtr a
deRefStablePtr :: StablePtr a -> IO a
freeStablePtr :: StablePtr a -> IO ()
instance Eq (StablePtr a)
instance IArray (IOToDiffArray IOUArray) (StablePtr a)
instance IArray UArray (StablePtr a)
instance Ix ix => Eq (UArray ix (StablePtr a))
instance MArray (STUArray s) (StablePtr a) (ST s)
instance Storable (StablePtr a)
instance Typeable a => Data (StablePtr a)
instance Typeable1 StablePtr
newStablePtr :: a -> IO (StablePtr a)

module Foreign.Storable
alignment :: Storable a => a -> Int
class Storable a
peek :: Storable a => Ptr a -> IO a
peekByteOff :: Storable a => Ptr b -> Int -> IO a
peekElemOff :: Storable a => Ptr a -> Int -> IO a
poke :: Storable a => Ptr a -> a -> IO ()
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
sizeOf :: Storable a => a -> Int

module GHC.Conc
ThreadId :: ThreadId# -> ThreadId
addMVarFinalizer :: MVar a -> IO () -> IO ()
asyncDoProc :: FunPtr (Ptr a -> IO Int) -> Ptr a -> IO Int
asyncRead :: Int -> Int -> Int -> Ptr a -> IO (Int, Int)
asyncReadBA :: Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)
asyncWrite :: Int -> Int -> Int -> Ptr a -> IO (Int, Int)
asyncWriteBA :: Int -> Int -> Int -> Int -> MutableByteArray# RealWorld -> IO (Int, Int)
atomically :: STM a -> IO a
catchSTM :: STM a -> (Exception -> STM a) -> STM a
data MVar a
data STM a
data TVar a
instance ??? a => Typeable (STM a)
instance ??? a => Typeable (TVar a)
instance Eq (MVar a)
instance Eq (TVar a)
instance Functor STM
instance Monad STM
instance Typeable a => Data (MVar a)
instance Typeable a => Data (STM a)
instance Typeable a => Data (TVar a)
instance Typeable1 MVar
isEmptyMVar :: MVar a -> IO Bool
labelThread :: ThreadId -> String -> IO ()
newEmptyMVar :: IO (MVar a)
newMVar :: a -> IO (MVar a)
newTVar :: a -> STM (TVar a)
orElse :: STM a -> STM a -> STM a
pseq :: a -> b -> b
putMVar :: MVar a -> a -> IO ()
readTVar :: TVar a -> STM a
retry :: STM a
takeMVar :: MVar a -> IO a
tryPutMVar :: MVar a -> a -> IO Bool
tryTakeMVar :: MVar a -> IO (Maybe a)
unsafeIOToSTM :: IO a -> STM a
writeTVar :: TVar a -> a -> STM ()

module GHC.ConsoleHandler
Break :: ConsoleEvent
Catch :: (ConsoleEvent -> IO ()) -> Handler
Close :: ConsoleEvent
ControlC :: ConsoleEvent
Default :: Handler
Ignore :: Handler
Logoff :: ConsoleEvent
Shutdown :: ConsoleEvent
data ConsoleEvent
data Handler
flushConsole :: Handle -> IO ()
installHandler :: Handler -> IO Handler

module GHC.Dotnet
checkResult :: (State# RealWorld -> (#State# RealWorld, a, Addr##)) -> IO a
data Object a
marshalObject :: Object a -> (Addr# -> IO b) -> IO b
marshalString :: String -> (Addr# -> IO a) -> IO a
unmarshalObject :: Addr# -> Object a
unmarshalString :: Addr# -> String

module GHC.Exts
C# :: Char# -> Char
D# :: Double# -> Double
F# :: Float# -> Float
FunPtr :: Addr# -> FunPtr a
I# :: Int# -> Int
J# :: Int# -> ByteArray# -> Integer
Ptr :: Addr# -> Ptr a
S# :: Int# -> Integer
W# :: Word# -> Word
augment :: ((a -> b -> b) -> b -> b) -> [a] -> [a]
build :: ((a -> b -> b) -> b -> b) -> [a]
class Splittable t
iShiftL# :: Int# -> Int# -> Int#
iShiftRA# :: Int# -> Int# -> Int#
iShiftRL# :: Int# -> Int# -> Int#
shiftL# :: Word# -> Int# -> Word#
shiftRL# :: Word# -> Int# -> Word#
split :: Splittable t => t -> (t,t)

module GHC.Unicode
isAsciiLower :: Char -> Bool
isAsciiUpper :: Char -> Bool

module IO
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
hClose :: Handle -> IO ()
hFileSize :: Handle -> IO Integer
hFlush :: Handle -> IO ()
hGetBuffering :: Handle -> IO BufferMode
hGetChar :: Handle -> IO Char
hGetContents :: Handle -> IO String
hGetLine :: Handle -> IO String
hGetPosn :: Handle -> IO HandlePosn
hIsClosed :: Handle -> IO Bool
hIsEOF :: Handle -> IO Bool
hIsOpen :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hLookAhead :: Handle -> IO Char
hPrint :: Show a => Handle -> a -> IO ()
hPutChar :: Handle -> Char -> IO ()
hPutStr :: Handle -> String -> IO ()
hPutStrLn :: Handle -> String -> IO ()
hReady :: Handle -> IO Bool
hSeek :: Handle -> SeekMode -> Integer -> IO ()
hSetBuffering :: Handle -> BufferMode -> IO ()
hSetPosn :: HandlePosn -> IO ()
hWaitForInput :: Handle -> Int -> IO Bool
ioeGetErrorString :: IOError -> String
ioeGetFileName :: IOError -> Maybe FilePath
ioeGetHandle :: IOError -> Maybe Handle
isAlreadyExistsError :: IOError -> Bool
isAlreadyInUseError :: IOError -> Bool
isDoesNotExistError :: IOError -> Bool
isEOF :: IO Bool
isEOFError :: IOError -> Bool
isFullError :: IOError -> Bool
isIllegalOperation :: IOError -> Bool
isPermissionError :: IOError -> Bool
isUserError :: IOError -> Bool
openFile :: FilePath -> IOMode -> IO Handle
stderr :: Handle
stdin :: Handle
stdout :: Handle
try :: IO a -> IO (Either IOError a)

module Ix
inRange :: Ix a => (a,a) -> a -> Bool
index :: Ix a => (a,a) -> a -> Int
range :: Ix a => (a,a) -> [a]
rangeSize :: Ix a => (a,a) -> Int

module Language.Haskell.Parser
ParseFailed :: SrcLoc -> String -> ParseResult a
ParseMode :: String -> ParseMode
data ParseMode
defaultParseMode :: ParseMode
parseFilename :: ParseMode -> String
parseModule :: String -> ParseResult HsModule
parseModuleWithMode :: ParseMode -> String -> ParseResult HsModule

module Language.Haskell.Syntax
HsAlt :: SrcLoc -> HsPat -> HsGuardedAlts -> [HsDecl] -> HsAlt
HsApp :: HsExp -> HsExp -> HsExp
HsAsPat :: HsName -> HsExp -> HsExp
HsAssocLeft :: HsAssoc
HsAssocNone :: HsAssoc
HsAssocRight :: HsAssoc
HsBangedTy :: HsType -> HsBangType
HsCase :: HsExp -> [HsAlt] -> HsExp
HsChar :: Char -> HsLiteral
HsCharPrim :: Char -> HsLiteral
HsClassDecl :: SrcLoc -> HsContext -> HsName -> [HsName] -> [HsDecl] -> HsDecl
HsCon :: HsQName -> HsExp
HsConDecl :: SrcLoc -> HsName -> [HsBangType] -> HsConDecl
HsConName :: HsName -> HsCName
HsConOp :: HsName -> HsOp
HsCons :: HsSpecialCon
HsDataDecl :: SrcLoc -> HsContext -> HsName -> [HsName] -> [HsConDecl] -> [HsQName] -> HsDecl
HsDefaultDecl :: SrcLoc -> [HsType] -> HsDecl
HsDo :: [HsStmt] -> HsExp
HsDoublePrim :: Rational -> HsLiteral
HsEAbs :: HsQName -> HsExportSpec
HsEModuleContents :: Module -> HsExportSpec
HsEThingAll :: HsQName -> HsExportSpec
HsEThingWith :: HsQName -> [HsCName] -> HsExportSpec
HsEVar :: HsQName -> HsExportSpec
HsEnumFrom :: HsExp -> HsExp
HsEnumFromThen :: HsExp -> HsExp -> HsExp
HsEnumFromThenTo :: HsExp -> HsExp -> HsExp -> HsExp
HsEnumFromTo :: HsExp -> HsExp -> HsExp
HsExpTypeSig :: SrcLoc -> HsExp -> HsQualType -> HsExp
HsFieldUpdate :: HsQName -> HsExp -> HsFieldUpdate
HsFloatPrim :: Rational -> HsLiteral
HsFrac :: Rational -> HsLiteral
HsFunBind :: [HsMatch] -> HsDecl
HsFunCon :: HsSpecialCon
HsGenerator :: SrcLoc -> HsPat -> HsExp -> HsStmt
HsGuardedAlt :: SrcLoc -> HsExp -> HsExp -> HsGuardedAlt
HsGuardedAlts :: [HsGuardedAlt] -> HsGuardedAlts
HsGuardedRhs :: SrcLoc -> HsExp -> HsExp -> HsGuardedRhs
HsGuardedRhss :: [HsGuardedRhs] -> HsRhs
HsIAbs :: HsName -> HsImportSpec
HsIThingAll :: HsName -> HsImportSpec
HsIThingWith :: HsName -> [HsCName] -> HsImportSpec
HsIVar :: HsName -> HsImportSpec
HsIdent :: String -> HsName
HsIf :: HsExp -> HsExp -> HsExp -> HsExp
HsImportDecl :: SrcLoc -> Module -> Bool -> Maybe Module -> (Maybe (Bool,[HsImportSpec])) -> HsImportDecl
HsInfixApp :: HsExp -> HsQOp -> HsExp -> HsExp
HsInfixDecl :: SrcLoc -> HsAssoc -> Int -> [HsOp] -> HsDecl
HsInstDecl :: SrcLoc -> HsContext -> HsQName -> [HsType] -> [HsDecl] -> HsDecl
HsInt :: Integer -> HsLiteral
HsIntPrim :: Integer -> HsLiteral
HsIrrPat :: HsExp -> HsExp
HsLambda :: SrcLoc -> [HsPat] -> HsExp -> HsExp
HsLeftSection :: HsExp -> HsQOp -> HsExp
HsLet :: [HsDecl] -> HsExp -> HsExp
HsLetStmt :: [HsDecl] -> HsStmt
HsList :: [HsExp] -> HsExp
HsListComp :: HsExp -> [HsStmt] -> HsExp
HsListCon :: HsSpecialCon
HsLit :: HsLiteral -> HsExp
HsMatch :: SrcLoc -> HsName -> [HsPat] -> HsRhs -> [HsDecl] -> HsMatch
HsModule :: SrcLoc -> Module -> (Maybe [HsExportSpec]) -> [HsImportDecl] -> [HsDecl] -> HsModule
HsNegApp :: HsExp -> HsExp
HsNewTypeDecl :: SrcLoc -> HsContext -> HsName -> [HsName] -> HsConDecl -> [HsQName] -> HsDecl
HsPApp :: HsQName -> [HsPat] -> HsPat
HsPAsPat :: HsName -> HsPat -> HsPat
HsPFieldPat :: HsQName -> HsPat -> HsPatField
HsPInfixApp :: HsPat -> HsQName -> HsPat -> HsPat
HsPIrrPat :: HsPat -> HsPat
HsPList :: [HsPat] -> HsPat
HsPLit :: HsLiteral -> HsPat
HsPNeg :: HsPat -> HsPat
HsPParen :: HsPat -> HsPat
HsPRec :: HsQName -> [HsPatField] -> HsPat
HsPTuple :: [HsPat] -> HsPat
HsPVar :: HsName -> HsPat
HsPWildCard :: HsPat
HsParen :: HsExp -> HsExp
HsPatBind :: SrcLoc -> HsPat -> HsRhs -> [HsDecl] -> HsDecl
HsQConOp :: HsQName -> HsQOp
HsQVarOp :: HsQName -> HsQOp
HsQualType :: HsContext -> HsType -> HsQualType
HsQualifier :: HsExp -> HsStmt
HsRecConstr :: HsQName -> [HsFieldUpdate] -> HsExp
HsRecDecl :: SrcLoc -> HsName -> [([HsName],HsBangType)] -> HsConDecl
HsRecUpdate :: HsExp -> [HsFieldUpdate] -> HsExp
HsRightSection :: HsQOp -> HsExp -> HsExp
HsString :: String -> HsLiteral
HsStringPrim :: String -> HsLiteral
HsSymbol :: String -> HsName
HsTuple :: [HsExp] -> HsExp
HsTupleCon :: Int -> HsSpecialCon
HsTyApp :: HsType -> HsType -> HsType
HsTyCon :: HsQName -> HsType
HsTyFun :: HsType -> HsType -> HsType
HsTyTuple :: [HsType] -> HsType
HsTyVar :: HsName -> HsType
HsTypeDecl :: SrcLoc -> HsName -> [HsName] -> HsType -> HsDecl
HsTypeSig :: SrcLoc -> [HsName] -> HsQualType -> HsDecl
HsUnBangedTy :: HsType -> HsBangType
HsUnGuardedAlt :: HsExp -> HsGuardedAlts
HsUnGuardedRhs :: HsExp -> HsRhs
HsUnitCon :: HsSpecialCon
HsVar :: HsQName -> HsExp
HsVarName :: HsName -> HsCName
HsVarOp :: HsName -> HsOp
HsWildCard :: HsExp
Module :: String -> Module
Qual :: Module -> HsName -> HsQName
Special :: HsSpecialCon -> HsQName
SrcLoc :: String -> Int -> Int -> SrcLoc
UnQual :: HsName -> HsQName
as_name :: HsName
data HsAlt
data HsAssoc
data HsBangType
data HsCName
data HsConDecl
data HsDecl
data HsExp
data HsExportSpec
data HsFieldUpdate
data HsGuardedAlt
data HsGuardedAlts
data HsGuardedRhs
data HsImportDecl
data HsImportSpec
data HsLiteral
data HsMatch
data HsModule
data HsName
data HsOp
data HsPat
data HsPatField
data HsQName
data HsQOp
data HsQualType
data HsRhs
data HsSpecialCon
data HsStmt
data HsType
data SrcLoc
fun_tycon :: HsType
fun_tycon_name :: HsQName
hiding_name :: HsName
importAs :: HsImportDecl -> Maybe Module
importLoc :: HsImportDecl -> SrcLoc
importModule :: HsImportDecl -> Module
importQualified :: HsImportDecl -> Bool
importSpecs :: HsImportDecl -> (Maybe (Bool,[HsImportSpec]))
instance Data HsAlt
instance Data HsAssoc
instance Data HsBangType
instance Data HsCName
instance Data HsConDecl
instance Data HsDecl
instance Data HsExp
instance Data HsExportSpec
instance Data HsFieldUpdate
instance Data HsGuardedAlt
instance Data HsGuardedAlts
instance Data HsGuardedRhs
instance Data HsImportDecl
instance Data HsImportSpec
instance Data HsLiteral
instance Data HsMatch
instance Data HsModule
instance Data HsName
instance Data HsOp
instance Data HsPat
instance Data HsPatField
instance Data HsQName
instance Data HsQOp
instance Data HsQualType
instance Data HsRhs
instance Data HsSpecialCon
instance Data HsStmt
instance Data HsType
instance Data Module
instance Data SrcLoc
instance Eq HsAlt
instance Eq HsAssoc
instance Eq HsBangType
instance Eq HsCName
instance Eq HsConDecl
instance Eq HsDecl
instance Eq HsExp
instance Eq HsExportSpec
instance Eq HsFieldUpdate
instance Eq HsGuardedAlt
instance Eq HsGuardedAlts
instance Eq HsGuardedRhs
instance Eq HsImportDecl
instance Eq HsImportSpec
instance Eq HsLiteral
instance Eq HsMatch
instance Eq HsName
instance Eq HsOp
instance Eq HsPat
instance Eq HsPatField
instance Eq HsQName
instance Eq HsQOp
instance Eq HsQualType
instance Eq HsRhs
instance Eq HsSpecialCon
instance Eq HsStmt
instance Eq HsType
instance Eq Module
instance Eq SrcLoc
instance Ord HsCName
instance Ord HsName
instance Ord HsOp
instance Ord HsQName
instance Ord HsQOp
instance Ord HsSpecialCon
instance Ord Module
instance Ord SrcLoc
instance Pretty HsAlt
instance Pretty HsAssoc
instance Pretty HsBangType
instance Pretty HsCName
instance Pretty HsConDecl
instance Pretty HsDecl
instance Pretty HsExp
instance Pretty HsExportSpec
instance Pretty HsFieldUpdate
instance Pretty HsGuardedAlt
instance Pretty HsGuardedAlts
instance Pretty HsGuardedRhs
instance Pretty HsImportDecl
instance Pretty HsImportSpec
instance Pretty HsLiteral
instance Pretty HsMatch
instance Pretty HsModule
instance Pretty HsName
instance Pretty HsOp
instance Pretty HsPat
instance Pretty HsPatField
instance Pretty HsQName
instance Pretty HsQOp
instance Pretty HsQualType
instance Pretty HsRhs
instance Pretty HsStmt
instance Pretty HsType
instance Pretty Module
instance Show HsAlt
instance Show HsAssoc
instance Show HsBangType
instance Show HsCName
instance Show HsConDecl
instance Show HsDecl
instance Show HsExp
instance Show HsExportSpec
instance Show HsFieldUpdate
instance Show HsGuardedAlt
instance Show HsGuardedAlts
instance Show HsGuardedRhs
instance Show HsImportDecl
instance Show HsImportSpec
instance Show HsLiteral
instance Show HsMatch
instance Show HsModule
instance Show HsName
instance Show HsOp
instance Show HsPat
instance Show HsPatField
instance Show HsQName
instance Show HsQOp
instance Show HsQualType
instance Show HsRhs
instance Show HsSpecialCon
instance Show HsStmt
instance Show HsType
instance Show Module
instance Show SrcLoc
instance Typeable HsAlt
instance Typeable HsAssoc
instance Typeable HsBangType
instance Typeable HsCName
instance Typeable HsConDecl
instance Typeable HsDecl
instance Typeable HsExp
instance Typeable HsExportSpec
instance Typeable HsFieldUpdate
instance Typeable HsGuardedAlt
instance Typeable HsGuardedAlts
instance Typeable HsGuardedRhs
instance Typeable HsImportDecl
instance Typeable HsImportSpec
instance Typeable HsLiteral
instance Typeable HsMatch
instance Typeable HsModule
instance Typeable HsName
instance Typeable HsOp
instance Typeable HsPat
instance Typeable HsPatField
instance Typeable HsQName
instance Typeable HsQOp
instance Typeable HsQualType
instance Typeable HsRhs
instance Typeable HsSpecialCon
instance Typeable HsStmt
instance Typeable HsType
instance Typeable Module
instance Typeable SrcLoc
list_cons_name :: HsQName
list_tycon :: HsType
list_tycon_name :: HsQName
main_mod :: Module
main_name :: HsName
minus_name :: HsName
newtype Module
pling_name :: HsName
prelude_mod :: Module
qualified_name :: HsName
srcColumn :: SrcLoc -> Int
srcFilename :: SrcLoc -> String
srcLine :: SrcLoc -> Int
tuple_con :: Int -> HsExp
tuple_con_name :: Int -> HsQName
tuple_tycon :: Int -> HsType
tuple_tycon_name :: Int -> HsQName
type HsAsst = (HsQName, [HsType])
type HsContext = [HsAsst]
unit_con :: HsExp
unit_con_name :: HsQName
unit_tycon :: HsType
unit_tycon_name :: HsQName

module Language.Haskell.TH
AppE :: Exp -> Exp -> Exp
AppT :: Type -> Type -> Type
ArithSeqE :: Range -> Exp
ArrowT :: Type
AsP :: Name -> Pat -> Pat
BindS :: Pat -> Exp -> Stmt
CCall :: Callconv
CaseE :: Exp -> [Match] -> Exp
CharL :: Char -> Lit
ClassD :: Cxt -> Name -> [Name] -> [FunDep] -> [Dec] -> Dec
ClassI :: Dec -> Info
ClassOpI :: Name -> Type -> Name -> Fixity -> Info
Clause :: [Pat] -> Body -> [Dec] -> Clause
CompE :: [Stmt] -> Exp
ConE :: Name -> Exp
ConP :: Name -> [Pat] -> Pat
ConT :: Name -> Type
CondE :: Exp -> Exp -> Exp -> Exp
DataConI :: Name -> Type -> Name -> Fixity -> Info
DataD :: Cxt -> Name -> [Name] -> [Con] -> [Name] -> Dec
DoE :: [Stmt] -> Exp
DoublePrimL :: Rational -> Lit
ExportF :: Callconv -> String -> Name -> Type -> Foreign
Fixity :: Int -> FixityDirection -> Fixity
FloatPrimL :: Rational -> Lit
ForallC :: [Name] -> Cxt -> Con -> Con
ForallT :: [Name] -> Cxt -> Type -> Type
ForeignD :: Foreign -> Dec
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FunD :: Name -> [Clause] -> Dec
FunDep :: [Name] -> [Name] -> FunDep
GuardedB :: [(Guard,Exp)] -> Body
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
InfixC :: StrictType -> Name -> StrictType -> Con
InfixE :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp
InfixL :: FixityDirection
InfixN :: FixityDirection
InfixP :: Pat -> Name -> Pat -> Pat
InfixR :: FixityDirection
InstanceD :: Cxt -> Type -> [Dec] -> Dec
IntPrimL :: Integer -> Lit
IntegerL :: Integer -> Lit
IsStrict :: Strict
LamE :: [Pat] -> Exp -> Exp
LetE :: [Dec] -> Exp -> Exp
LetS :: [Dec] -> Stmt
ListE :: [Exp] -> Exp
ListP :: [Pat] -> Pat
ListT :: Type
LitE :: Lit -> Exp
LitP :: Lit -> Pat
Match :: Pat -> Body -> [Dec] -> Match
NewtypeD :: Cxt -> Name -> [Name] -> Con -> [Name] -> Dec
NoBindS :: Exp -> Stmt
NormalB :: Exp -> Body
NormalC :: Name -> [StrictType] -> Con
NormalG :: Exp -> Guard
NotStrict :: Strict
ParS :: [[Stmt]] -> Stmt
PatG :: [Stmt] -> Guard
PrimTyConI :: Name -> Int -> Bool -> Info
RationalL :: Rational -> Lit
RecC :: Name -> [VarStrictType] -> Con
RecConE :: Name -> [FieldExp] -> Exp
RecP :: Name -> [FieldPat] -> Pat
RecUpdE :: Exp -> [FieldExp] -> Exp
Safe :: Safety
SigD :: Name -> Type -> Dec
SigE :: Exp -> Type -> Exp
SigP :: Pat -> Type -> Pat
StdCall :: Callconv
StringL :: String -> Lit
Threadsafe :: Safety
TildeP :: Pat -> Pat
TupE :: [Exp] -> Exp
TupP :: [Pat] -> Pat
TupleT :: Int -> Type
TyConI :: Dec -> Info
TySynD :: Name -> [Name] -> Type -> Dec
TyVarI :: Name -> Type -> Info
Unsafe :: Safety
ValD :: Pat -> Body -> [Dec] -> Dec
VarE :: Name -> Exp
VarI :: Name -> Type -> (Maybe Dec) -> Fixity -> Info
VarP :: Name -> Pat
VarT :: Name -> Type
WildP :: Pat
appE :: ExpQ -> ExpQ -> ExpQ
appT :: TypeQ -> TypeQ -> TypeQ
appsE :: [ExpQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
arrowT :: TypeQ
asP :: Name -> PatQ -> PatQ
bindS :: PatQ -> ExpQ -> StmtQ
cCall :: Callconv
caseE :: ExpQ -> [MatchQ] -> ExpQ
charL :: Char -> Lit
class Ppr a
classD :: CxtQ -> Name -> [Name] -> [FunDep] -> [DecQ] -> DecQ
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ
compE :: [StmtQ] -> ExpQ
conE :: Name -> ExpQ
conP :: Name -> [PatQ] -> PatQ
conT :: Name -> TypeQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
currentModule :: Q String
cxt :: [TypeQ] -> CxtQ
data Body
data Callconv
data Clause
data Con
data Dec
data Exp
data FixityDirection
data Foreign
data FunDep
data Guard
data Info
data Lit
data Match
data Name
data Pat
data Q a
data Range
data Safety
data Stmt
data Strict
data Type
dataD :: CxtQ -> Name -> [Name] -> [ConQ] -> [Name] -> DecQ
defaultFixity :: Fixity
doE :: [StmtQ] -> ExpQ
doublePrimL :: Rational -> Lit
dyn :: String -> Q Exp
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fieldPat :: Name -> PatQ -> FieldPatQ
floatPrimL :: Rational -> Lit
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
fromE :: ExpQ -> ExpQ
fromR :: ExpQ -> RangeQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromToR :: ExpQ -> ExpQ -> RangeQ
funD :: Name -> [ClauseQ] -> DecQ
global :: Name -> ExpQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixP :: PatQ -> Name -> PatQ -> PatQ
instance Eq Body
instance Eq Callconv
instance Eq Clause
instance Eq Con
instance Eq Dec
instance Eq Exp
instance Eq FixityDirection
instance Eq Foreign
instance Eq FunDep
instance Eq Guard
instance Eq Lit
instance Eq Match
instance Eq Name
instance Eq Pat
instance Eq Range
instance Eq Safety
instance Eq Stmt
instance Eq Strict
instance Eq Type
instance Monad Q
instance Ord Name
instance Ppr Clause
instance Ppr Con
instance Ppr Dec
instance Ppr Exp
instance Ppr Foreign
instance Ppr FunDep
instance Ppr Info
instance Ppr Match
instance Ppr Name
instance Ppr Pat
instance Ppr Range
instance Ppr Stmt
instance Ppr Type
instance Quasi Q
instance Show Body
instance Show Callconv
instance Show Clause
instance Show Con
instance Show Dec
instance Show Exp
instance Show Foreign
instance Show FunDep
instance Show Guard
instance Show Lit
instance Show Match
instance Show Name
instance Show Pat
instance Show Range
instance Show Safety
instance Show Stmt
instance Show Strict
instance Show Type
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
intPrimL :: Integer -> Lit
integerL :: Integer -> Lit
isStrict :: Q Strict
lam1E :: PatQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
letS :: [DecQ] -> StmtQ
listE :: [ExpQ] -> ExpQ
listP :: [PatQ] -> PatQ
listT :: TypeQ
litE :: Lit -> ExpQ
litP :: Lit -> PatQ
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
maxPrecedence :: Int
mkName :: String -> Name
nameBase :: Name -> String
nameModule :: Name -> Maybe String
newName :: String -> Q Name
newtypeD :: CxtQ -> Name -> [Name] -> ConQ -> [Name] -> DecQ
noBindS :: ExpQ -> StmtQ
normalB :: ExpQ -> BodyQ
normalC :: Name -> [StrictTypeQ] -> ConQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
notStrict :: Q Strict
parS :: [[StmtQ]] -> StmtQ
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> Q (Guard, Exp)
ppr :: Ppr a => a -> Doc
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprParendType :: Type -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
rationalL :: Rational -> Lit
recC :: Name -> [VarStrictTypeQ] -> ConQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recP :: Name -> [FieldPatQ] -> PatQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
recover :: Q a -> Q a -> Q a
reify :: Name -> Q Info
report :: Bool -> String -> Q ()
runIO :: IO a -> Q a
runQ :: Quasi m => Q a -> m a
safe :: Safety
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
sigD :: Name -> TypeQ -> DecQ
sigE :: ExpQ -> TypeQ -> ExpQ
sigP :: PatQ -> TypeQ -> PatQ
stdCall :: Callconv
strictType :: Q Strict -> TypeQ -> StrictTypeQ
stringE :: String -> ExpQ
stringL :: String -> Lit
threadsafe :: Safety
tildeP :: PatQ -> PatQ
tupE :: [ExpQ] -> ExpQ
tupP :: [PatQ] -> PatQ
tupleDataName :: Int -> Name
tupleT :: Int -> TypeQ
tupleTypeName :: Int -> Name
tySynD :: Name -> [Name] -> TypeQ -> DecQ
type BodyQ = Q Body
type ClauseQ = Q Clause
type ConQ = Q Con
type Cxt = [Type]
type CxtQ = Q Cxt
type DecQ = Q Dec
type ExpQ = Q Exp
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
type FieldPatQ = Q FieldPat
type GuardQ = Q Guard
type InfoQ = Q Info
type MatchQ = Q Match
type PatQ = Q Pat
type RangeQ = Q Range
type StmtQ = Q Stmt
type StrictTypeQ = Q StrictType
type TypeQ = Q Type
type VarStrictTypeQ = Q VarStrictType
unsafe :: Safety
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
varE :: Name -> ExpQ
varP :: Name -> PatQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
varT :: Name -> TypeQ
wildP :: PatQ

module Language.Haskell.TH.Lib
alpha :: [(Name, Name)] -> Name -> ExpQ
combine :: [([(Name, Name)], Pat)] -> ([(Name, Name)], [Pat])
forallC :: [Name] -> CxtQ -> ConQ -> ConQ
funDep :: [Name] -> [Name] -> FunDep
genpat :: Pat -> Q (Name -> ExpQ, Pat)
rename :: Pat -> Q ([(Name, Name)], Pat)
simpleMatch :: Pat -> Exp -> Match
type FieldExpQ = Q FieldExp

module Language.Haskell.TH.Ppr
appPrec :: Precedence
nestDepth :: Int
noPrec :: Precedence
opPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprBody :: Bool -> Body -> Doc
pprCxt :: Cxt -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprFixity :: Name -> Fixity -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprStrictType :: (Strict, Type) -> Doc
pprTyApp :: (Type, [Type]) -> Doc
pprVarStrictType :: (Name, Strict, Type) -> Doc
showtextl :: Show a => a -> Doc
split :: Type -> (Type, [Type])
type Precedence = Int
where_clause :: [Dec] -> Doc

module Language.Haskell.TH.PprLib
data PprM a
instance Monad PprM
isEmpty :: Doc -> PprM Bool
pprName :: Name -> Doc
to_HPJ_Doc :: Doc -> Doc
type Doc = PprM Doc

module Language.Haskell.TH.Syntax
DataName :: NameSpace
Name :: OccName -> NameFlavour -> Name
NameG :: NameSpace -> ModName -> NameFlavour
NameL :: Int# -> NameFlavour
NameQ :: ModName -> NameFlavour
NameS :: NameFlavour
NameU :: Int# -> NameFlavour
TcClsName :: NameSpace
VarName :: NameSpace
bindQ :: Q a -> (a -> Q b) -> Q b
class Lift t
class Monad m => Quasi m
data NameFlavour
data NameSpace
instance Eq NameFlavour
instance Eq NameSpace
instance Ord NameFlavour
instance Ord NameSpace
lift :: Lift t => t -> Q Exp
mkModName :: String -> ModName
mkNameG_d :: String -> String -> Name
mkNameG_tc :: String -> String -> Name
mkNameG_v :: String -> String -> Name
mkNameL :: String -> Uniq -> Name
mkNameU :: String -> Uniq -> Name
mkOccName :: String -> OccName
modString :: ModName -> String
occString :: OccName -> String
qCurrentModule :: Quasi m => m String
qNewName :: Quasi m => String -> m Name
qRecover :: Quasi m => m a -> m a -> m a
qReify :: Quasi m => Name -> m Info
qReport :: Quasi m => Bool -> String -> m ()
qRunIO :: Quasi m => IO a -> m a
returnQ :: a -> Q a
sequenceQ :: [Q a] -> Q [a]
type ModName = PackedString
type OccName = PackedString
type StrictType = (Strict, Type)
type Uniq = Int
type VarStrictType = (Name, Strict, Type)

module List
(\\) :: Eq a => [a] -> [a] -> [a]
delete :: Eq a => a -> [a] -> [a]
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
elemIndex :: Eq => a -> [a] -> Maybe Int
elemIndices :: Eq a => a -> [a] -> [Int]
find :: (a -> Bool) -> [a] -> Maybe a
findIndex :: (a -> Bool) -> [a] -> Maybe Int
findIndices :: (a -> Bool) -> [a] -> [Int]
genericDrop :: Integral a => a -> [b] -> [b]
genericIndex :: Integral a => [b] -> a -> b
genericLength :: Integral a => [b] -> a
genericReplicate :: Integral a => a -> b -> [b]
genericSplitAt :: Integral a => a -> [b] -> ([b],[b])
genericTake :: Integral a => a -> [b] -> [b]
group :: Eq a => [a] -> [[a]]
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
inits :: [a] -> [[a]]
insert :: Ord a => a -> [a] -> [a]
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
intersect :: Eq a => [a] -> [a] -> [a]
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
intersperse :: a -> [a] -> [a]
isPrefixOf :: Eq a => [a] -> [a] -> Bool
isSuffixOf :: Eq a => [a] -> [a] -> Bool
mapAccumL :: (a -> b -> (a,c)) -> a -> [b] -> (a,[c])
mapAccumR :: (a -> b -> (a,c)) -> a -> [b] -> (a,[c])
maximumBy :: (a -> a -> a) -> [a] -> a
minimumBy :: (a -> a -> a) -> [a] -> a
nub :: Eq a => [a] -> [a]
nubBy :: (a -> a -> Bool) -> [a] -> [a]
partition :: (a -> Bool) -> [a] -> ([a],[a])
sort :: Ord a => [a] -> [a]
sortBy :: (a -> a -> Ordering) -> [a] -> [a]
tails :: [a] -> [[a]]
transpose :: [[a]] -> [[a]]
unfoldr :: (a -> Maybe (b,a)) -> a -> [b]
union :: Eq a => [a] -> [a] -> [a]
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])
unzip5 :: [(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])
unzip6 :: [(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])
unzip7 :: [(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a,b,c,d,e,f)]
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a,b,c,d,e,f,g)]
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

module Locale
defaultTimeLocale :: TimeLocale

module Maybe
catMaybes :: [Maybe a] -> [a]
fromJust :: Maybe a -> a
fromMaybe :: a -> Maybe a -> a
isJust :: Maybe a -> Bool
isNothing :: Maybe a -> Bool
listToMaybe :: [a] -> Maybe a
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
maybeToList :: Maybe a -> [a]

module Monad
ap :: Monad a => a (b -> c) -> a b -> a c
filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
guard :: MonadPlus a => Bool -> a ()
join :: Monad a => a (a b) -> a b
liftM :: Monad a => (b -> c) -> a b -> a c
liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
liftM3 :: Monad a => (b -> c -> d -> e) -> a b -> a c -> a d -> a e
liftM4 :: Monad a => (b -> c -> d -> e -> f) -> a b -> a c -> a d -> a e -> a f
liftM5 :: Monad a => (b -> c -> d -> e -> f -> g) -> a b -> a c -> a d -> a e -> a f -> a g
mapAndUnzipM :: Monad a => (b -> a (c,d)) -> [b] -> a ([c],[d])
msum :: MonadPlus a => [a b] -> a b
unless :: Monad a => Bool -> a () -> a ()
when :: Monad a => Bool -> a () -> a ()
zipWithM :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a [d]
zipWithM_ :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a ()

module Network
PortNumber :: PortNumber -> PortID
Service :: String -> PortID
accept :: Socket -> IO (Handle, HostName, PortNumber)
connectTo :: HostName -> PortID -> IO Handle
data PortID
data PortNumber
data Socket
instance Enum PortNumber
instance Eq PortNumber
instance Eq Socket
instance Integral PortNumber
instance Num PortNumber
instance Ord PortNumber
instance Real PortNumber
instance Show PortNumber
instance Show Socket
instance Storable PortNumber
instance Typeable PortNumber
instance Typeable Socket
listenOn :: PortID -> IO Socket
recvFrom :: HostName -> PortID -> IO String
sClose :: Socket -> IO ()
sendTo :: HostName -> PortID -> String -> IO ()
socketPort :: Socket -> IO PortID
type HostName = String
withSocketsDo :: IO a -> IO a

module Network.BSD
HostEntry :: HostName -> [HostName] -> Family -> [HostAddress] -> HostEntry
NetworkEntry :: NetworkName -> [NetworkName] -> Family -> NetworkAddr -> NetworkEntry
ProtocolEntry :: ProtocolName -> [ProtocolName] -> ProtocolNumber -> ProtocolEntry
ServiceEntry :: ServiceName -> [ServiceName] -> PortNumber -> ProtocolName -> ServiceEntry
data HostEntry
data NetworkEntry
data ProtocolEntry
data ServiceEntry
getHostByAddr :: Family -> HostAddress -> IO HostEntry
getHostByName :: HostName -> IO HostEntry
getHostName :: IO HostName
getProtocolByName :: ProtocolName -> IO ProtocolEntry
getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry
getProtocolNumber :: ProtocolName -> IO ProtocolNumber
getServiceByName :: ServiceName -> ProtocolName -> IO ServiceEntry
getServiceByPort :: PortNumber -> ProtocolName -> IO ServiceEntry
getServicePortNumber :: ServiceName -> IO PortNumber
hostAddress :: HostEntry -> HostAddress
hostAddresses :: HostEntry -> [HostAddress]
hostAliases :: HostEntry -> [HostName]
hostFamily :: HostEntry -> Family
hostName :: HostEntry -> HostName
instance Read HostEntry
instance Read NetworkEntry
instance Read ProtocolEntry
instance Show HostEntry
instance Show NetworkEntry
instance Show ProtocolEntry
instance Show ServiceEntry
instance Storable HostEntry
instance Storable NetworkEntry
instance Storable ProtocolEntry
instance Storable ServiceEntry
instance Typeable HostEntry
instance Typeable NetworkEntry
instance Typeable ProtocolEntry
instance Typeable ServiceEntry
networkAddress :: NetworkEntry -> NetworkAddr
networkAliases :: NetworkEntry -> [NetworkName]
networkFamily :: NetworkEntry -> Family
networkName :: NetworkEntry -> NetworkName
protoAliases :: ProtocolEntry -> [ProtocolName]
protoName :: ProtocolEntry -> ProtocolName
protoNumber :: ProtocolEntry -> ProtocolNumber
serviceAliases :: ServiceEntry -> [ServiceName]
serviceName :: ServiceEntry -> ServiceName
servicePort :: ServiceEntry -> PortNumber
serviceProtocol :: ServiceEntry -> ProtocolName
type NetworkAddr = CULong
type NetworkName = String
type ProtocolName = String
type ProtocolNumber = CInt
type ServiceName = String

module Network.CGI
Html
connectToCGIScript :: String -> PortID -> IO ()
pwrapper :: PortID -> ([(String, String)] -> IO Html) -> IO ()
wrapper :: ([(String, String)] -> IO Html) -> IO ()

module Network.Socket
AF_APPLETALK :: Family
AF_CCITT :: Family
AF_CHAOS :: Family
AF_DATAKIT :: Family
AF_DECnet :: Family
AF_DLI :: Family
AF_ECMA :: Family
AF_HYLINK :: Family
AF_IMPLINK :: Family
AF_INET :: Family
AF_INET6 :: Family
AF_IPX :: Family
AF_ISO :: Family
AF_LAT :: Family
AF_NETBIOS :: Family
AF_NS :: Family
AF_OSI :: Family
AF_PUP :: Family
AF_SNA :: Family
AF_UNIX :: Family
AF_UNSPEC :: Family
Bound :: SocketStatus
Broadcast :: SocketOption
Connected :: SocketStatus
Datagram :: SocketType
Debug :: SocketOption
DontRoute :: SocketOption
DummySocketOption__ :: SocketOption
KeepAlive :: SocketOption
Linger :: SocketOption
Listening :: SocketStatus
MkSocket :: CInt -> Family -> SocketType -> ProtocolNumber -> (MVar SocketStatus) -> Socket
NoDelay :: SocketOption
NoSocketType :: SocketType
NotConnected :: SocketStatus
OOBInline :: SocketOption
PortNum :: Word16 -> PortNumber
RDM :: SocketType
Raw :: SocketType
RecvBuffer :: SocketOption
RecvLowWater :: SocketOption
RecvTimeOut :: SocketOption
ReuseAddr :: SocketOption
SendBuffer :: SocketOption
SendLowWater :: SocketOption
SendTimeOut :: SocketOption
SeqPacket :: SocketType
ShutdownBoth :: ShutdownCmd
ShutdownReceive :: ShutdownCmd
ShutdownSend :: ShutdownCmd
SoError :: SocketOption
SockAddrInet :: PortNumber -> HostAddress -> SockAddr
Stream :: SocketType
Type :: SocketOption
UseLoopBack :: SocketOption
aNY_PORT :: PortNumber
accept :: Socket -> IO (Socket, SockAddr)
bindSocket :: Socket -> SockAddr -> IO ()
connect :: Socket -> SockAddr -> IO ()
data Family
data ShutdownCmd
data SockAddr
data SocketOption
data SocketStatus
data SocketType
fdSocket :: Socket -> CInt
getPeerName :: Socket -> IO SockAddr
getSocketName :: Socket -> IO SockAddr
getSocketOption :: Socket -> SocketOption -> IO Int
iNADDR_ANY :: HostAddress
inet_addr :: String -> IO HostAddress
inet_ntoa :: HostAddress -> IO String
instance Eq Family
instance Eq SockAddr
instance Eq SocketStatus
instance Eq SocketType
instance Ord Family
instance Ord SocketType
instance Read Family
instance Read SocketType
instance Show Family
instance Show SockAddr
instance Show SocketStatus
instance Show SocketType
instance Typeable ShutdownCmd
instance Typeable SockAddr
instance Typeable SocketOption
instance Typeable SocketStatus
instance Typeable SocketType
listen :: Socket -> Int -> IO ()
maxListenQueue :: Int
mkSocket :: CInt -> Family -> SocketType -> ProtocolNumber -> SocketStatus -> IO Socket
newtype PortNumber
packFamily :: Family -> CInt
packSocketType :: SocketType -> CInt
recv :: Socket -> Int -> IO String
recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)
recvLen :: Socket -> Int -> IO (String, Int)
sIsBound :: Socket -> IO Bool
sIsConnected :: Socket -> IO Bool
sIsListening :: Socket -> IO Bool
sIsReadable :: Socket -> IO Bool
sIsWritable :: Socket -> IO Bool
sOL_SOCKET :: Int
sOMAXCONN :: Int
send :: Socket -> String -> IO Int
sendBufTo :: Socket -> Ptr a -> Int -> SockAddr -> IO Int
sendTo :: Socket -> String -> SockAddr -> IO Int
setSocketOption :: Socket -> SocketOption -> Int -> IO ()
shutdown :: Socket -> ShutdownCmd -> IO ()
socket :: Family -> SocketType -> ProtocolNumber -> IO Socket
socketPort :: Socket -> IO PortNumber
socketToHandle :: Socket -> IOMode -> IO Handle
throwSocketErrorIfMinus1_ :: Num a => String -> IO a -> IO ()
type HostAddress = Word32
unpackFamily :: CInt -> Family

module Network.URI
URI :: String -> Maybe URIAuth -> String -> String -> String -> URI
URIAuth :: String -> String -> String -> URIAuth
authority :: URI -> String
data URI
data URIAuth
escapeString :: String -> (Char -> Bool) -> String
escapeURIChar :: (Char -> Bool) -> Char -> String
escapeURIString :: (Char -> Bool) -> String -> String
fragment :: URI -> String
instance Data URI
instance Data URIAuth
instance Eq URI
instance Eq URIAuth
instance Show URI
instance Typeable URI
instance Typeable URIAuth
isAbsoluteURI :: String -> Bool
isAllowedInURI :: Char -> Bool
isIPv4address :: String -> Bool
isIPv6address :: String -> Bool
isRelativeReference :: String -> Bool
isReserved :: Char -> Bool
isURI :: String -> Bool
isURIReference :: String -> Bool
isUnescapedInURI :: Char -> Bool
isUnreserved :: Char -> Bool
nonStrictRelativeTo :: URI -> URI -> Maybe URI
normalizeCase :: String -> String
normalizeEscape :: String -> String
normalizePathSegments :: String -> String
nullURI :: URI
parseRelativeReference :: String -> Maybe URI
parseURI :: String -> Maybe URI
parseURIReference :: String -> Maybe URI
parseabsoluteURI :: String -> Maybe URI
path :: URI -> String
query :: URI -> String
relativeFrom :: URI -> URI -> URI
relativeTo :: URI -> URI -> Maybe URI
reserved :: Char -> Bool
scheme :: URI -> String
unEscapeString :: String -> String
unreserved :: Char -> Bool
uriAuthority :: URI -> Maybe URIAuth
uriFragment :: URI -> String
uriPath :: URI -> String
uriPort :: URIAuth -> String
uriQuery :: URI -> String
uriRegName :: URIAuth -> String
uriScheme :: URI -> String
uriToString :: (String -> String) -> URI -> ShowS
uriUserInfo :: URIAuth -> String

module Numeric
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
floatToDigits :: RealFloat a => Integer -> a -> ([Int],Int)
fromRat :: RealFloat a => Rational -> a
lexDigits :: ReadS String
readDec :: Integral a => ReadS a
readDec :: Num a => ReadS a
readFloat :: RealFloat a => ReadS a
readFloat :: RealFrac a => ReadS a
readHex :: Integral a => ReadS a
readHex :: Num a => ReadS a
readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
readOct :: Integral a => ReadS a
readOct :: Num a => ReadS a
readSigned :: Real a => ReadS a -> ReadS a
showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
showFloat :: RealFloat a => a -> ShowS
showGFloat :: RealFloat a => Maybe Int -> a -> ShowS
showHex :: Integral a => a -> ShowS
showInt :: Integral a => a -> ShowS
showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
showOct :: Integral a => a -> ShowS
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS

module Prelude
(!!) :: [a] -> Int -> a
($!) :: (a -> b) -> a -> b
($) :: (a -> b) -> a -> b
(&&) :: Bool -> Bool -> Bool
(*) :: Num a => a -> a -> a
(**) :: Floating a => a -> a -> a
(+) :: Num a => a -> a -> a
(++) :: [a] -> [a] -> [a]
(-) :: Num a => a -> a -> a
(.) :: (b -> c) -> (a -> b) -> a -> c
(/) :: Fractional a => a -> a -> a
(/=) :: Eq a => a -> a -> Bool
(:) :: a -> [a] -> [a]
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(=<<) :: Monad m => (a -> m b) -> m a -> m b
(==) :: Eq a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
(>>) :: Monad m => m a -> m b -> m b
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(^) :: (Num a, Integral b) => a -> b -> a
(^^) :: (Fractional a, Integral b) => a -> b -> a
(||) :: Bool -> Bool -> Bool
EQ :: Ordering
False :: Bool
GT :: Ordering
Just :: a -> Maybe a
LT :: Ordering
Left :: a -> Either a b
Nothing :: Maybe a
Right :: b -> Either a b
True :: Bool
[] :: [a]
abs :: Num a => a -> a
acos :: Floating a => a -> a
acosh :: Floating a => a -> a
all :: (a -> Bool) -> [a] -> Bool
and :: [Bool] -> Bool
any :: (a -> Bool) -> [a] -> Bool
appendFile :: FilePath -> String -> IO ()
asTypeOf :: a -> a -> a
asin :: Floating a => a -> a
asinh :: Floating a => a -> a
atan :: Floating a => a -> a
atan2 :: RealFloat a => a -> a -> a
atanh :: Floating a => a -> a
break :: (a -> Bool) -> [a] -> ([a], [a])
catch :: IO a -> (IOError -> IO a) -> IO a
ceiling :: (RealFrac a, Integral b) => a -> b
class (Eq a, Show a) => Num a
class (Num a, Ord a) => Real a
class (Real a, Enum a) => Integral a
class (Real a, Fractional a) => RealFrac a
class (RealFrac a, Floating a) => RealFloat a
class Bounded a
class Enum a
class Eq a
class Eq a => Ord a
class Fractional a => Floating a
class Functor f
class Monad m
class Num a => Fractional a
class Read a
class Show a
compare :: Ord a => a -> a -> Ordering
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]
const :: a -> b -> a
cos :: Floating a => a -> a
cosh :: Floating a => a -> a
curry :: ((a, b) -> c) -> a -> b -> c
cycle :: [a] -> [a]
data Bool
data Char
data Double
data Either a b
data Float
data IO a
data Int
data Integer
data Maybe a
data Ordering
data []
decodeFloat :: RealFloat a => a -> (Integer,Int)
div :: Integral a => a -> a -> a
divMod :: Integral a => a -> a -> (a,a)
drop :: Int -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
either :: (a -> c) -> (b -> c) -> Either a b -> c
elem :: Eq a => a -> [a] -> Bool
encodeFloat :: RealFloat a => Integer -> Int -> a
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
error :: String -> a
even :: Integral a => a -> Bool
exp :: Floating a => a -> a
exponent :: RealFloat a => a -> Int
fail :: Monad m => String -> m a
filter :: (a -> Bool) -> [a] -> [a]
flip :: (a -> b -> c) -> b -> a -> c
floatDigits :: RealFloat a => a -> Int
floatRadix :: RealFloat a => a -> Integer
floatRange :: RealFloat a => a -> (Int,Int)
floor :: (RealFrac a, Integral b) => a -> b
fmap :: Functor f => (a -> b) -> f a -> f b
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl1 :: (a -> a -> a) -> [a] -> a
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr1 :: (a -> a -> a) -> [a] -> a
fromEnum :: Enum a => a -> Int
fromInteger :: Num a => Integer -> a
fromIntegral :: (Integral a, Num b) => a -> b
fromRational :: Fractional a => Rational -> a
fst :: (a, b) -> a
gcd :: Integral a => a -> a -> a
getChar :: IO Char
getContents :: IO String
getLine :: IO String
head :: [a] -> a
id :: a -> a
init :: [a] -> [a]
instance (Data a, Data b) => Data (Either a b)
instance (Eq a, Eq b) => Eq (Either a b)
instance (Ix ix, Show ix) => Show (DiffUArray ix Char)
instance (Ix ix, Show ix) => Show (DiffUArray ix Double)
instance (Ix ix, Show ix) => Show (DiffUArray ix Float)
instance (Ix ix, Show ix) => Show (DiffUArray ix Int)
instance (Ix ix, Show ix) => Show (UArray ix Bool)
instance (Ix ix, Show ix) => Show (UArray ix Char)
instance (Ix ix, Show ix) => Show (UArray ix Double)
instance (Ix ix, Show ix) => Show (UArray ix Float)
instance (Ix ix, Show ix) => Show (UArray ix Int)
instance (Ord a, Ord b) => Ord (Either a b)
instance (Read a, Read b) => Read (Either a b)
instance (Show a, Show b) => Show (Either a b)
instance Bits Int
instance Bits Integer
instance Bounded Bool
instance Bounded Char
instance Bounded Int
instance Bounded Ordering
instance Data Bool
instance Data Char
instance Data Double
instance Data Float
instance Data Int
instance Data Integer
instance Data Ordering
instance Data a => Data (Maybe a)
instance Enum Bool
instance Enum Char
instance Enum Double
instance Enum Float
instance Enum Int
instance Enum Integer
instance Enum Ordering
instance Eq Bool
instance Eq Char
instance Eq Double
instance Eq Float
instance Eq Int
instance Eq Integer
instance Eq Ordering
instance Eq a => Eq (Maybe a)
instance Floating Double
instance Floating Float
instance Fractional Double
instance Fractional Float
instance Functor IO
instance Functor Maybe
instance FunctorM Maybe
instance HPrintfType (IO a)
instance HTML Char
instance IArray (IOToDiffArray IOUArray) Char
instance IArray (IOToDiffArray IOUArray) Double
instance IArray (IOToDiffArray IOUArray) Float
instance IArray (IOToDiffArray IOUArray) Int
instance IArray UArray Bool
instance IArray UArray Char
instance IArray UArray Double
instance IArray UArray Float
instance IArray UArray Int
instance Integral Int
instance Integral Integer
instance IsChar Char
instance Ix Bool
instance Ix Char
instance Ix Int
instance Ix Integer
instance Ix Ordering
instance Ix ix => Eq (UArray ix Bool)
instance Ix ix => Eq (UArray ix Char)
instance Ix ix => Eq (UArray ix Double)
instance Ix ix => Eq (UArray ix Float)
instance Ix ix => Eq (UArray ix Int)
instance Ix ix => Ord (UArray ix Bool)
instance Ix ix => Ord (UArray ix Char)
instance Ix ix => Ord (UArray ix Double)
instance Ix ix => Ord (UArray ix Float)
instance Ix ix => Ord (UArray ix Int)
instance MArray (STUArray s) Bool (ST s)
instance MArray (STUArray s) Char (ST s)
instance MArray (STUArray s) Double (ST s)
instance MArray (STUArray s) Float (ST s)
instance MArray (STUArray s) Int (ST s)
instance MArray IOArray e IO
instance MArray IOUArray (FunPtr a) IO
instance MArray IOUArray (Ptr a) IO
instance MArray IOUArray (StablePtr a) IO
instance MArray IOUArray Bool IO
instance MArray IOUArray Char IO
instance MArray IOUArray Double IO
instance MArray IOUArray Float IO
instance MArray IOUArray Int IO
instance MArray IOUArray Int16 IO
instance MArray IOUArray Int32 IO
instance MArray IOUArray Int64 IO
instance MArray IOUArray Int8 IO
instance MArray IOUArray Word IO
instance MArray IOUArray Word16 IO
instance MArray IOUArray Word32 IO
instance MArray IOUArray Word64 IO
instance MArray IOUArray Word8 IO
instance Monad IO
instance Monad Maybe
instance MonadFix IO
instance MonadFix Maybe
instance MonadPlus Maybe
instance Monoid Ordering
instance NFData Bool
instance NFData Char
instance NFData Double
instance NFData Float
instance NFData Int
instance NFData Integer
instance NFDataIntegral Int
instance NFDataOrd Int
instance Num Double
instance Num Float
instance Num Int
instance Num Integer
instance Ord Bool
instance Ord Char
instance Ord Double
instance Ord Float
instance Ord Int
instance Ord Integer
instance Ord Ordering
instance Ord a => Ord (Maybe a)
instance PrintfArg Char
instance PrintfArg Double
instance PrintfArg Float
instance PrintfArg Int
instance PrintfArg Integer
instance PrintfType (IO a)
instance Random Bool
instance Random Char
instance Random Double
instance Random Float
instance Random Int
instance Random Integer
instance Read Bool
instance Read Char
instance Read Double
instance Read Float
instance Read Int
instance Read Integer
instance Read Ordering
instance Read a => Read (Maybe a)
instance Real Double
instance Real Float
instance Real Int
instance Real Integer
instance RealFloat Double
instance RealFloat Float
instance RealFrac Double
instance RealFrac Float
instance Show Bool
instance Show Char
instance Show Double
instance Show Float
instance Show Int
instance Show Integer
instance Show Ordering
instance Show a => Show (Maybe a)
instance Storable Bool
instance Storable Char
instance Storable Double
instance Storable Float
instance Storable Int
instance Storable e => MArray StorableArray e IO
instance Typeable Bool
instance Typeable Char
instance Typeable Double
instance Typeable Float
instance Typeable Int
instance Typeable Integer
instance Typeable Ordering
instance Typeable a => Data (IO a)
instance Typeable1 IO
instance Typeable1 Maybe
instance Typeable2 Either
interact :: (String -> String) -> IO ()
ioError :: IOError -> IO a
isDenormalized :: RealFloat a => a -> Bool
isIEEE :: RealFloat a => a -> Bool
isInfinite :: RealFloat a => a -> Bool
isNaN :: RealFloat a => a -> Bool
isNegativeZero :: RealFloat a => a -> Bool
iterate :: (a -> a) -> a -> [a]
keyword !
keyword ->
keyword ::
keyword <-
keyword @
keyword _
keyword as
keyword case
keyword class
keyword data
keyword default
keyword deriving
keyword do
keyword else
keyword forall
keyword hiding
keyword if
keyword import
keyword in
keyword infix
keyword infixl
keyword infixr
keyword instance
keyword let
keyword module
keyword newtype
keyword of
keyword qualified
keyword then
keyword type
keyword where
keyword |
keyword ~
last :: [a] -> a
lcm :: Integral a => a -> a -> a
length :: [a] -> Int
lex :: ReadS String
lines :: String -> [String]
log :: Floating a => a -> a
logBase :: Floating a => a -> a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
map :: (a -> b) -> [a] -> [b]
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
max :: Ord a => a -> a -> a
maxBound :: Bounded a => a
maximum :: Ord a => [a] -> a
maybe :: b -> (a -> b) -> Maybe a -> b
min :: Ord a => a -> a -> a
minBound :: Bounded a => a
minimum :: Ord a => [a] -> a
mod :: Integral a => a -> a -> a
negate :: Num a => a -> a
not :: Bool -> Bool
notElem :: Eq a => a -> [a] -> Bool
null :: [a] -> Bool
odd :: Integral a => a -> Bool
or :: [Bool] -> Bool
otherwise :: Bool
pi :: Floating a => a
pred :: Enum a => a -> a
print :: Show a => a -> IO ()
product :: Num a => [a] -> a
properFraction :: (RealFrac a, Integral b) => a -> (b,a)
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
quot :: Integral a => a -> a -> a
quotRem :: Integral a => a -> a -> (a,a)
read :: Read a => String -> a
readFile :: FilePath -> IO String
readIO :: Read a => String -> IO a
readList :: Read a => ReadS [a]
readLn :: Read a => IO a
readParen :: Bool -> ReadS a -> ReadS a
reads :: Read a => ReadS a
readsPrec :: Read a => Int -> ReadS a
realToFrac :: (Real a, Fractional b) => a -> b
recip :: Fractional a => a -> a
rem :: Integral a => a -> a -> a
repeat :: a -> [a]
replicate :: Int -> a -> [a]
return :: Monad m => a -> m a
reverse :: [a] -> [a]
round :: (RealFrac a, Integral b) => a -> b
scaleFloat :: RealFloat a => Int -> a -> a
scanl :: (a -> b -> a) -> a -> [b] -> [a]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
seq :: a -> b -> b
sequence :: Monad m => [m a] -> m [a]
sequence_ :: Monad m => [m a] -> m ()
show :: Show a => a -> String
showChar :: Char -> ShowS
showList :: Show a => [a] -> ShowS
showParen :: Bool -> ShowS -> ShowS
showString :: String -> ShowS
shows :: Show a => a -> ShowS
showsPrec :: Show a => Int -> a -> ShowS
significand :: RealFloat a => a -> a
signum :: Num a => a -> a
sin :: Floating a => a -> a
sinh :: Floating a => a -> a
snd :: (a, b) -> b
span :: (a -> Bool) -> [a] -> ([a], [a])
splitAt :: Int -> [a] -> ([a], [a])
sqrt :: Floating a => a -> a
subtract :: Num a => a -> a -> a
succ :: Enum a => a -> a
sum :: Num a => [a] -> a
tail :: [a] -> [a]
take :: Int -> [a] -> [a]
takeWhile :: (a -> Bool) -> [a] -> [a]
tan :: Floating a => a -> a
tanh :: Floating a => a -> a
toEnum :: Enum a => Int -> a
toInteger :: Integral a => a -> Integer
toRational :: Real a => a -> Rational
truncate :: (RealFrac a, Integral b) => a -> b
type FilePath = String
type IOError = IOException
type Rational = Ratio Integer
type ReadS a = String -> [(a, String)]
type ShowS = String -> String
type String = [Char]
uncurry :: (a -> b -> c) -> (a, b) -> c
undefined :: a
unlines :: [String] -> String
until :: (a -> Bool) -> (a -> a) -> a -> a
unwords :: [String] -> String
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
userError :: String -> IOError
words :: String -> [String]
writeFile :: FilePath -> String -> IO ()
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

module Random
getStdGen :: IO StdGen
getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
mkStdGen :: Int -> StdGen
newStdGen :: IO StdGen
next :: RandomGen a => a -> (Int,a)
random :: (Random a, RandomGen b) => b -> (a,b)
randomIO :: Random a => IO a
randomR :: (Random a, RandomGen b) => (a,a) -> b -> (a,b)
randomRIO :: Random a => (a,a) -> IO a
randomRs :: (Random a, RandomGen b) => (a,a) -> b -> [a]
randoms :: (Random a, RandomGen b) => b -> [a]
setStdGen :: StdGen -> IO ()
split :: RandomGen a => a -> (a,a)

module Ratio
(%) :: Integral a => a -> a -> Ratio a
approxRational :: RealFrac a => a -> a -> Rational
denominator :: Integral a => Ratio a -> a
numerator :: Integral a => Ratio a -> a

module System
exitFailure :: IO a
exitWith :: ExitCode -> IO a
getArgs :: IO [String]
getEnv :: String -> IO String
getProgName :: IO String
system :: String -> IO ExitCode

module System.Cmd
rawSystem :: String -> [String] -> IO ExitCode

module System.Console.Readline
Function :: Callback -> Entry
Keymap :: Keymap -> Entry
Macro :: String -> Entry
UndoBegin :: UndoCode
UndoDelete :: UndoCode
UndoEnd :: UndoCode
UndoInsert :: UndoCode
addDefun :: String -> Callback -> Maybe Char -> IO ()
addHistory :: String -> IO ()
addUndo :: UndoCode -> Int -> Int -> String -> IO ()
beginUndoGroup :: IO ()
bindKey :: Char -> Callback -> IO ()
bindKeyInMap :: Char -> Callback -> Keymap -> IO ()
callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
callbackReadChar :: IO ()
clearMessage :: IO ()
clearSignals :: IO ()
complete :: Int -> Char -> IO Int
completeInternal :: Char -> IO ()
completionMatches :: String -> (String -> IO [String]) -> IO (Maybe (String, [String]))
copyKeymap :: Keymap -> IO Keymap
copyText :: Int -> Int -> IO String
data Entry
data Keymap
data UndoCode
deleteText :: Int -> Int -> IO ()
ding :: IO Bool
doUndo :: IO Bool
endUndoGroup :: IO ()
filenameCompletionFunction :: String -> IO [String]
forcedUpdateDisplay :: IO ()
freeKeymap :: Keymap -> IO ()
freeUndoList :: IO ()
functionDumper :: Bool -> IO ()
functionOfKeyseq :: String -> Maybe Keymap -> IO Entry
genericBind :: String -> Entry -> Keymap -> IO ()
getBasicQuoteCharacters :: IO String
getBasicWordBreakCharacters :: IO String
getBindingKeymap :: IO Keymap
getCompleterQuoteCharacters :: IO String
getCompleterWordBreakCharacters :: IO String
getCompletionAppendCharacter :: IO (Maybe Char)
getCompletionQueryItems :: IO Int
getEnd :: IO Int
getExecutingKeymap :: IO Keymap
getFilenameCompletionDesired :: IO Bool
getFilenameQuoteCharacters :: IO String
getFilenameQuotingDesired :: IO Bool
getIgnoreCompletionDuplicates :: IO Bool
getInStream :: IO Handle
getInhibitCompletion :: IO Bool
getKeymap :: IO Keymap
getKeymapByName :: String -> IO Keymap
getKeymapName :: Keymap -> IO (Maybe String)
getLibraryVersion :: IO String
getLineBuffer :: IO String
getMark :: IO Int
getOutStream :: IO Handle
getPoint :: IO Int
getPrompt :: IO String
getSpecialPrefixes :: IO String
getTerminalName :: IO String
initialize :: IO ()
insertCompletions :: Int -> Char -> IO Int
insertText :: String -> IO ()
killText :: Int -> Int -> IO ()
listFunmapNames :: IO ()
message :: String -> IO ()
modifying :: Int -> Int -> IO ()
namedFunction :: String -> IO (Maybe Callback)
newBareKeymap :: IO Keymap
newKeymap :: IO Keymap
onNewLine :: IO ()
parseAndBind :: String -> IO ()
possibleCompletions :: Int -> Char -> IO Int
quoteFilename :: String -> Bool -> Ptr CChar -> IO String
readInitFile :: String -> IO ()
readKey :: IO Char
readline :: String -> IO (Maybe String)
redisplay :: IO ()
resetLineState :: IO ()
resetTerminal :: Maybe String -> IO ()
setAttemptedCompletionFunction :: Maybe (String -> Int -> Int -> IO (Maybe (String, [String]))) -> IO ()
setBasicQuoteCharacters :: String -> IO ()
setBasicWordBreakCharacters :: String -> IO ()
setCharIsQuotedP :: Maybe (String -> Int -> IO Bool) -> IO ()
setCompleterQuoteCharacters :: String -> IO ()
setCompleterWordBreakCharacters :: String -> IO ()
setCompletionAppendCharacter :: Maybe Char -> IO ()
setCompletionEntryFunction :: Maybe (String -> IO [String]) -> IO ()
setCompletionQueryItems :: Int -> IO ()
setDirectoryCompletionHook :: Maybe (String -> IO String) -> IO ()
setDone :: Bool -> IO ()
setEnd :: Int -> IO ()
setEventHook :: Maybe (IO ()) -> IO ()
setFilenameCompletionDesired :: Bool -> IO ()
setFilenameDequotingFunction :: Maybe (String -> Maybe Char -> IO String) -> IO ()
setFilenameQuoteCharacters :: String -> IO ()
setFilenameQuotingDesired :: Bool -> IO ()
setFilenameQuotingFunction :: Maybe (String -> Bool -> Ptr CChar -> IO String) -> IO ()
setIgnoreCompletionDuplicates :: Bool -> IO ()
setIgnoreSomeCompletionsFunction :: Maybe ([String] -> IO [String]) -> IO ()
setInhibitCompletion :: Bool -> IO ()
setKeymap :: Keymap -> IO ()
setMark :: Int -> IO ()
setPendingInput :: Char -> IO ()
setPoint :: Int -> IO ()
setReadlineName :: String -> IO ()
setRedisplayFunction :: Maybe (IO ()) -> IO ()
setSignals :: IO ()
setSpecialPrefixes :: String -> IO ()
setStartupHook :: Maybe (IO ()) -> IO ()
stuffChar :: Char -> IO Bool
type Callback = Int -> Char -> IO Int
unbindCommandInMap :: String -> Keymap -> IO ()
unbindKey :: Char -> IO ()
unbindKeyInMap :: Char -> Keymap -> IO ()
usernameCompletionFunction :: String -> IO [String]

module System.Console.SimpleLineEditor
delChars :: String -> IO ()
getLineEdited :: String -> IO (Maybe String)
initialise :: IO ()
restore :: IO ()

module System.Directory
Permissions :: Bool -> Bool -> Bool -> Bool -> Permissions
canonicalizePath :: FilePath -> IO FilePath
copyFile :: FilePath -> FilePath -> IO ()
createDirectoryIfMissing :: Bool -> FilePath -> IO ()
data Permissions
findExecutable :: String -> IO (Maybe FilePath)
getAppUserDataDirectory :: String -> IO FilePath
getHomeDirectory :: IO FilePath
getTemporaryDirectory :: IO FilePath
getUserDocumentsDirectory :: IO FilePath
instance Eq Permissions
instance Ord Permissions
instance Read Permissions
instance Show Permissions
removeDirectoryRecursive :: FilePath -> IO ()

module System.Environment
getEnvironment :: IO [(String, String)]
withArgs :: [String] -> IO a -> IO a
withProgName :: String -> IO a -> IO a

module System.Exit
ExitFailure :: Int -> ExitCode
ExitSuccess :: ExitCode
data ExitCode
instance Eq ExitCode
instance Ord ExitCode
instance Read ExitCode
instance Show ExitCode

module System.IO
AbsoluteSeek :: SeekMode
AppendMode :: IOMode
BlockBuffering :: (Maybe Int) -> BufferMode
LineBuffering :: BufferMode
NoBuffering :: BufferMode
ReadMode :: IOMode
ReadWriteMode :: IOMode
RelativeSeek :: SeekMode
SeekFromEnd :: SeekMode
WriteMode :: IOMode
data BufferMode
data Handle
data HandlePosn
data IOMode
data SeekMode
fixIO :: (a -> IO a) -> IO a
hGetBuf :: Handle -> Ptr a -> Int -> IO Int
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
hGetEcho :: Handle -> IO Bool
hIsTerminalDevice :: Handle -> IO Bool
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
hSetBinaryMode :: Handle -> Bool -> IO ()
hSetEcho :: Handle -> Bool -> IO ()
hSetFileSize :: Handle -> Integer -> IO ()
hShow :: Handle -> IO String
hTell :: Handle -> IO Integer
instance Data Handle
instance Enum IOMode
instance Enum SeekMode
instance Eq BufferMode
instance Eq Handle
instance Eq HandlePosn
instance Eq IOMode
instance Eq SeekMode
instance Ix IOMode
instance Ix SeekMode
instance Ord BufferMode
instance Ord IOMode
instance Ord SeekMode
instance Read BufferMode
instance Read IOMode
instance Read SeekMode
instance Show BufferMode
instance Show Handle
instance Show HandlePosn
instance Show IOMode
instance Show SeekMode
instance Typeable Handle
openBinaryFile :: FilePath -> IOMode -> IO Handle
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
openTempFile :: FilePath -> String -> IO (FilePath, Handle)

module System.IO.Error
alreadyExistsErrorType :: IOErrorType
alreadyInUseErrorType :: IOErrorType
annotateIOError :: IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError
data IOErrorType
doesNotExistErrorType :: IOErrorType
eofErrorType :: IOErrorType
fullErrorType :: IOErrorType
illegalOperationErrorType :: IOErrorType
instance Eq IOErrorType
instance Show IOErrorType
ioeGetErrorType :: IOError -> IOErrorType
ioeSetErrorString :: IOError -> String -> IOError
ioeSetErrorType :: IOError -> IOErrorType -> IOError
ioeSetFileName :: IOError -> FilePath -> IOError
ioeSetHandle :: IOError -> Handle -> IOError
isAlreadyExistsErrorType :: IOErrorType -> Bool
isAlreadyInUseErrorType :: IOErrorType -> Bool
isDoesNotExistErrorType :: IOErrorType -> Bool
isEOFErrorType :: IOErrorType -> Bool
isFullErrorType :: IOErrorType -> Bool
isIllegalOperationErrorType :: IOErrorType -> Bool
isPermissionErrorType :: IOErrorType -> Bool
isUserErrorType :: IOErrorType -> Bool
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError
modifyIOError :: (IOError -> IOError) -> IO a -> IO a
permissionErrorType :: IOErrorType
userErrorType :: IOErrorType

module System.IO.Unsafe
unsafeInterleaveIO :: IO a -> IO a

module System.Info
arch :: String
compilerName :: String
compilerVersion :: Version
os :: String

module System.Locale
TimeLocale :: [(String,String)] -> [(String,String)] -> [(String,String)] -> String,String -> String -> String -> String -> String -> TimeLocale
amPm :: TimeLocale -> String,String
data TimeLocale
dateFmt :: TimeLocale -> String
dateTimeFmt :: TimeLocale -> String
instance Eq TimeLocale
instance Ord TimeLocale
instance Show TimeLocale
intervals :: TimeLocale -> [(String,String)]
iso8601DateFormat :: Maybe String -> String
months :: TimeLocale -> [(String,String)]
rfc822DateFormat :: String
time12Fmt :: TimeLocale -> String
timeFmt :: TimeLocale -> String
wDays :: TimeLocale -> [(String,String)]

module System.Mem
performGC :: IO ()

module System.Mem.StableName
data StableName a
hashStableName :: StableName a -> Int
instance Eq (StableName a)
instance Typeable1 StableName
makeStableName :: a -> IO (StableName a)

module System.Mem.Weak
addFinalizer :: key -> IO () -> IO ()
data Weak v
deRefWeak :: Weak v -> IO (Maybe v)
finalize :: Weak v -> IO ()
instance Typeable1 Weak
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)
mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))
mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)

module System.Posix.Types
Fd :: CInt -> Fd
data CDev
data CIno
data CMode
data COff
data CPid
data CSsize
instance Bits CIno
instance Bits CMode
instance Bits COff
instance Bits CPid
instance Bits CSsize
instance Bits Fd
instance Bounded CIno
instance Bounded CMode
instance Bounded COff
instance Bounded CPid
instance Bounded CSsize
instance Bounded Fd
instance Enum CDev
instance Enum CIno
instance Enum CMode
instance Enum COff
instance Enum CPid
instance Enum CSsize
instance Enum Fd
instance Eq CDev
instance Eq CIno
instance Eq CMode
instance Eq COff
instance Eq CPid
instance Eq CSsize
instance Eq Fd
instance Integral CIno
instance Integral CMode
instance Integral COff
instance Integral CPid
instance Integral CSsize
instance Integral Fd
instance Num CDev
instance Num CIno
instance Num CMode
instance Num COff
instance Num CPid
instance Num CSsize
instance Num Fd
instance Ord CDev
instance Ord CIno
instance Ord CMode
instance Ord COff
instance Ord CPid
instance Ord CSsize
instance Ord Fd
instance Read CDev
instance Read CIno
instance Read CMode
instance Read COff
instance Read CPid
instance Read CSsize
instance Read Fd
instance Real CDev
instance Real CIno
instance Real CMode
instance Real COff
instance Real CPid
instance Real CSsize
instance Real Fd
instance Show CDev
instance Show CIno
instance Show CMode
instance Show COff
instance Show CPid
instance Show CSsize
instance Show Fd
instance Storable CDev
instance Storable CIno
instance Storable CMode
instance Storable COff
instance Storable CPid
instance Storable CSsize
instance Storable Fd
instance Typeable CDev
instance Typeable CIno
instance Typeable CMode
instance Typeable COff
instance Typeable CPid
instance Typeable CSsize
instance Typeable Fd
newtype Fd
type ByteCount = CSize
type ClockTick = CClock
type DeviceID = CDev
type EpochTime = CTime
type FileID = CIno
type FileMode = CMode
type FileOffset = COff
type Limit = CLong
type ProcessGroupID = CPid
type ProcessID = CPid

module System.Process
data ProcessHandle
getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
runCommand :: String -> IO ProcessHandle
runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
terminateProcess :: ProcessHandle -> IO ()
waitForProcess :: ProcessHandle -> IO ExitCode

module System.Random
class Random a
class RandomGen g
data StdGen
genRange :: RandomGen g => g -> (Int,Int)
instance RandomGen StdGen
instance Read StdGen
instance Show StdGen
next :: RandomGen g => g -> (Int,g)
random :: (Random a, RandomGen g) => g -> (a,g)
randomR :: (Random a, RandomGen g) => (a,a) -> g -> (a,g)
randomRs :: (Random a, RandomGen g) => (a,a) -> g -> [a]
randoms :: (Random a, RandomGen g) => g -> [a]
split :: RandomGen g => g -> (g,g)

module System.Time
April :: Month
August :: Month
CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
December :: Month
February :: Month
Friday :: Day
January :: Month
July :: Month
June :: Month
March :: Month
May :: Month
Monday :: Day
November :: Month
October :: Month
Saturday :: Day
September :: Month
Sunday :: Day
TOD :: Integer -> Integer -> ClockTime
Thursday :: Day
TimeDiff :: Int -> Int -> Int -> Int -> Int -> Int -> Integer -> TimeDiff
Tuesday :: Day
Wednesday :: Day
ctDay :: CalendarTime -> Int
ctHour :: CalendarTime -> Int
ctIsDST :: CalendarTime -> Bool
ctMin :: CalendarTime -> Int
ctMonth :: CalendarTime -> Month
ctPicosec :: CalendarTime -> Integer
ctSec :: CalendarTime -> Int
ctTZ :: CalendarTime -> Int
ctTZName :: CalendarTime -> String
ctWDay :: CalendarTime -> Day
ctYDay :: CalendarTime -> Int
ctYear :: CalendarTime -> Int
data CalendarTime
data ClockTime
data Day
data Month
data TimeDiff
formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
instance Bounded Day
instance Bounded Month
instance Enum Day
instance Enum Month
instance Eq CalendarTime
instance Eq ClockTime
instance Eq Day
instance Eq Month
instance Eq TimeDiff
instance Ix Day
instance Ix Month
instance Ord CalendarTime
instance Ord ClockTime
instance Ord Day
instance Ord Month
instance Ord TimeDiff
instance Read CalendarTime
instance Read Day
instance Read Month
instance Read TimeDiff
instance Show CalendarTime
instance Show ClockTime
instance Show Day
instance Show Month
instance Show TimeDiff
noTimeDiff :: TimeDiff
normalizeTimeDiff :: TimeDiff -> TimeDiff
tdDay :: TimeDiff -> Int
tdHour :: TimeDiff -> Int
tdMin :: TimeDiff -> Int
tdMonth :: TimeDiff -> Int
tdPicosec :: TimeDiff -> Integer
tdSec :: TimeDiff -> Int
tdYear :: TimeDiff -> Int
timeDiffToString :: TimeDiff -> String

module System.Win32.DLL
c_DisableThreadLibraryCalls :: HMODULE -> IO Bool
c_FreeLibrary :: HMODULE -> IO Bool
c_GetModuleFileName :: HMODULE -> LPTSTR -> Int -> IO Bool
c_GetModuleHandle :: LPCTSTR -> IO HMODULE
c_GetProcAddress :: HMODULE -> LPCSTR -> IO Addr
c_LoadLibrary :: LPCTSTR -> IO HINSTANCE
c_LoadLibraryEx :: LPCTSTR -> HANDLE -> LoadLibraryFlags -> IO HINSTANCE
disableThreadLibraryCalls :: HMODULE -> IO ()
freeLibrary :: HMODULE -> IO ()
getModuleFileName :: HMODULE -> IO String
getModuleHandle :: Maybe String -> IO HMODULE
getProcAddress :: HMODULE -> String -> IO Addr
lOAD_LIBRARY_AS_DATAFILE :: LoadLibraryFlags
lOAD_WITH_ALTERED_SEARCH_PATH :: LoadLibraryFlags
loadLibrary :: String -> IO HINSTANCE
loadLibraryEx :: String -> HANDLE -> LoadLibraryFlags -> IO HINSTANCE
type LoadLibraryFlags = DWORD

module System.Win32.File
aCCESS_SYSTEM_SECURITY :: AccessMode
areFileApisANSI :: IO Bool
cREATE_ALWAYS :: CreateMode
cREATE_NEW :: CreateMode
c_CloseHandle :: HANDLE -> IO Bool
c_CopyFile :: LPCTSTR -> LPCTSTR -> Bool -> IO Bool
c_CreateDirectory :: LPCTSTR -> LPSECURITY_ATTRIBUTES -> IO Bool
c_CreateDirectoryEx :: LPCTSTR -> LPCTSTR -> LPSECURITY_ATTRIBUTES -> IO Bool
c_CreateFile :: LPCTSTR -> AccessMode -> ShareMode -> LPSECURITY_ATTRIBUTES -> CreateMode -> FileAttributeOrFlag -> HANDLE -> IO HANDLE
c_DefineDosDevice :: DefineDosDeviceFlags -> LPCTSTR -> LPCTSTR -> IO Bool
c_DeleteFile :: LPCTSTR -> IO Bool
c_FindCloseChangeNotification :: HANDLE -> IO Bool
c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
c_FindNextChangeNotification :: HANDLE -> IO Bool
c_FlushFileBuffers :: HANDLE -> IO Bool
c_GetBinaryType :: LPCTSTR -> Ptr DWORD -> IO Bool
c_GetDiskFreeSpace :: LPCTSTR -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> IO Bool
c_GetFileAttributes :: LPCTSTR -> IO FileAttributeOrFlag
c_GetLogicalDrives :: IO DWORD
c_MoveFile :: LPCTSTR -> LPCTSTR -> IO Bool
c_MoveFileEx :: LPCTSTR -> LPCTSTR -> MoveFileFlag -> IO Bool
c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
c_RemoveDirectory :: LPCTSTR -> IO Bool
c_SetCurrentDirectory :: LPCTSTR -> IO Bool
c_SetEndOfFile :: HANDLE -> IO Bool
c_SetFileAttributes :: LPCTSTR -> FileAttributeOrFlag -> IO Bool
c_SetVolumeLabel :: LPCTSTR -> LPCTSTR -> IO Bool
c_WriteFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
closeHandle :: HANDLE -> IO ()
copyFile :: String -> String -> Bool -> IO ()
createDirectory :: String -> Maybe LPSECURITY_ATTRIBUTES -> IO ()
createDirectoryEx :: String -> String -> Maybe LPSECURITY_ATTRIBUTES -> IO ()
createFile :: String -> AccessMode -> ShareMode -> Maybe LPSECURITY_ATTRIBUTES -> CreateMode -> FileAttributeOrFlag -> Maybe HANDLE -> IO HANDLE
dDD_EXACT_MATCH_ON_REMOVE :: DefineDosDeviceFlags
dDD_RAW_TARGET_PATH :: DefineDosDeviceFlags
dDD_REMOVE_DEFINITION :: DefineDosDeviceFlags
dELETE :: AccessMode
dRIVE_CDROM :: DriveType
dRIVE_FIXED :: DriveType
dRIVE_NO_ROOT_DIR :: DriveType
dRIVE_RAMDISK :: DriveType
dRIVE_REMOTE :: DriveType
dRIVE_REMOVABLE :: DriveType
dRIVE_UNKNOWN :: DriveType
defineDosDevice :: DefineDosDeviceFlags -> String -> String -> IO ()
deleteFile :: String -> IO ()
fILE_ATTRIBUTE_ARCHIVE :: FileAttributeOrFlag
fILE_ATTRIBUTE_COMPRESSED :: FileAttributeOrFlag
fILE_ATTRIBUTE_DIRECTORY :: FileAttributeOrFlag
fILE_ATTRIBUTE_HIDDEN :: FileAttributeOrFlag
fILE_ATTRIBUTE_NORMAL :: FileAttributeOrFlag
fILE_ATTRIBUTE_READONLY :: FileAttributeOrFlag
fILE_ATTRIBUTE_SYSTEM :: FileAttributeOrFlag
fILE_ATTRIBUTE_TEMPORARY :: FileAttributeOrFlag
fILE_BEGIN :: FilePtrDirection
fILE_CURRENT :: FilePtrDirection
fILE_END :: FilePtrDirection
fILE_FLAG_BACKUP_SEMANTICS :: FileAttributeOrFlag
fILE_FLAG_DELETE_ON_CLOSE :: FileAttributeOrFlag
fILE_FLAG_NO_BUFFERING :: FileAttributeOrFlag
fILE_FLAG_OVERLAPPED :: FileAttributeOrFlag
fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
fILE_FLAG_RANDOM_ACCESS :: FileAttributeOrFlag
fILE_FLAG_SEQUENTIAL_SCAN :: FileAttributeOrFlag
fILE_FLAG_WRITE_THROUGH :: FileAttributeOrFlag
fILE_NOTIFY_CHANGE_ATTRIBUTES :: FileNotificationFlag
fILE_NOTIFY_CHANGE_DIR_NAME :: FileNotificationFlag
fILE_NOTIFY_CHANGE_FILE_NAME :: FileNotificationFlag
fILE_NOTIFY_CHANGE_LAST_WRITE :: FileNotificationFlag
fILE_NOTIFY_CHANGE_SECURITY :: FileNotificationFlag
fILE_NOTIFY_CHANGE_SIZE :: FileNotificationFlag
fILE_SHARE_NONE :: ShareMode
fILE_SHARE_READ :: ShareMode
fILE_SHARE_WRITE :: ShareMode
fILE_TYPE_CHAR :: FileType
fILE_TYPE_DISK :: FileType
fILE_TYPE_PIPE :: FileType
fILE_TYPE_REMOTE :: FileType
fILE_TYPE_UNKNOWN :: FileType
findCloseChangeNotification :: HANDLE -> IO ()
findFirstChangeNotification :: String -> Bool -> FileNotificationFlag -> IO HANDLE
findNextChangeNotification :: HANDLE -> IO ()
flushFileBuffers :: HANDLE -> IO ()
gENERIC_ALL :: AccessMode
gENERIC_EXECUTE :: AccessMode
gENERIC_NONE :: AccessMode
gENERIC_READ :: AccessMode
gENERIC_WRITE :: AccessMode
getBinaryType :: String -> IO BinaryType
getDiskFreeSpace :: Maybe String -> IO (DWORD, DWORD, DWORD, DWORD)
getFileAttributes :: String -> IO FileAttributeOrFlag
getFileType :: HANDLE -> IO FileType
getLogicalDrives :: IO DWORD
mAXIMUM_ALLOWED :: AccessMode
mOVEFILE_COPY_ALLOWED :: MoveFileFlag
mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
mOVEFILE_REPLACE_EXISTING :: MoveFileFlag
moveFile :: String -> String -> IO ()
moveFileEx :: String -> String -> MoveFileFlag -> IO ()
oPEN_ALWAYS :: CreateMode
oPEN_EXISTING :: CreateMode
rEAD_CONTROL :: AccessMode
removeDirectory :: String -> IO ()
sCS_32BIT_BINARY :: BinaryType
sCS_DOS_BINARY :: BinaryType
sCS_OS216_BINARY :: BinaryType
sCS_PIF_BINARY :: BinaryType
sCS_POSIX_BINARY :: BinaryType
sCS_WOW_BINARY :: BinaryType
sECURITY_ANONYMOUS :: FileAttributeOrFlag
sECURITY_CONTEXT_TRACKING :: FileAttributeOrFlag
sECURITY_DELEGATION :: FileAttributeOrFlag
sECURITY_EFFECTIVE_ONLY :: FileAttributeOrFlag
sECURITY_IDENTIFICATION :: FileAttributeOrFlag
sECURITY_IMPERSONATION :: FileAttributeOrFlag
sECURITY_SQOS_PRESENT :: FileAttributeOrFlag
sECURITY_VALID_SQOS_FLAGS :: FileAttributeOrFlag
sPECIFIC_RIGHTS_ALL :: AccessMode
sTANDARD_RIGHTS_ALL :: AccessMode
sTANDARD_RIGHTS_EXECUTE :: AccessMode
sTANDARD_RIGHTS_READ :: AccessMode
sTANDARD_RIGHTS_REQUIRED :: AccessMode
sTANDARD_RIGHTS_WRITE :: AccessMode
sYNCHRONIZE :: AccessMode
setCurrentDirectory :: String -> IO ()
setEndOfFile :: HANDLE -> IO ()
setFileApisToANSI :: IO ()
setFileApisToOEM :: IO ()
setFileAttributes :: String -> FileAttributeOrFlag -> IO ()
setHandleCount :: UINT -> IO UINT
setVolumeLabel :: String -> String -> IO ()
tRUNCATE_EXISTING :: CreateMode
type AccessMode = UINT
type BinaryType = DWORD
type CreateMode = UINT
type DefineDosDeviceFlags = DWORD
type DriveType = UINT
type FileAttributeOrFlag = UINT
type FileNotificationFlag = DWORD
type FilePtrDirection = DWORD
type FileType = DWORD
type LPOVERLAPPED = Ptr ()
type LPSECURITY_ATTRIBUTES = Ptr ()
type MbLPOVERLAPPED = Maybe LPOVERLAPPED
type MbLPSECURITY_ATTRIBUTES = Maybe LPSECURITY_ATTRIBUTES
type MoveFileFlag = DWORD
type ShareMode = UINT
wRITE_DAC :: AccessMode
wRITE_OWNER :: AccessMode
win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD

module System.Win32.Info
cOLOR_ACTIVEBORDER :: SystemColor
cOLOR_ACTIVECAPTION :: SystemColor
cOLOR_APPWORKSPACE :: SystemColor
cOLOR_BACKGROUND :: SystemColor
cOLOR_BTNFACE :: SystemColor
cOLOR_BTNHIGHLIGHT :: SystemColor
cOLOR_BTNSHADOW :: SystemColor
cOLOR_BTNTEXT :: SystemColor
cOLOR_CAPTIONTEXT :: SystemColor
cOLOR_GRAYTEXT :: SystemColor
cOLOR_HIGHLIGHT :: SystemColor
cOLOR_HIGHLIGHTTEXT :: SystemColor
cOLOR_INACTIVEBORDER :: SystemColor
cOLOR_INACTIVECAPTION :: SystemColor
cOLOR_INACTIVECAPTIONTEXT :: SystemColor
cOLOR_MENU :: SystemColor
cOLOR_MENUTEXT :: SystemColor
cOLOR_SCROLLBAR :: SystemColor
cOLOR_WINDOW :: SystemColor
cOLOR_WINDOWFRAME :: SystemColor
cOLOR_WINDOWTEXT :: SystemColor
sM_ARRANGE :: SMSetting
sM_CLEANBOOT :: SMSetting
sM_CMETRICS :: SMSetting
sM_CMOUSEBUTTONS :: SMSetting
sM_CXBORDER :: SMSetting
sM_CXCURSOR :: SMSetting
sM_CXDLGFRAME :: SMSetting
sM_CXDOUBLECLK :: SMSetting
sM_CXDRAG :: SMSetting
sM_CXEDGE :: SMSetting
sM_CXFRAME :: SMSetting
sM_CXFULLSCREEN :: SMSetting
sM_CXHSCROLL :: SMSetting
sM_CXICON :: SMSetting
sM_CXICONSPACING :: SMSetting
sM_CXMAXIMIZED :: SMSetting
sM_CXMENUCHECK :: SMSetting
sM_CXMENUSIZE :: SMSetting
sM_CXMIN :: SMSetting
sM_CXMINIMIZED :: SMSetting
sM_CXMINTRACK :: SMSetting
sM_CXSCREEN :: SMSetting
sM_CXSIZE :: SMSetting
sM_CXSIZEFRAME :: SMSetting
sM_CXSMICON :: SMSetting
sM_CXSMSIZE :: SMSetting
sM_CXVSCROLL :: SMSetting
sM_CYBORDER :: SMSetting
sM_CYCAPTION :: SMSetting
sM_CYCURSOR :: SMSetting
sM_CYDLGFRAME :: SMSetting
sM_CYDOUBLECLK :: SMSetting
sM_CYDRAG :: SMSetting
sM_CYEDGE :: SMSetting
sM_CYFRAME :: SMSetting
sM_CYFULLSCREEN :: SMSetting
sM_CYHSCROLL :: SMSetting
sM_CYICON :: SMSetting
sM_CYICONSPACING :: SMSetting
sM_CYKANJIWINDOW :: SMSetting
sM_CYMAXIMIZED :: SMSetting
sM_CYMENU :: SMSetting
sM_CYMENUCHECK :: SMSetting
sM_CYMENUSIZE :: SMSetting
sM_CYMIN :: SMSetting
sM_CYMINIMIZED :: SMSetting
sM_CYMINTRACK :: SMSetting
sM_CYSCREEN :: SMSetting
sM_CYSIZE :: SMSetting
sM_CYSIZEFRAME :: SMSetting
sM_CYSMCAPTION :: SMSetting
sM_CYSMICON :: SMSetting
sM_CYSMSIZE :: SMSetting
sM_CYVSCROLL :: SMSetting
sM_CYVTHUMB :: SMSetting
sM_DBCSENABLED :: SMSetting
sM_DEBUG :: SMSetting
sM_MENUDROPALIGNMENT :: SMSetting
sM_MIDEASTENABLED :: SMSetting
sM_MOUSEPRESENT :: SMSetting
sM_NETWORK :: SMSetting
sM_PENWINDOWS :: SMSetting
sM_SECURE :: SMSetting
sM_SHOWSOUNDS :: SMSetting
sM_SLOWMACHINE :: SMSetting
sM_SWAPBUTTON :: SMSetting
type SMSetting = UINT
type SystemColor = UINT

module System.Win32.Mem
c_GlobalAlloc :: GlobalAllocFlags -> DWORD -> IO HGLOBAL
c_GlobalFlags :: HGLOBAL -> IO GlobalAllocFlags
c_GlobalFree :: HGLOBAL -> IO HGLOBAL
c_GlobalHandle :: Addr -> IO HGLOBAL
c_GlobalLock :: HGLOBAL -> IO Addr
c_GlobalReAlloc :: HGLOBAL -> DWORD -> GlobalAllocFlags -> IO HGLOBAL
c_GlobalSize :: HGLOBAL -> IO DWORD
c_GlobalUnlock :: HGLOBAL -> IO Bool
c_HeapAlloc :: HANDLE -> HeapAllocFlags -> DWORD -> IO Addr
c_HeapCompact :: HANDLE -> HeapAllocFlags -> IO UINT
c_HeapCreate :: HeapAllocFlags -> DWORD -> DWORD -> IO HANDLE
c_HeapDestroy :: HANDLE -> IO Bool
c_HeapFree :: HANDLE -> HeapAllocFlags -> Addr -> IO Bool
c_HeapLock :: HANDLE -> IO Bool
c_HeapReAlloc :: HANDLE -> HeapAllocFlags -> Addr -> DWORD -> IO Addr
c_HeapSize :: HANDLE -> HeapAllocFlags -> Addr -> IO DWORD
c_HeapUnlock :: HANDLE -> IO Bool
c_VirtualAlloc :: Addr -> DWORD -> DWORD -> DWORD -> IO Addr
c_VirtualFree :: Addr -> DWORD -> FreeFlags -> IO Bool
c_VirtualLock :: Addr -> DWORD -> IO Bool
c_VirtualProtect :: Addr -> DWORD -> DWORD -> Ptr DWORD -> IO Bool
c_VirtualProtectEx :: HANDLE -> Addr -> DWORD -> DWORD -> Ptr DWORD -> IO Bool
c_VirtualUnlock :: Addr -> DWORD -> IO Bool
copyMemory :: Ptr a -> Ptr a -> DWORD -> IO ()
fillMemory :: Ptr a -> DWORD -> BYTE -> IO ()
gHND :: GlobalAllocFlags
gMEM_DDESHARE :: GlobalAllocFlags
gMEM_FIXED :: GlobalAllocFlags
gMEM_INVALID_HANDLE :: GlobalAllocFlags
gMEM_LOWER :: GlobalAllocFlags
gMEM_MOVEABLE :: GlobalAllocFlags
gMEM_NOCOMPACT :: GlobalAllocFlags
gMEM_NODISCARD :: GlobalAllocFlags
gMEM_NOTIFY :: GlobalAllocFlags
gMEM_NOT_BANKED :: GlobalAllocFlags
gMEM_SHARE :: GlobalAllocFlags
gMEM_ZEROINIT :: GlobalAllocFlags
gPTR :: GlobalAllocFlags
getProcessHeap :: IO HANDLE
getProcessHeaps :: DWORD -> Addr -> IO DWORD
globalAlloc :: GlobalAllocFlags -> DWORD -> IO HGLOBAL
globalFlags :: HGLOBAL -> IO GlobalAllocFlags
globalFree :: HGLOBAL -> IO HGLOBAL
globalHandle :: Addr -> IO HGLOBAL
globalLock :: HGLOBAL -> IO Addr
globalReAlloc :: HGLOBAL -> DWORD -> GlobalAllocFlags -> IO HGLOBAL
globalSize :: HGLOBAL -> IO DWORD
globalUnlock :: HGLOBAL -> IO ()
hEAP_GENERATE_EXCEPTIONS :: HeapAllocFlags
hEAP_NO_SERIALIZE :: HeapAllocFlags
hEAP_ZERO_MEMORY :: HeapAllocFlags
heapAlloc :: HANDLE -> HeapAllocFlags -> DWORD -> IO Addr
heapCompact :: HANDLE -> HeapAllocFlags -> IO UINT
heapCreate :: HeapAllocFlags -> DWORD -> DWORD -> IO HANDLE
heapDestroy :: HANDLE -> IO ()
heapFree :: HANDLE -> HeapAllocFlags -> Addr -> IO ()
heapLock :: HANDLE -> IO ()
heapReAlloc :: HANDLE -> HeapAllocFlags -> Addr -> DWORD -> IO Addr
heapSize :: HANDLE -> HeapAllocFlags -> Addr -> IO DWORD
heapUnlock :: HANDLE -> IO ()
heapValidate :: HANDLE -> HeapAllocFlags -> Addr -> IO Bool
mEM_COMMIT :: VirtualAllocFlags
mEM_DECOMMIT :: FreeFlags
mEM_RELEASE :: FreeFlags
mEM_RESERVE :: VirtualAllocFlags
memset :: Ptr a -> CInt -> CSize -> IO ()
moveMemory :: Ptr a -> Ptr a -> DWORD -> IO ()
pAGE_EXECUTE :: ProtectFlags
pAGE_EXECUTE_READ :: ProtectFlags
pAGE_EXECUTE_READWRITE :: ProtectFlags
pAGE_GUARD :: ProtectFlags
pAGE_NOACCESS :: ProtectFlags
pAGE_NOCACHE :: ProtectFlags
pAGE_READONLY :: ProtectFlags
pAGE_READWRITE :: ProtectFlags
type FreeFlags = DWORD
type GlobalAllocFlags = UINT
type HGLOBAL = Addr
type HeapAllocFlags = DWORD
type ProtectFlags = DWORD
type VirtualAllocFlags = DWORD
virtualAlloc :: Addr -> DWORD -> VirtualAllocFlags -> ProtectFlags -> IO Addr
virtualFree :: Addr -> DWORD -> FreeFlags -> IO ()
virtualLock :: Addr -> DWORD -> IO ()
virtualProtect :: Addr -> DWORD -> ProtectFlags -> IO ProtectFlags
virtualProtectEx :: HANDLE -> Addr -> DWORD -> ProtectFlags -> IO ProtectFlags
virtualUnlock :: Addr -> DWORD -> IO ()
zeroMemory :: Ptr a -> DWORD -> IO ()

module System.Win32.NLS
cP_ACP :: CodePage
cP_MACCP :: CodePage
cP_OEMCP :: CodePage
c_LCMapString :: LCID -> LCMapFlags -> LPCTSTR -> Int -> LPCTSTR -> Int -> IO Int
c_SetLocaleInfo :: LCID -> LCTYPE -> LPCTSTR -> IO Bool
convertDefaultLocale :: LCID -> IO LCID
getACP :: IO CodePage
getOEMCP :: CodePage
getSystemDefaultLCID :: LCID
getSystemDefaultLangID :: LANGID
getThreadLocale :: IO LCID
getUserDefaultLCID :: LCID
getUserDefaultLangID :: LANGID
isValidCodePage :: CodePage -> IO Bool
isValidLocale :: LCID -> LocaleTestFlags -> IO Bool
lANGIDFROMLCID :: LCID -> LANGID
lANG_AFRIKAANS :: PrimaryLANGID
lANG_ALBANIAN :: PrimaryLANGID
lANG_ARABIC :: PrimaryLANGID
lANG_ARMENIAN :: PrimaryLANGID
lANG_ASSAMESE :: PrimaryLANGID
lANG_AZERI :: PrimaryLANGID
lANG_BASQUE :: PrimaryLANGID
lANG_BELARUSIAN :: PrimaryLANGID
lANG_BENGALI :: PrimaryLANGID
lANG_BULGARIAN :: PrimaryLANGID
lANG_CATALAN :: PrimaryLANGID
lANG_CHINESE :: PrimaryLANGID
lANG_CROATIAN :: PrimaryLANGID
lANG_CZECH :: PrimaryLANGID
lANG_DANISH :: PrimaryLANGID
lANG_DUTCH :: PrimaryLANGID
lANG_ENGLISH :: PrimaryLANGID
lANG_ESTONIAN :: PrimaryLANGID
lANG_FAEROESE :: PrimaryLANGID
lANG_FARSI :: PrimaryLANGID
lANG_FINNISH :: PrimaryLANGID
lANG_FRENCH :: PrimaryLANGID
lANG_GEORGIAN :: PrimaryLANGID
lANG_GERMAN :: PrimaryLANGID
lANG_GREEK :: PrimaryLANGID
lANG_GUJARATI :: PrimaryLANGID
lANG_HEBREW :: PrimaryLANGID
lANG_HINDI :: PrimaryLANGID
lANG_HUNGARIAN :: PrimaryLANGID
lANG_ICELANDIC :: PrimaryLANGID
lANG_INDONESIAN :: PrimaryLANGID
lANG_ITALIAN :: PrimaryLANGID
lANG_JAPANESE :: PrimaryLANGID
lANG_KANNADA :: PrimaryLANGID
lANG_KASHMIRI :: PrimaryLANGID
lANG_KAZAK :: PrimaryLANGID
lANG_KONKANI :: PrimaryLANGID
lANG_KOREAN :: PrimaryLANGID
lANG_LATVIAN :: PrimaryLANGID
lANG_LITHUANIAN :: PrimaryLANGID
lANG_MACEDONIAN :: PrimaryLANGID
lANG_MALAY :: PrimaryLANGID
lANG_MALAYALAM :: PrimaryLANGID
lANG_MANIPURI :: PrimaryLANGID
lANG_MARATHI :: PrimaryLANGID
lANG_NEPALI :: PrimaryLANGID
lANG_NEUTRAL :: PrimaryLANGID
lANG_NORWEGIAN :: PrimaryLANGID
lANG_ORIYA :: PrimaryLANGID
lANG_POLISH :: PrimaryLANGID
lANG_PORTUGUESE :: PrimaryLANGID
lANG_PUNJABI :: PrimaryLANGID
lANG_ROMANIAN :: PrimaryLANGID
lANG_RUSSIAN :: PrimaryLANGID
lANG_SANSKRIT :: PrimaryLANGID
lANG_SERBIAN :: PrimaryLANGID
lANG_SINDHI :: PrimaryLANGID
lANG_SLOVAK :: PrimaryLANGID
lANG_SLOVENIAN :: PrimaryLANGID
lANG_SPANISH :: PrimaryLANGID
lANG_SWAHILI :: PrimaryLANGID
lANG_SWEDISH :: PrimaryLANGID
lANG_TAMIL :: PrimaryLANGID
lANG_TATAR :: PrimaryLANGID
lANG_TELUGU :: PrimaryLANGID
lANG_THAI :: PrimaryLANGID
lANG_TURKISH :: PrimaryLANGID
lANG_URDU :: PrimaryLANGID
lANG_UZBEK :: PrimaryLANGID
lANG_VIETNAMESE :: PrimaryLANGID
lCID_INSTALLED :: LocaleTestFlags
lCID_SUPPORTED :: LocaleTestFlags
lCMAP_BYTEREV :: LCMapFlags
lCMAP_FULLWIDTH :: LCMapFlags
lCMAP_HALFWIDTH :: LCMapFlags
lCMAP_HIRAGANA :: LCMapFlags
lCMAP_KATAKANA :: LCMapFlags
lCMAP_LINGUISTIC_CASING :: LCMapFlags
lCMAP_LOWERCASE :: LCMapFlags
lCMAP_SIMPLIFIED_CHINESE :: LCMapFlags
lCMAP_SORTKEY :: LCMapFlags
lCMAP_TRADITIONAL_CHINESE :: LCMapFlags
lCMAP_UPPERCASE :: LCMapFlags
lCMapString :: LCID -> LCMapFlags -> String -> Int -> IO String
lOCALE_ICALENDARTYPE :: LCTYPE
lOCALE_ICURRDIGITS :: LCTYPE
lOCALE_ICURRENCY :: LCTYPE
lOCALE_IDIGITS :: LCTYPE
lOCALE_IFIRSTDAYOFWEEK :: LCTYPE
lOCALE_IFIRSTWEEKOFYEAR :: LCTYPE
lOCALE_ILZERO :: LCTYPE
lOCALE_IMEASURE :: LCTYPE
lOCALE_INEGCURR :: LCTYPE
lOCALE_INEGNUMBER :: LCTYPE
lOCALE_ITIME :: LCTYPE
lOCALE_NEUTRAL :: LCID
lOCALE_S1159 :: LCTYPE
lOCALE_S2359 :: LCTYPE
lOCALE_SCURRENCY :: LCTYPE
lOCALE_SDATE :: LCTYPE
lOCALE_SDECIMAL :: LCTYPE
lOCALE_SGROUPING :: LCTYPE
lOCALE_SLIST :: LCTYPE
lOCALE_SLONGDATE :: LCTYPE
lOCALE_SMONDECIMALSEP :: LCTYPE
lOCALE_SMONGROUPING :: LCTYPE
lOCALE_SMONTHOUSANDSEP :: LCTYPE
lOCALE_SNEGATIVESIGN :: LCTYPE
lOCALE_SPOSITIVESIGN :: LCTYPE
lOCALE_SSHORTDATE :: LCTYPE
lOCALE_STHOUSAND :: LCTYPE
lOCALE_STIME :: LCTYPE
lOCALE_STIMEFORMAT :: LCTYPE
lOCALE_SYSTEM_DEFAULT :: LCID
lOCALE_USER_DEFAULT :: LCID
mAKELANGID :: PrimaryLANGID -> SubLANGID -> LANGID
mAKELCID :: LANGID -> SortID -> LCID
nORM_IGNORECASE :: LCMapFlags
nORM_IGNOREKANATYPE :: LCMapFlags
nORM_IGNORENONSPACE :: LCMapFlags
nORM_IGNORESYMBOLS :: LCMapFlags
nORM_IGNOREWIDTH :: LCMapFlags
pRIMARYLANGID :: LANGID -> PrimaryLANGID
sORTIDFROMLCID :: LCID -> SortID
sORT_CHINESE_BIG5 :: SortID
sORT_CHINESE_UNICODE :: SortID
sORT_DEFAULT :: SortID
sORT_JAPANESE_UNICODE :: SortID
sORT_JAPANESE_XJIS :: SortID
sORT_KOREAN_KSC :: SortID
sORT_KOREAN_UNICODE :: SortID
sORT_STRINGSORT :: LCMapFlags
sUBLANGID :: LANGID -> SubLANGID
sUBLANG_ARABIC_ALGERIA :: SubLANGID
sUBLANG_ARABIC_BAHRAIN :: SubLANGID
sUBLANG_ARABIC_EGYPT :: SubLANGID
sUBLANG_ARABIC_IRAQ :: SubLANGID
sUBLANG_ARABIC_JORDAN :: SubLANGID
sUBLANG_ARABIC_KUWAIT :: SubLANGID
sUBLANG_ARABIC_LEBANON :: SubLANGID
sUBLANG_ARABIC_LIBYA :: SubLANGID
sUBLANG_ARABIC_MOROCCO :: SubLANGID
sUBLANG_ARABIC_OMAN :: SubLANGID
sUBLANG_ARABIC_QATAR :: SubLANGID
sUBLANG_ARABIC_SAUDI_ARABIA :: SubLANGID
sUBLANG_ARABIC_SYRIA :: SubLANGID
sUBLANG_ARABIC_TUNISIA :: SubLANGID
sUBLANG_ARABIC_UAE :: SubLANGID
sUBLANG_ARABIC_YEMEN :: SubLANGID
sUBLANG_AZERI_CYRILLIC :: SubLANGID
sUBLANG_AZERI_LATIN :: SubLANGID
sUBLANG_CHINESE_HONGKONG :: SubLANGID
sUBLANG_CHINESE_MACAU :: SubLANGID
sUBLANG_CHINESE_SIMPLIFIED :: SubLANGID
sUBLANG_CHINESE_SINGAPORE :: SubLANGID
sUBLANG_CHINESE_TRADITIONAL :: SubLANGID
sUBLANG_DEFAULT :: SubLANGID
sUBLANG_DUTCH :: SubLANGID
sUBLANG_DUTCH_BELGIAN :: SubLANGID
sUBLANG_ENGLISH_AUS :: SubLANGID
sUBLANG_ENGLISH_BELIZE :: SubLANGID
sUBLANG_ENGLISH_CAN :: SubLANGID
sUBLANG_ENGLISH_CARIBBEAN :: SubLANGID
sUBLANG_ENGLISH_EIRE :: SubLANGID
sUBLANG_ENGLISH_JAMAICA :: SubLANGID
sUBLANG_ENGLISH_NZ :: SubLANGID
sUBLANG_ENGLISH_PHILIPPINES :: SubLANGID
sUBLANG_ENGLISH_SOUTH_AFRICA :: SubLANGID
sUBLANG_ENGLISH_TRINIDAD :: SubLANGID
sUBLANG_ENGLISH_UK :: SubLANGID
sUBLANG_ENGLISH_US :: SubLANGID
sUBLANG_ENGLISH_ZIMBABWE :: SubLANGID
sUBLANG_FRENCH :: SubLANGID
sUBLANG_FRENCH_BELGIAN :: SubLANGID
sUBLANG_FRENCH_CANADIAN :: SubLANGID
sUBLANG_FRENCH_LUXEMBOURG :: SubLANGID
sUBLANG_FRENCH_MONACO :: SubLANGID
sUBLANG_FRENCH_SWISS :: SubLANGID
sUBLANG_GERMAN :: SubLANGID
sUBLANG_GERMAN_AUSTRIAN :: SubLANGID
sUBLANG_GERMAN_LIECHTENSTEIN :: SubLANGID
sUBLANG_GERMAN_LUXEMBOURG :: SubLANGID
sUBLANG_GERMAN_SWISS :: SubLANGID
sUBLANG_ITALIAN :: SubLANGID
sUBLANG_ITALIAN_SWISS :: SubLANGID
sUBLANG_KASHMIRI_INDIA :: SubLANGID
sUBLANG_KOREAN :: SubLANGID
sUBLANG_LITHUANIAN :: SubLANGID
sUBLANG_MALAY_BRUNEI_DARUSSALAM :: SubLANGID
sUBLANG_MALAY_MALAYSIA :: SubLANGID
sUBLANG_NEPALI_INDIA :: SubLANGID
sUBLANG_NEUTRAL :: SubLANGID
sUBLANG_NORWEGIAN_BOKMAL :: SubLANGID
sUBLANG_NORWEGIAN_NYNORSK :: SubLANGID
sUBLANG_PORTUGUESE :: SubLANGID
sUBLANG_PORTUGUESE_BRAZILIAN :: SubLANGID
sUBLANG_SERBIAN_CYRILLIC :: SubLANGID
sUBLANG_SERBIAN_LATIN :: SubLANGID
sUBLANG_SPANISH :: SubLANGID
sUBLANG_SPANISH_ARGENTINA :: SubLANGID
sUBLANG_SPANISH_BOLIVIA :: SubLANGID
sUBLANG_SPANISH_CHILE :: SubLANGID
sUBLANG_SPANISH_COLOMBIA :: SubLANGID
sUBLANG_SPANISH_COSTA_RICA :: SubLANGID
sUBLANG_SPANISH_DOMINICAN_REPUBLIC :: SubLANGID
sUBLANG_SPANISH_ECUADOR :: SubLANGID
sUBLANG_SPANISH_EL_SALVADOR :: SubLANGID
sUBLANG_SPANISH_GUATEMALA :: SubLANGID
sUBLANG_SPANISH_HONDURAS :: SubLANGID
sUBLANG_SPANISH_MEXICAN :: SubLANGID
sUBLANG_SPANISH_MODERN :: SubLANGID
sUBLANG_SPANISH_NICARAGUA :: SubLANGID
sUBLANG_SPANISH_PANAMA :: SubLANGID
sUBLANG_SPANISH_PARAGUAY :: SubLANGID
sUBLANG_SPANISH_PERU :: SubLANGID
sUBLANG_SPANISH_PUERTO_RICO :: SubLANGID
sUBLANG_SPANISH_URUGUAY :: SubLANGID
sUBLANG_SPANISH_VENEZUELA :: SubLANGID
sUBLANG_SWEDISH :: SubLANGID
sUBLANG_SWEDISH_FINLAND :: SubLANGID
sUBLANG_SYS_DEFAULT :: SubLANGID
sUBLANG_URDU_INDIA :: SubLANGID
sUBLANG_URDU_PAKISTAN :: SubLANGID
sUBLANG_UZBEK_CYRILLIC :: SubLANGID
sUBLANG_UZBEK_LATIN :: SubLANGID
setLocaleInfo :: LCID -> LCTYPE -> String -> IO ()
setThreadLocale :: LCID -> IO ()
type CodePage = UINT
type LANGID = WORD
type LCID = DWORD
type LCMapFlags = DWORD
type LCTYPE = UINT
type LocaleTestFlags = DWORD
type PrimaryLANGID = WORD
type SortID = WORD
type SubLANGID = WORD

module System.Win32.Process
iNFINITE :: DWORD
sleep :: DWORD -> IO ()

module System.Win32.Registry
RegInfoKey :: String -> Int -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Int -> Word32 -> Word32 -> RegInfoKey
c_RegCloseKey :: PKEY -> IO ErrCode
c_RegConnectRegistry :: LPCTSTR -> PKEY -> Ptr PKEY -> IO ErrCode
c_RegCreateKey :: PKEY -> LPCTSTR -> Ptr PKEY -> IO ErrCode
c_RegCreateKeyEx :: PKEY -> LPCTSTR -> DWORD -> LPCTSTR -> RegCreateOptions -> REGSAM -> LPSECURITY_ATTRIBUTES -> Ptr PKEY -> Ptr DWORD -> IO ErrCode
c_RegDeleteKey :: PKEY -> LPCTSTR -> IO ErrCode
c_RegDeleteValue :: PKEY -> LPCTSTR -> IO ErrCode
c_RegEnumKey :: PKEY -> DWORD -> LPTSTR -> DWORD -> IO ErrCode
c_RegEnumValue :: PKEY -> DWORD -> LPTSTR -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> LPBYTE -> Ptr DWORD -> IO ErrCode
c_RegFlushKey :: PKEY -> IO ErrCode
c_RegLoadKey :: PKEY -> LPCTSTR -> LPCTSTR -> IO ErrCode
c_RegNotifyChangeKeyValue :: PKEY -> Bool -> RegNotifyOptions -> HANDLE -> Bool -> IO ErrCode
c_RegOpenKey :: PKEY -> LPCTSTR -> Ptr PKEY -> IO ErrCode
c_RegOpenKeyEx :: PKEY -> LPCTSTR -> DWORD -> REGSAM -> Ptr PKEY -> IO ErrCode
c_RegQueryInfoKey :: PKEY -> LPTSTR -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr FILETIME -> IO ErrCode
c_RegQueryValue :: PKEY -> LPCTSTR -> LPTSTR -> Ptr LONG -> IO ErrCode
c_RegQueryValueEx :: PKEY -> LPCTSTR -> Ptr DWORD -> Ptr DWORD -> LPBYTE -> Ptr DWORD -> IO ErrCode
c_RegReplaceKey :: PKEY -> LPCTSTR -> LPCTSTR -> LPCTSTR -> IO ErrCode
c_RegRestoreKey :: PKEY -> LPCTSTR -> RegRestoreFlags -> IO ErrCode
c_RegSaveKey :: PKEY -> LPCTSTR -> LPSECURITY_ATTRIBUTES -> IO ErrCode
c_RegSetValue :: PKEY -> LPCTSTR -> DWORD -> LPCTSTR -> Int -> IO ErrCode
c_RegSetValueEx :: PKEY -> LPCTSTR -> DWORD -> RegValueType -> LPTSTR -> Int -> IO ErrCode
c_RegUnLoadKey :: PKEY -> LPCTSTR -> IO ErrCode
class_id :: RegInfoKey -> Int
class_string :: RegInfoKey -> String
data RegInfoKey
eRROR_NO_MORE_ITEMS :: ErrCode
hKEY_CLASSES_ROOT :: HKEY
hKEY_CURRENT_CONFIG :: HKEY
hKEY_CURRENT_USER :: HKEY
hKEY_LOCAL_MACHINE :: HKEY
hKEY_USERS :: HKEY
kEY_ALL_ACCESS :: REGSAM
kEY_CREATE_LINK :: REGSAM
kEY_CREATE_SUB_KEY :: REGSAM
kEY_ENUMERATE_SUB_KEYS :: REGSAM
kEY_EXECUTE :: REGSAM
kEY_NOTIFY :: REGSAM
kEY_QUERY_VALUE :: REGSAM
kEY_READ :: REGSAM
kEY_SET_VALUE :: REGSAM
kEY_WRITE :: REGSAM
lastWrite_hi :: RegInfoKey -> Word32
lastWrite_lo :: RegInfoKey -> Word32
max_class_len :: RegInfoKey -> Word32
max_subkey_len :: RegInfoKey -> Word32
max_value_len :: RegInfoKey -> Word32
max_value_name_len :: RegInfoKey -> Word32
rEG_BINARY :: RegValueType
rEG_DWORD :: RegValueType
rEG_DWORD_BIG_ENDIAN :: RegValueType
rEG_DWORD_LITTLE_ENDIAN :: RegValueType
rEG_EXPAND_SZ :: RegValueType
rEG_LINK :: RegValueType
rEG_MULTI_SZ :: RegValueType
rEG_NONE :: RegValueType
rEG_NOTIFY_CHANGE_ATTRIBUTES :: RegNotifyOptions
rEG_NOTIFY_CHANGE_LAST_SET :: RegNotifyOptions
rEG_NOTIFY_CHANGE_NAME :: RegNotifyOptions
rEG_NOTIFY_CHANGE_SECURITY :: RegNotifyOptions
rEG_NO_LAZY_FLUSH :: RegRestoreFlags
rEG_OPTION_NON_VOLATILE :: RegCreateOptions
rEG_OPTION_VOLATILE :: RegCreateOptions
rEG_REFRESH_HIVE :: RegRestoreFlags
rEG_RESOURCE_LIST :: RegValueType
rEG_SZ :: RegValueType
rEG_WHOLE_HIVE_VOLATILE :: RegRestoreFlags
regCloseKey :: HKEY -> IO ()
regConnectRegistry :: Maybe String -> HKEY -> IO HKEY
regCreateKey :: HKEY -> String -> IO HKEY
regCreateKeyEx :: HKEY -> String -> String -> RegCreateOptions -> REGSAM -> Maybe LPSECURITY_ATTRIBUTES -> IO (HKEY, Bool)
regDeleteKey :: HKEY -> String -> IO ()
regDeleteValue :: HKEY -> String -> IO ()
regEnumKey :: HKEY -> DWORD -> LPTSTR -> DWORD -> IO (String, Int)
regEnumKeyVals :: HKEY -> IO [(String, String, RegValueType)]
regEnumKeys :: HKEY -> IO [String]
regEnumValue :: HKEY -> DWORD -> LPTSTR -> DWORD -> LPBYTE -> DWORD -> IO (RegValueType, String, Int)
regFlushKey :: HKEY -> IO ()
regLoadKey :: HKEY -> String -> String -> IO ()
regNotifyChangeKeyValue :: HKEY -> Bool -> RegNotifyOptions -> HANDLE -> Bool -> IO ()
regOpenKey :: HKEY -> String -> IO HKEY
regOpenKeyEx :: HKEY -> String -> REGSAM -> IO HKEY
regQueryInfoKey :: HKEY -> IO RegInfoKey
regQueryValue :: HKEY -> Maybe String -> IO String
regQueryValueEx :: HKEY -> String -> LPBYTE -> Int -> IO RegValueType
regQueryValueKey :: HKEY -> Maybe String -> IO String
regReplaceKey :: HKEY -> String -> String -> String -> IO ()
regRestoreKey :: HKEY -> String -> RegRestoreFlags -> IO ()
regSaveKey :: HKEY -> String -> Maybe LPSECURITY_ATTRIBUTES -> IO ()
regSetStringValue :: HKEY -> String -> String -> IO ()
regSetValue :: HKEY -> String -> String -> IO ()
regSetValueEx :: HKEY -> String -> RegValueType -> LPTSTR -> Int -> IO ()
regUnLoadKey :: HKEY -> String -> IO ()
sec_len :: RegInfoKey -> Int
subkeys :: RegInfoKey -> Word32
type FILETIME = ()
type REGSAM = Word32
type RegCreateOptions = DWORD
type RegNotifyOptions = DWORD
type RegRestoreFlags = DWORD
type RegValueType = DWORD
values :: RegInfoKey -> Word32

module System.Win32.Types
castFunPtrToLONG :: FunPtr a -> LONG
castPtrToUINT :: Ptr s -> UINT
castUINTToPtr :: UINT -> Ptr a
deleteObject_p :: FunPtr (HANDLE -> IO ())
errorWin :: String -> IO a
failIf :: (a -> Bool) -> String -> IO a -> IO a
failIfFalse_ :: String -> IO Bool -> IO ()
failIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
failIfZero :: Num a => String -> IO a -> IO a
failIf_ :: (a -> Bool) -> String -> IO a -> IO ()
failUnlessSuccess :: String -> IO ErrCode -> IO ()
failUnlessSuccessOr :: ErrCode -> String -> IO ErrCode -> IO Bool
failWith :: String -> ErrCode -> IO a
getErrorMessage :: DWORD -> IO LPWSTR
getLastError :: IO ErrCode
hIWORD :: DWORD -> WORD
handleToWord :: HANDLE -> UINT
lOWORD :: DWORD -> WORD
localFree :: Ptr a -> IO (Ptr a)
maybeNum :: Num a => Maybe a -> a
maybePtr :: Maybe (Ptr a) -> Ptr a
newForeignHANDLE :: HANDLE -> IO ForeignHANDLE
newTString :: String -> IO LPCTSTR
nullFinalHANDLE :: ForeignPtr a
nullHANDLE :: HANDLE
nullPtr
numToMaybe :: Num a => a -> Maybe a
peekTString :: LPCTSTR -> IO String
peekTStringLen :: (LPCTSTR, Int) -> IO String
ptrToMaybe :: Ptr a -> Maybe (Ptr a)
type ATOM = UINT
type Addr = Ptr ()
type BOOL = Bool
type BYTE = Word8
type DWORD = Word32
type ErrCode = DWORD
type FLOAT = Float
type ForeignHANDLE = ForeignPtr ()
type HANDLE = Ptr ()
type HINSTANCE = Ptr ()
type HKEY = ForeignHANDLE
type HMODULE = Ptr ()
type INT = Int32
type LONG = Int32
type LPARAM = LONG
type LPBYTE = Ptr BYTE
type LPCSTR = LPSTR
type LPCTSTR = LPTSTR
type LPCTSTR_ = LPCTSTR
type LPCWSTR = LPWSTR
type LPSTR = Ptr CChar
type LPTSTR = Ptr TCHAR
type LPVOID = Ptr ()
type LPWSTR = Ptr CWchar
type LRESULT = LONG
type MbATOM = Maybe ATOM
type MbHANDLE = Maybe HANDLE
type MbHINSTANCE = Maybe HINSTANCE
type MbHMODULE = Maybe HMODULE
type MbINT = Maybe INT
type MbLPCSTR = Maybe LPCSTR
type MbLPCTSTR = Maybe LPCTSTR
type MbLPVOID = Maybe LPVOID
type MbString = Maybe String
type PKEY = HANDLE
type TCHAR = CWchar
type UINT = Word32
type USHORT = Word16
type WORD = Word16
type WPARAM = UINT
withTString :: String -> (LPTSTR -> IO a) -> IO a
withTStringLen :: String -> ((LPTSTR, Int) -> IO a) -> IO a

module Test.HUnit.Base
(@=?) :: (Eq a, Show a) => a -> a -> Assertion
(@?) :: AssertionPredicable t => t -> String -> Assertion
(@?=) :: (Eq a, Show a) => a -> a -> Assertion
(~:) :: Testable t => String -> t -> Test
(~=?) :: (Eq a, Show a) => a -> a -> Test
(~?) :: AssertionPredicable t => t -> String -> Test
(~?=) :: (Eq a, Show a) => a -> a -> Test
Counts :: Int -> Int -> Int -> Int -> Counts
Label :: String -> Node
ListItem :: Int -> Node
State :: Path -> Counts -> State
TestCase :: Assertion -> Test
TestLabel :: String -> Test -> Test
TestList :: [Test] -> Test
assert :: Assertable t => t -> Assertion
assertBool :: String -> Bool -> Assertion
assertEqual :: (Eq a, Show a) => String -> a -> a -> Assertion
assertFailure :: String -> Assertion
assertString :: String -> Assertion
assertionPredicate :: AssertionPredicable t => t -> AssertionPredicate
cases :: Counts -> Int
class Assertable t
class AssertionPredicable t
class ListAssertable t
class Testable t
counts :: State -> Counts
data Counts
data Node
data State
data Test
errors :: Counts -> Int
failures :: Counts -> Int
instance Eq Counts
instance Eq Node
instance Eq State
instance Read Counts
instance Read Node
instance Read State
instance Show Counts
instance Show Node
instance Show State
instance Show Test
instance Testable Test
listAssert :: ListAssertable t => [t] -> Assertion
path :: State -> Path
performTest :: ReportStart us -> ReportProblem us -> ReportProblem us -> us -> Test -> IO (Counts, us)
test :: Testable t => t -> Test
testCaseCount :: Test -> Int
testCasePaths :: Test -> [Path]
tried :: Counts -> Int
type Assertion = IO ()
type AssertionPredicate = IO Bool
type Path = [Node]
type ReportProblem us = String -> State -> us -> IO us
type ReportStart us = State -> us -> IO us

module Test.HUnit.Lang
performTestCase :: Assertion -> IO (Maybe (Bool, String))

module Test.HUnit.Terminal
terminalAppearance :: String -> String

module Test.HUnit.Text
PutText :: (String -> Bool -> st -> IO st) -> st -> PutText st
data PutText st
putTextToHandle :: Handle -> Bool -> PutText Int
putTextToShowS :: PutText ShowS
runTestTT :: Test -> IO Counts
runTestText :: PutText st -> Test -> IO (Counts, st)
showCounts :: Counts -> String
showPath :: Path -> String

module Test.QuickCheck
(==>) :: Testable a => Bool -> a -> Property
Config :: Int -> Int -> Int -> Int -> Int -> [String] -> String -> Config
Result :: Maybe Bool -> [String] -> [String] -> Result
arbitrary :: Arbitrary a => Gen a
arguments :: Result -> [String]
check :: Testable a => Config -> a -> IO ()
choose :: Random a => (a, a) -> Gen a
class Arbitrary a
class Testable a
classify :: Testable a => Bool -> String -> a -> Property
coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
collect :: (Show a, Testable b) => a -> b -> Property
configEvery :: Config -> Int -> [String] -> String
configMaxFail :: Config -> Int
configMaxTest :: Config -> Int
configSize :: Config -> Int -> Int
data Config
data Gen a
data Property
data Result
defaultConfig :: Config
elements :: [a] -> Gen a
evaluate :: Testable a => a -> Gen Result
forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
four :: Monad m => m a -> m (a, a, a, a)
frequency :: [(Int, Gen a)] -> Gen a
generate :: Int -> StdGen -> Gen a -> a
instance Functor Gen
instance Monad Gen
instance Testable Property
instance Testable Result
label :: Testable a => String -> a -> Property
ok :: Result -> Maybe Bool
oneof :: [Gen a] -> Gen a
promote :: (a -> Gen b) -> Gen (a -> b)
property :: Testable a => a -> Property
quickCheck :: Testable a => a -> IO ()
rand :: Gen StdGen
resize :: Int -> Gen a -> Gen a
sized :: (Int -> Gen a) -> Gen a
stamp :: Result -> [String]
test :: Testable a => a -> IO ()
three :: Monad m => m a -> m (a, a, a)
trivial :: Testable a => Bool -> a -> Property
two :: Monad m => m a -> m (a, a)
variant :: Int -> Gen a -> Gen a
vector :: Arbitrary a => Int -> Gen [a]
verboseCheck :: Testable a => a -> IO ()

module Test.QuickCheck.Batch
TestAborted :: Exception -> TestResult
TestExausted :: String -> Int -> [[String]] -> TestResult
TestFailed :: [String] -> Int -> TestResult
TestOk :: String -> Int -> [[String]] -> TestResult
TestOptions :: Int -> Int -> Bool -> TestOptions
bottom :: a
data TestOptions
data TestResult
debug_tests :: TestOptions -> Bool
defOpt :: TestOptions
isBottom :: a -> Bool
length_of_tests :: TestOptions -> Int
no_of_tests :: TestOptions -> Int
run :: Testable a => a -> TestOptions -> IO TestResult
runTests :: String -> TestOptions -> [TestOptions -> IO TestResult] -> IO ()

module Test.QuickCheck.Poly
type ALPHA = Poly ALPHA_
type BETA = Poly BETA_
type GAMMA = Poly GAMMA_
type OrdALPHA = Poly OrdALPHA_
type OrdBETA = Poly OrdBETA_
type OrdGAMMA = Poly OrdGAMMA_

module Test.QuickCheck.Utils
isAssociative :: (Arbitrary a, Show a, Eq a) => (a -> a -> a) -> Property
isAssociativeBy :: (Show a, Testable prop) => (a -> a -> prop) -> Gen a -> (a -> a -> a) -> Property
isCommutable :: (Arbitrary a, Show a, Eq b) => (a -> a -> b) -> Property
isCommutableBy :: (Show a, Testable prop) => (b -> b -> prop) -> Gen a -> (a -> a -> b) -> Property
isTotalOrder :: (Arbitrary a, Show a, Ord a) => a -> a -> Property

module Text.Html
(!) :: ADDATTRS a => a -> [HtmlAttr] -> a
(+++) :: (HTML a, HTML b) => a -> b -> Html
(<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
(</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
(<<) :: HTML a => (Html -> b) -> a -> b
HotLink :: URL -> [Html] -> [HtmlAttr] -> HotLink
Html :: [HtmlElement] -> Html
HtmlAttr :: String -> String -> HtmlAttr
HtmlLeaf :: Html -> HtmlTree
HtmlNode :: Html -> [HtmlTree] -> Html -> HtmlTree
HtmlString :: String -> HtmlElement
HtmlTable :: (BlockTable (Int -> Int -> Html)) -> HtmlTable
HtmlTag :: String -> [HtmlAttr] -> Html -> HtmlElement
above :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
aboves :: HTMLTABLE ht => [ht] -> HtmlTable
action :: String -> HtmlAttr
address :: Html -> Html
afile :: String -> Html
align :: String -> HtmlAttr
alink :: String -> HtmlAttr
alt :: String -> HtmlAttr
altcode :: String -> HtmlAttr
anchor :: Html -> Html
applet :: Html -> Html
aqua :: String
archive :: String -> HtmlAttr
area :: Html
background :: String -> HtmlAttr
base :: String -> HtmlAttr
basefont :: Html
beside :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
besides :: HTMLTABLE ht => [ht] -> HtmlTable
bgcolor :: String -> HtmlAttr
big :: Html -> Html
black :: String
blockquote :: Html -> Html
blue :: String
body :: Html -> Html
bold :: Html -> Html
border :: Int -> HtmlAttr
bordercolor :: String -> HtmlAttr
br :: Html
bullet :: Html
caption :: Html -> Html
cell :: HTMLTABLE ht => ht -> HtmlTable
cellpadding :: Int -> HtmlAttr
cellspacing :: Int -> HtmlAttr
center :: Html -> Html
checkbox :: String -> String -> Html
checked :: HtmlAttr
cite :: Html -> Html
class ADDATTRS a
class HTML a
class HTMLTABLE ht
clear :: String -> HtmlAttr
clickmap :: String -> Html
code :: String -> HtmlAttr
codebase :: String -> HtmlAttr
color :: String -> HtmlAttr
cols :: String -> HtmlAttr
colspan :: Int -> HtmlAttr
compact :: HtmlAttr
concatHtml :: HTML a => [a] -> Html
content :: String -> HtmlAttr
coords :: String -> HtmlAttr
copyright :: Html
data HotLink
data HtmlAttr
data HtmlElement
data HtmlTree
ddef :: Html -> Html
debugHtml :: HTML a => a -> Html
defList :: (HTML a, HTML b) => [(a, b)] -> Html
define :: Html -> Html
dlist :: Html -> Html
dterm :: Html -> Html
emphasize :: Html -> Html
emptyAttr :: String -> HtmlAttr
enctype :: String -> HtmlAttr
face :: String -> HtmlAttr
fieldset :: Html -> Html
font :: Html -> Html
form :: Html -> Html
frame :: Html -> Html
frameborder :: Int -> HtmlAttr
frameset :: Html -> Html
fuchsia :: String
getHtmlElements :: Html -> [HtmlElement]
gray :: String
green :: String
gui :: String -> Html -> Html
h1 :: Html -> Html
h2 :: Html -> Html
h3 :: Html -> Html
h4 :: Html -> Html
h5 :: Html -> Html
h6 :: Html -> Html
header :: Html -> Html
height :: Int -> HtmlAttr
hidden :: String -> String -> Html
hotLinkAttributes :: HotLink -> [HtmlAttr]
hotLinkContents :: HotLink -> [Html]
hotLinkURL :: HotLink -> URL
hotlink :: URL -> [Html] -> HotLink
hr :: Html
href :: String -> HtmlAttr
hspace :: Int -> HtmlAttr
httpequiv :: String -> HtmlAttr
identifier :: String -> HtmlAttr
image :: Html
input :: Html
instance ADDATTRS Html
instance HTML HotLink
instance HTML Html
instance HTML HtmlTable
instance HTML HtmlTree
instance HTMLTABLE Html
instance HTMLTABLE HtmlTable
instance Show HotLink
instance Show Html
instance Show HtmlAttr
instance Show HtmlTable
intAttr :: String -> Int -> HtmlAttr
ismap :: HtmlAttr
itag :: String -> Html
italics :: Html -> Html
keyboard :: Html -> Html
lang :: String -> HtmlAttr
legend :: Html -> Html
li :: Html -> Html
lime :: String
lineToHtml :: String -> Html
linesToHtml :: [String] -> Html
link :: String -> HtmlAttr
marginheight :: Int -> HtmlAttr
marginwidth :: Int -> HtmlAttr
markupAttrs :: HtmlElement -> [HtmlAttr]
markupContent :: HtmlElement -> Html
markupTag :: HtmlElement -> String
maroon :: String
maxlength :: Int -> HtmlAttr
menu :: String -> [Html] -> Html
meta :: Html
method :: String -> HtmlAttr
mkHtmlTable :: BlockTable (Int -> Int -> Html) -> HtmlTable
multiple :: HtmlAttr
name :: String -> HtmlAttr
navy :: String
newtype Html
newtype HtmlTable
noHtml :: Html
noframes :: Html -> Html
nohref :: HtmlAttr
noresize :: HtmlAttr
noshade :: HtmlAttr
nowrap :: HtmlAttr
olist :: Html -> Html
olive :: String
option :: Html -> Html
ordList :: HTML a => [a] -> Html
p :: Html -> Html
paragraph :: Html -> Html
param :: Html
password :: String -> Html
pre :: Html -> Html
prettyHtml :: HTML html => html -> String
prettyHtml' :: HtmlElement -> [String]
primHtml :: String -> Html
primHtmlChar :: String -> Html
purple :: String
radio :: String -> String -> Html
red :: String
rel :: String -> HtmlAttr
renderHtml :: HTML html => html -> String
renderHtml' :: Int -> HtmlElement -> ShowS
renderTable :: BlockTable (Int -> Int -> Html) -> Html
renderTag :: Bool -> String -> [HtmlAttr] -> Int -> ShowS
reset :: String -> String -> Html
rev :: String -> HtmlAttr
rows :: String -> HtmlAttr
rowspan :: Int -> HtmlAttr
rules :: String -> HtmlAttr
sample :: Html -> Html
scrolling :: String -> HtmlAttr
select :: Html -> Html
selected :: HtmlAttr
shape :: String -> HtmlAttr
silver :: String
simpleTable :: [HtmlAttr] -> [HtmlAttr] -> [[Html]] -> Html
size :: String -> HtmlAttr
small :: Html -> Html
spaceHtml :: Html
src :: String -> HtmlAttr
start :: Int -> HtmlAttr
strAttr :: String -> String -> HtmlAttr
stringToHtml :: String -> Html
stringToHtmlString :: String -> String
strong :: Html -> Html
style :: Html -> Html
sub :: Html -> Html
submit :: String -> String -> Html
sup :: Html -> Html
table :: Html -> Html
tag :: String -> Html -> Html
target :: String -> HtmlAttr
td :: Html -> Html
teal :: String
text :: String -> HtmlAttr
textarea :: Html -> Html
textfield :: String -> Html
th :: Html -> Html
thebase :: Html
theclass :: String -> HtmlAttr
thecode :: Html -> Html
thediv :: Html -> Html
thehtml :: Html -> Html
thelink :: Html -> Html
themap :: Html -> Html
thespan :: Html -> Html
thestyle :: String -> HtmlAttr
thetitle :: Html -> Html
thetype :: String -> HtmlAttr
title :: String -> HtmlAttr
toHtml :: HTML a => a -> Html
toHtmlFromList :: HTML a => [a] -> Html
tr :: Html -> Html
treeHtml :: [String] -> HtmlTree -> Html
tt :: Html -> Html
type URL = String
ulist :: Html -> Html
underline :: Html -> Html
unordList :: HTML a => [a] -> Html
usemap :: String -> HtmlAttr
validHtmlAttrs :: [String]
validHtmlITags :: [String]
validHtmlTags :: [String]
valign :: String -> HtmlAttr
value :: String -> HtmlAttr
variable :: Html -> Html
version :: String -> HtmlAttr
vlink :: String -> HtmlAttr
vspace :: Int -> HtmlAttr
white :: String
widget :: String -> String -> [HtmlAttr] -> Html
width :: String -> HtmlAttr
yellow :: String

module Text.Html.BlockTable
above :: BlockTable a -> BlockTable a -> BlockTable a
beside :: BlockTable a -> BlockTable a -> BlockTable a
data BlockTable a
getMatrix :: BlockTable a -> [[(a, (Int, Int))]]
instance Show a => Show (BlockTable a)
showTable :: Show a => BlockTable a -> String
showsTable :: Show a => BlockTable a -> ShowS
single :: a -> BlockTable a

module Text.ParserCombinators.Parsec
data ParseError
data SourcePos
errorPos :: ParseError -> SourcePos
incSourceColumn :: SourcePos -> Column -> SourcePos
incSourceLine :: SourcePos -> Line -> SourcePos
instance Eq SourcePos
instance Ord SourcePos
instance Show ParseError
instance Show SourcePos
setSourceColumn :: SourcePos -> Column -> SourcePos
setSourceLine :: SourcePos -> Line -> SourcePos
setSourceName :: SourcePos -> SourceName -> SourcePos
sourceColumn :: SourcePos -> Column
sourceLine :: SourcePos -> Line
sourceName :: SourcePos -> SourceName
type Column = Int
type Line = Int
type SourceName = String

module Text.ParserCombinators.Parsec.Char
alphaNum :: CharParser st Char
anyChar :: CharParser st Char
char :: Char -> CharParser st Char
digit :: CharParser st Char
hexDigit :: CharParser st Char
letter :: CharParser st Char
lower :: CharParser st Char
newline :: CharParser st Char
noneOf :: [Char] -> CharParser st Char
octDigit :: CharParser st Char
oneOf :: [Char] -> CharParser st Char
satisfy :: (Char -> Bool) -> CharParser st Char
space :: CharParser st Char
spaces :: CharParser st ()
string :: String -> CharParser st String
tab :: CharParser st Char
type CharParser st a = GenParser Char st a
upper :: CharParser st Char

module Text.ParserCombinators.Parsec.Combinator
anyToken :: Show tok => GenParser tok st tok
between :: GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a
chainl :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a
chainl1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a
chainr :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a
chainr1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a
choice :: [GenParser tok st a] -> GenParser tok st a
count :: Int -> GenParser tok st a -> GenParser tok st [a]
endBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
endBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
eof :: Show tok => GenParser tok st ()
lookAhead :: GenParser tok st a -> GenParser tok st a
many1 :: GenParser tok st a -> GenParser tok st [a]
manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]
notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
option :: a -> GenParser tok st a -> GenParser tok st a
optional :: GenParser tok st a -> GenParser tok st ()
sepBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
sepBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
sepEndBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
sepEndBy1 :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
skipMany1 :: GenParser tok st a -> GenParser tok st ()

module Text.ParserCombinators.Parsec.Error
Expect :: !String -> Message
Message :: !String -> Message
SysUnExpect :: !String -> Message
UnExpect :: !String -> Message
addErrorMessage :: Message -> ParseError -> ParseError
data Message
errorIsUnknown :: ParseError -> Bool
errorMessages :: ParseError -> [Message]
mergeError :: ParseError -> ParseError -> ParseError
messageCompare :: Message -> Message -> Ordering
messageEq :: Message -> Message -> Bool
messageString :: Message -> String
newErrorMessage :: Message -> SourcePos -> ParseError
newErrorUnknown :: SourcePos -> ParseError
setErrorMessage :: Message -> ParseError -> ParseError
setErrorPos :: SourcePos -> ParseError -> ParseError
showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String

module Text.ParserCombinators.Parsec.Expr
AssocLeft :: Assoc
AssocNone :: Assoc
AssocRight :: Assoc
Infix :: (GenParser t st (a -> a -> a)) -> Assoc -> Operator t st a
Postfix :: (GenParser t st (a -> a)) -> Operator t st a
Prefix :: (GenParser t st (a -> a)) -> Operator t st a
buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
data Assoc
data Operator t st a
type OperatorTable t st a = [[Operator t st a]]

module Text.ParserCombinators.Parsec.Language
LanguageDef :: String -> String -> String -> Bool -> CharParser st Char -> CharParser st Char -> CharParser st Char -> CharParser st Char -> [String] -> [String] -> Bool -> LanguageDef st
caseSensitive :: LanguageDef st -> Bool
commentEnd :: LanguageDef st -> String
commentLine :: LanguageDef st -> String
commentStart :: LanguageDef st -> String
data LanguageDef st
emptyDef :: LanguageDef st
haskell :: TokenParser st
haskellDef :: LanguageDef st
haskellStyle :: LanguageDef st
identLetter :: LanguageDef st -> CharParser st Char
identStart :: LanguageDef st -> CharParser st Char
javaStyle :: LanguageDef st
mondrian :: TokenParser st
mondrianDef :: LanguageDef st
nestedComments :: LanguageDef st -> Bool
opLetter :: LanguageDef st -> CharParser st Char
opStart :: LanguageDef st -> CharParser st Char
reservedNames :: LanguageDef st -> [String]
reservedOpNames :: LanguageDef st -> [String]

module Text.ParserCombinators.Parsec.Perm
(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b
(<$?>) :: (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
(<|?>) :: PermParser tok st (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
(<||>) :: PermParser tok st (a -> b) -> GenParser tok st a -> PermParser tok st b
data PermParser tok st a
permute :: PermParser tok st a -> GenParser tok st a

module Text.ParserCombinators.Parsec.Pos
initialPos :: SourceName -> SourcePos
newPos :: SourceName -> Line -> Column -> SourcePos
updatePosChar :: SourcePos -> Char -> SourcePos
updatePosString :: SourcePos -> String -> SourcePos

module Text.ParserCombinators.Parsec.Prim
(<?>) :: GenParser tok st a -> String -> GenParser tok st a
(<|>) :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a
State :: [tok] -> !SourcePos -> !st -> State tok st
data GenParser tok st a
data State tok st
getInput :: GenParser tok st [tok]
getParserState :: GenParser tok st (State tok st)
getPosition :: GenParser tok st SourcePos
getState :: GenParser tok st st
instance Functor (GenParser tok st)
instance Monad (GenParser tok st)
instance MonadPlus (GenParser tok st)
label :: GenParser tok st a -> String -> GenParser tok st a
labels :: GenParser tok st a -> [String] -> GenParser tok st a
many :: GenParser tok st a -> GenParser tok st [a]
parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)
parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()
pzero :: GenParser tok st a
runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
setInput :: [tok] -> GenParser tok st ()
setParserState :: State tok st -> GenParser tok st (State tok st)
setPosition :: SourcePos -> GenParser tok st ()
setState :: st -> GenParser tok st ()
skipMany :: GenParser tok st a -> GenParser tok st ()
stateInput :: State tok st -> [tok]
statePos :: State tok st -> !SourcePos
stateUser :: State tok st -> !st
token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
tokenPrim :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
tokenPrimEx :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> Maybe (SourcePos -> tok -> [tok] -> st -> st) -> (tok -> Maybe a) -> GenParser tok st a
tokens :: Eq tok => ([tok] -> String) -> (SourcePos -> [tok] -> SourcePos) -> [tok] -> GenParser tok st [tok]
try :: GenParser tok st a -> GenParser tok st a
type Parser a = GenParser Char () a
unexpected :: String -> GenParser tok st a
updateState :: (st -> st) -> GenParser tok st ()

module Text.ParserCombinators.Parsec.Token
TokenParser :: CharParser st String -> (String -> CharParser st ()) -> CharParser st String -> (String -> CharParser st ()) -> CharParser st Char -> CharParser st String -> CharParser st Integer -> CharParser st Integer -> CharParser st Double -> (CharParser st (Either Integer Double)) -> CharParser st Integer -> CharParser st Integer -> CharParser st Integer -> String -> CharParser st String -> CharParser st a -> CharParser st a -> (CharParser st ()) -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st a -> CharParser st String -> CharParser st String -> CharParser st String -> CharParser st String -> CharParser st a -> CharParser st [a] -> CharParser st a -> CharParser st [a] -> CharParser st a -> CharParser st [a] -> CharParser st a -> CharParser st [a] -> TokenParser st
angles :: TokenParser st -> CharParser st a -> CharParser st a
braces :: TokenParser st -> CharParser st a -> CharParser st a
brackets :: TokenParser st -> CharParser st a -> CharParser st a
charLiteral :: TokenParser st -> CharParser st Char
colon :: TokenParser st -> CharParser st String
comma :: TokenParser st -> CharParser st String
commaSep :: TokenParser st -> CharParser st a -> CharParser st [a]
commaSep1 :: TokenParser st -> CharParser st a -> CharParser st [a]
data TokenParser st
decimal :: TokenParser st -> CharParser st Integer
dot :: TokenParser st -> CharParser st String
float :: TokenParser st -> CharParser st Double
hexadecimal :: TokenParser st -> CharParser st Integer
identifier :: TokenParser st -> CharParser st String
integer :: TokenParser st -> CharParser st Integer
lexeme :: TokenParser st -> CharParser st a -> CharParser st a
makeTokenParser :: LanguageDef st -> TokenParser st
natural :: TokenParser st -> CharParser st Integer
naturalOrFloat :: TokenParser st -> (CharParser st (Either Integer Double))
octal :: TokenParser st -> CharParser st Integer
operator :: TokenParser st -> CharParser st String
parens :: TokenParser st -> CharParser st a -> CharParser st a
reserved :: TokenParser st -> (String -> CharParser st ())
reservedOp :: TokenParser st -> (String -> CharParser st ())
semi :: TokenParser st -> CharParser st String
semiSep :: TokenParser st -> CharParser st a -> CharParser st [a]
semiSep1 :: TokenParser st -> CharParser st a -> CharParser st [a]
squares :: TokenParser st -> CharParser st a -> CharParser st a
stringLiteral :: TokenParser st -> CharParser st String
symbol :: TokenParser st -> String -> CharParser st String
whiteSpace :: TokenParser st -> (CharParser st ())

module Text.ParserCombinators.ReadP
(+++) :: ReadP a -> ReadP a -> ReadP a
(<++) :: ReadP a -> ReadP a -> ReadP a
between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
char :: Char -> ReadP Char
choice :: [ReadP a] -> ReadP a
count :: Int -> ReadP a -> ReadP [a]
data ReadP a
endBy :: ReadP a -> ReadP sep -> ReadP [a]
endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
gather :: ReadP a -> ReadP (String, a)
get :: ReadP Char
instance Functor ReadP
instance Monad ReadP
instance MonadPlus ReadP
look :: ReadP String
many :: ReadP a -> ReadP [a]
many1 :: ReadP a -> ReadP [a]
manyTill :: ReadP a -> ReadP end -> ReadP [a]
munch :: (Char -> Bool) -> ReadP String
munch1 :: (Char -> Bool) -> ReadP String
option :: a -> ReadP a -> ReadP a
optional :: ReadP a -> ReadP ()
pfail :: ReadP a
readP_to_S :: ReadP a -> ReadS a
readS_to_P :: ReadS a -> ReadP a
satisfy :: (Char -> Bool) -> ReadP Char
sepBy :: ReadP a -> ReadP sep -> ReadP [a]
sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
skipMany :: ReadP a -> ReadP ()
skipMany1 :: ReadP a -> ReadP ()
skipSpaces :: ReadP ()
string :: String -> ReadP String

module Text.ParserCombinators.ReadPrec
(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
choice :: [ReadPrec a] -> ReadPrec a
data ReadPrec a
get :: ReadPrec Char
instance Functor ReadPrec
instance Monad ReadPrec
instance MonadPlus ReadPrec
lift :: ReadP a -> ReadPrec a
look :: ReadPrec String
minPrec :: Prec
pfail :: ReadPrec a
prec :: Prec -> ReadPrec a -> ReadPrec a
readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readPrec_to_P :: ReadPrec a -> Int -> ReadP a
readPrec_to_S :: ReadPrec a -> Int -> ReadS a
readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
reset :: ReadPrec a -> ReadPrec a
step :: ReadPrec a -> ReadPrec a
type Prec = Int

module Text.PrettyPrint.HughesPJ
($$) :: Doc -> Doc -> Doc
($+$) :: Doc -> Doc -> Doc
(<+>) :: Doc -> Doc -> Doc
(<>) :: Doc -> Doc -> Doc
Chr :: Char -> TextDetails
LeftMode :: Mode
OneLineMode :: Mode
PStr :: String -> TextDetails
PageMode :: Mode
Str :: String -> TextDetails
Style :: Mode -> Int -> Float -> Style
ZigZagMode :: Mode
braces :: Doc -> Doc
brackets :: Doc -> Doc
cat :: [Doc] -> Doc
char :: Char -> Doc
colon :: Doc
comma :: Doc
data Doc
data Mode
data Style
data TextDetails
double :: Double -> Doc
doubleQuotes :: Doc -> Doc
empty :: Doc
equals :: Doc
fcat :: [Doc] -> Doc
float :: Float -> Doc
fsep :: [Doc] -> Doc
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a
hang :: Doc -> Int -> Doc -> Doc
hcat :: [Doc] -> Doc
hsep :: [Doc] -> Doc
instance Show Doc
int :: Int -> Doc
integer :: Integer -> Doc
isEmpty :: Doc -> Bool
lbrace :: Doc
lbrack :: Doc
lineLength :: Style -> Int
lparen :: Doc
mode :: Style -> Mode
nest :: Int -> Doc -> Doc
parens :: Doc -> Doc
ptext :: String -> Doc
punctuate :: Doc -> [Doc] -> [Doc]
quotes :: Doc -> Doc
rational :: Rational -> Doc
rbrace :: Doc
rbrack :: Doc
render :: Doc -> String
renderStyle :: Style -> Doc -> String
ribbonsPerLine :: Style -> Float
rparen :: Doc
semi :: Doc
sep :: [Doc] -> Doc
space :: Doc
style :: Style
text :: String -> Doc
vcat :: [Doc] -> Doc

module Text.Printf
class HPrint
class I
class Prin
class Print
hPrintf :: HPrintfType r => Handle -> String -> r
printf :: PrintfType r => String -> r

module Text.Read
Char :: Char -> Lexeme
EOF :: Lexeme
Ident :: String -> Lexeme
Int :: Integer -> Lexeme
Punc :: String -> Lexeme
Rat :: Rational -> Lexeme
String :: String -> Lexeme
Symbol :: String -> Lexeme
data Lexeme
instance Eq Lexeme
instance Read Lexeme
instance Show Lexeme
lexP :: ReadPrec Lexeme
readListDefault :: Read a => ReadS [a]
readListPrec :: Read a => ReadPrec [a]
readListPrecDefault :: Read a => ReadPrec [a]
readPrec :: Read a => ReadPrec a

module Text.Read.Lex
hsLex :: ReadP String
lex :: ReadP Lexeme
lexChar :: ReadP Char
readDecP :: Num a => ReadP a
readHexP :: Num a => ReadP a
readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readOctP :: Num a => ReadP a

module Text.Regex
data Regex
matchRegex :: Regex -> String -> Maybe [String]
matchRegexAll :: Regex -> String -> Maybe (String, String, String, [String])
mkRegex :: String -> Regex
mkRegexWithOpts :: String -> Bool -> Bool -> Regex
splitRegex :: Regex -> String -> [String]
subRegex :: Regex -> String -> String -> String

module Text.Regex.Posix
regExtended :: Int
regIgnoreCase :: Int
regNewline :: Int
regcomp :: String -> Int -> IO Regex
regexec :: Regex -> String -> IO (Maybe (String, String, String, [String]))

module Text.Show
showListWith :: (a -> ShowS) -> [a] -> ShowS

module Time
addToClockTime :: TimeDiff -> ClockTime -> ClockTime
calendarTimeToString :: CalendarTime -> String
diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
getClockTime :: IO ClockTime
toCalendarTime :: ClockTime -> IO CalendarTime
toClockTime :: CalendarTime -> ClockTime
toUTCTime :: ClockTime -> CalendarTime
