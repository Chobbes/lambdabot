id :: a -> a
id x1 = x1
const :: a -> b -> a
const x1 _ = x1
fst :: (a, b) -> a
fst (v2, _) = v2
snd :: (a, b) -> b
snd (_, v3) = v3
swap :: (a, b) -> (b, a)
swap (v2, v3) = (v3, v2)
compose :: (b -> c) -> (a -> b) -> a -> c
compose x1 x2 x3 = x1 (x2 x3)
curry :: ((a, b) -> c) -> a -> b -> c
curry x1 x3 x4 = x1 (x3, x4)
uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry x1 (v3, v4) = x1 v3 v4
flip :: (a -> b -> c) -> b -> a -> c
flip x1 x2 x3 = x1 x3 x2
-- undefined cannot be realized.
either :: (a -> b) -> (c -> b) -> Either a c -> b
either x1 x2 x3 =
         case x3 of
         Left v6 -> x1 v6
         Right v7 -> x2 v7
returnC :: a -> C a
returnC x1 x2 = x2 x1
bindC :: C a -> (a -> C b) -> C b
bindC x1 x2 x3 = x1 (\ c15 -> x2 c15 x3)
callCC :: ((a -> C b) -> C a) -> C a
callCC x1 x2 = x1 (\ c15 _ -> x2 c15) x2
returnS :: a -> S s a
returnS x1 x2 = (x1, x2)
bindS :: S s a -> (a -> S s b) -> S s b
bindS x1 x2 x3 =
        case x1 x3 of
        (v4, v5) -> x2 v4 v5
returnSD :: a -> SD s a
returnSD x1 = SD (\ c16 -> (x1, c16))
bindSD :: SD s a -> (a -> SD s b) -> SD s b
bindSD x1 x4 =
         case x1 of
         SD v3 -> SD (\ c31 ->
                      case v3 c31 of
                      (c32, c33) -> case x4 c32 of
                                    SD c35 -> c35 c33)
returnCD :: a -> CD r a
returnCD x1 = CD (\ c15 -> c15 x1)
bindCD :: CD r a -> (a -> CD r b) -> CD r b
bindCD x1 x4 =
         case x1 of
         CD v3 -> CD (\ c49 ->
                      v3 (\ c50 ->
                          case x4 c50 of
                          CD c52 -> c52 c49))
callCCD :: ((a -> CD r b) -> CD r a) -> CD r a
callCCD x1 =
          CD (\ c68 ->
              case x1 (\ c69 -> CD (\ _ -> c68 c69)) of
              CD c72 -> c72 c68)
bindM :: Maybe a -> (a -> Maybe b) -> Maybe b
bindM x1 =
        case x1 of
        Nothing -> \ _ -> Nothing
        Just v8 -> \ x9 -> x9 v8
rot :: (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z) -> (z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
rot (v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
     v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) =
      (v27, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
       v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
f :: Either () (a, b) -> Either () (b, a)
f x1 =
    case x1 of
    Left _ -> Left ()
    Right (v15, v16) -> Right (v16, v15)
f :: a -> a -> a
f _ x2 = x2
-- or
f x1 _ = x1
f :: Either () (a, b) -> Either () (b, a)
f x1 =
    case x1 of
    Left _ -> Left ()
    Right (v15, v16) -> Right (v16, v15)
-- or
f _ = Left ()
-- or
f _ = Left ()
-- or
f _ = Left ()
f :: a -> (a -> a) -> a
f x1 x2 = x2 x1
-- or
f x1 _ = x1
-- or
f x1 _ = x1
f :: (a -> a) -> a -> a
f x1 x2 = x1 x2
-- or
f _ x2 = x2
f1 :: ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
f1 x1 =
     x1 (\ c64 ->
         Right (\ _ ->
                x1 (\ _ ->
                    Right (\ c148 ->
                           x1 (\ _ ->
                               Right (\ _ ->
                                      x1 (\ _ ->
                                          Left (\ c152 ->
                                                x1 (\ _ -> Right (\ _ -> c64 (c152, c148)))))))))))
f2 :: ((Either (a -> f) (b -> f) -> (a, b) -> f) -> f) -> f
f2 x1 =
     x1 (\ c16 ->
         case c16 of
         Left c18 -> \ (c20, _) -> c18 c20
         Right c23 -> \ (_, c26) -> c23 c26)
null :: List a -> Bool
null x7 =
       case out x7 of
       Nil -> True
       Cons _ _ -> False
