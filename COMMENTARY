                            COMMENTARY ON LAMBDABOT
                            ------------------------

Authors: Don Stewart

------------------------------------------------------------------------

Current module tree.

(lambdabot : static) 
    +- Boot -+- hs-plugins
            -+- Shared
            -+- Map

(plugins : dynamic)
        +-- Main
            IRC
            Shared
            Config
            DeepSeq
            ErrorUtils
            ExceptionError
            MonadException
            Map
            Util
            Modules -+ SystemModule
                       BaseModule
                       DynamicModule ...<dynload>... [*Module.o plugins]
                                                        +Set
                                                        +MiniHTTP ...

The static binary only contains hs-plugins.

------------------------------------------------------------------------

Plugins live in Plugins/ and inhabit the Plugins.* namespace.

------------------------------------------------------------------------

INOVKING COMMANDS

Each plugin lists the commands it will provide in its Module instance.
Commands to lambdabot are prefixed with certain magic characters,
described in Plugins/Base.hs. 

ONLINE/OFFLINE MODES

Lambdabot can run in an offline mode. This is in fact the default mode
now, and invoking lambdabot with --online is the way to connect to an
irc server. Otherwise you just get a prompt, and a chance to interact
with the plugins.

DEVELOPMENT

When testing out a new plugin,
    0) test out the plugin in ghci in isolation. don't both linking the
    rest of the bot.
then try:
    a) compile with "way=fast" . This is substantially faster
    b) don't go online, just use offline mode
or try:

GHCI:

I'm experimenting in ghci these days. its a faster turn around, though
you'll need at least 250M if you're doing a lot of reloading. Also, it
helps to compile all the objects first, so they run a bit faster.

    $ sh ./configure
    -- edit Config.hs to your requirements
    $ make way=ghci

then use
    *Main> main
or
    *Main> online

To then try out changes, try:
    *Main> :reload


ADDING A NEW PLUGIN

* Just create the module in Plugins/*
* Ensure it implements the Module class (see Hello.hs for the bare minimum).
* Add your plugin's module name to config.mk.in, for the static and dynamic plugin lists.
* import Plugin to get most common functions
* rebuild using gmake, to get genmodules to regenerate Modules.hs

N.B. you need to use the make path, not cabal, to regenerate the Modules.hs file.

PLUGIN STATE

Plugins may have local state. If a plugin provides an Serialiser (via
the moduleSerialize method), this state will be automatically read and
written to disk on module load/unload, respectively.

A default state may be provided via the `moduleDefState` method.

LIBRARIES

Libraries of common functoins are in Lib, they include code for:
    * munging strings
    * getting random elements
    * serialising data
    * doing regexes on packed strings
read the Lib/README for more info

Most of these libs are available when you import Plugin, some require
explicit imports.
